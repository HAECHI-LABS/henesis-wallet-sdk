/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://dev.wallet.henesis.io/docs/v2/accounts".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccessTokenDTO
 */
export interface AccessTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenDTO
     */
    accessToken: string;
}

/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    organizationId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountDTO
     */
    roles: Array<AccountDTO.RolesEnum>;
}

/**
 * @export
 * @namespace AccountDTO
 */
export namespace AccountDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        COIN = <any> 'COIN',
        VIEWER = <any> 'VIEWER',
        ADMIN = <any> 'ADMIN',
        HAECHI = <any> 'HAECHI',
        SPENDER = <any> 'SPENDER'
    }
}

/**
 * 
 * @export
 * @interface ChangeAccountNameRequest
 */
export interface ChangeAccountNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    lastName: string;
}

/**
 * 
 * @export
 * @interface CreateAccessTokenRequest
 */
export interface CreateAccessTokenRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateAccessTokenRequest
     */
    expiresIn: number;
}

/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateSecretResponse
 */
export interface CreateSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateSecretResponse
     */
    secret: string;
}

/**
 * 
 * @export
 * @interface CreateWithdrawalApprovalRequest
 */
export interface CreateWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    masterWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    transferAt: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    userWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    walletName: string;
}

/**
 * 
 * @export
 * @interface IdentityDTO
 */
export interface IdentityDTO {
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationSecret: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    otpKey: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDTO
     */
    roles: Array<IdentityDTO.RolesEnum>;
}

/**
 * @export
 * @namespace IdentityDTO
 */
export namespace IdentityDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        COIN = <any> 'COIN',
        VIEWER = <any> 'VIEWER',
        ADMIN = <any> 'ADMIN',
        HAECHI = <any> 'HAECHI',
        SPENDER = <any> 'SPENDER'
    }
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    templated?: boolean;
}

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}

/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    organizationId: string;
    /**
     * 
     * @type {OTPDTO}
     * @memberof LoginResponse
     */
    otp: OTPDTO;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginResponse
     */
    roles: Array<LoginResponse.RolesEnum>;
}

/**
 * @export
 * @namespace LoginResponse
 */
export namespace LoginResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        COIN = <any> 'COIN',
        VIEWER = <any> 'VIEWER',
        ADMIN = <any> 'ADMIN',
        HAECHI = <any> 'HAECHI',
        SPENDER = <any> 'SPENDER'
    }
}

/**
 * 
 * @export
 * @interface MapstringLink
 */
export interface MapstringLink {
    [key: string]: Link;

}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _425TOOEARLY = <any> '425 TOO_EARLY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}

/**
 * 
 * @export
 * @interface OTPDTO
 */
export interface OTPDTO {
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    url: string;
}

/**
 * 
 * @export
 * @interface OrgAccountDTO
 */
export interface OrgAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    lastName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrgAccountDTO
     */
    roles: Array<OrgAccountDTO.RolesEnum>;
}

/**
 * @export
 * @namespace OrgAccountDTO
 */
export namespace OrgAccountDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        COIN = <any> 'COIN',
        VIEWER = <any> 'VIEWER',
        ADMIN = <any> 'ADMIN',
        HAECHI = <any> 'HAECHI',
        SPENDER = <any> 'SPENDER'
    }
}

/**
 * 
 * @export
 * @interface OrganizationDTO
 */
export interface OrganizationDTO {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    secret: string;
}

/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}

/**
 * 
 * @export
 * @interface PaginationWithdrawalApprovalDTO
 */
export interface PaginationWithdrawalApprovalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WithdrawalApprovalDTO>}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    results: Array<WithdrawalApprovalDTO>;
}

/**
 * 
 * @export
 * @interface PatchAccountRoleRequest
 */
export interface PatchAccountRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    role: string;
}

/**
 * 
 * @export
 * @interface RefreshAccessTokenRequest
 */
export interface RefreshAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenRequest
     */
    otpCode?: string;
}

/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    role: string;
}

/**
 * 
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    organizationId: string;
}

/**
 * 
 * @export
 * @interface SimpleAccountDTO
 */
export interface SimpleAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    name: string;
}

/**
 * 
 * @export
 * @interface UpdateOTPInitializeRequest
 */
export interface UpdateOTPInitializeRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOTPInitializeRequest
     */
    initialize: boolean;
}

/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    newOrgId: string;
}

/**
 * 
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    password: string;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}

/**
 * 
 * @export
 * @interface WithdrawalApprovalDTO
 */
export interface WithdrawalApprovalDTO {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    amount: string;
    /**
     * 
     * @type {Array<SimpleAccountDTO>}
     * @memberof WithdrawalApprovalDTO
     */
    approvedBy: Array<SimpleAccountDTO>;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    blockchain: WithdrawalApprovalDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    masterWalletId: string;
    /**
     * 
     * @type {SimpleAccountDTO}
     * @memberof WithdrawalApprovalDTO
     */
    requester: SimpleAccountDTO;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    status: WithdrawalApprovalDTO.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    transferAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    userWalletId?: string;
}

/**
 * @export
 * @namespace WithdrawalApprovalDTO
 */
export namespace WithdrawalApprovalDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        REJECTED = <any> 'REJECTED',
        APPROVED = <any> 'APPROVED'
    }
}


/**
 * AccountControllerApi - fetch parameter creator
 * @export
 */
export const AccountControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary changeAccountName
         * @param {ChangeAccountNameRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountNameUsingPATCH(request: ChangeAccountNameRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling changeAccountNameUsingPATCH.');
            }
            const localVarPath = `/api/v2/accounts/name`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeAccountNameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/accounts/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessTokenUsingDELETE(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} request request
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingPOST(request: LoginRequest, browser?: string, ip?: string, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling loginUsingPOST.');
            }
            const localVarPath = `/api/v2/accounts/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (browser !== undefined) {
                localVarQueryParameter['browser'] = browser;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refreshShortAccessToken
         * @param {RefreshAccessTokenRequest} request request
         * @param {'short'} type 
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshShortAccessTokenUsingPOST(request: RefreshAccessTokenRequest, type: 'short', accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling refreshShortAccessTokenUsingPOST.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling refreshShortAccessTokenUsingPOST.');
            }
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RefreshAccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary register
         * @param {SignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST(request: SignUpRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling registerUsingPOST.');
            }
            const localVarPath = `/api/v2/accounts/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateOTPInitialize
         * @param {UpdateOTPInitializeRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitializeUsingPATCH(request: UpdateOTPInitializeRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateOTPInitializeUsingPATCH.');
            }
            const localVarPath = `/api/v2/accounts/otp-initialize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOTPInitializeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateOrganization
         * @param {UpdateOrganizationRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUsingPATCH(request: UpdateOrganizationRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateOrganizationUsingPATCH.');
            }
            const localVarPath = `/api/v2/accounts/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePassword
         * @param {UpdatePasswordRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordUsingPATCH(request: UpdatePasswordRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updatePasswordUsingPATCH.');
            }
            const localVarPath = `/api/v2/accounts/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePasswordRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary verifyIP
         * @param {string} identifier identifier
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIPUsingGET(identifier: string, browser?: string, ip?: string, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling verifyIPUsingGET.');
            }
            const localVarPath = `/api/v2/accounts/login/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (browser !== undefined) {
                localVarQueryParameter['browser'] = browser;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountControllerApi - functional programming interface
 * @export
 */
export const AccountControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary changeAccountName
         * @param {ChangeAccountNameRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountNameUsingPATCH(request: ChangeAccountNameRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDTO> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).changeAccountNameUsingPATCH(request, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDTO> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).createAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessTokenUsingDELETE(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).deleteAccessTokenUsingDELETE(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessTokenDTO> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).getAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} request request
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingPOST(request: LoginRequest, browser?: string, ip?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponse> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).loginUsingPOST(request, browser, ip, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary refreshShortAccessToken
         * @param {RefreshAccessTokenRequest} request request
         * @param {'short'} type 
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshShortAccessTokenUsingPOST(request: RefreshAccessTokenRequest, type: 'short', accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessTokenDTO> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).refreshShortAccessTokenUsingPOST(request, type, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary register
         * @param {SignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST(request: SignUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignUpResponse> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).registerUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateOTPInitialize
         * @param {UpdateOTPInitializeRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitializeUsingPATCH(request: UpdateOTPInitializeRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).updateOTPInitializeUsingPATCH(request, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateOrganization
         * @param {UpdateOrganizationRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUsingPATCH(request: UpdateOrganizationRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).updateOrganizationUsingPATCH(request, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updatePassword
         * @param {UpdatePasswordRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordUsingPATCH(request: UpdatePasswordRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).updatePasswordUsingPATCH(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary verifyIP
         * @param {string} identifier identifier
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIPUsingGET(identifier: string, browser?: string, ip?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountControllerApiFetchParamCreator(configuration).verifyIPUsingGET(identifier, browser, ip, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountControllerApi - factory interface
 * @export
 */
export const AccountControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary changeAccountName
         * @param {ChangeAccountNameRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountNameUsingPATCH(request: ChangeAccountNameRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).changeAccountNameUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).createAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessTokenUsingDELETE(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).deleteAccessTokenUsingDELETE(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAccessToken
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).getAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary login
         * @param {LoginRequest} request request
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingPOST(request: LoginRequest, browser?: string, ip?: string, options?: any) {
            return AccountControllerApiFp(configuration).loginUsingPOST(request, browser, ip, options)(fetch, basePath);
        },
        /**
         * 
         * @summary refreshShortAccessToken
         * @param {RefreshAccessTokenRequest} request request
         * @param {'short'} type 
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshShortAccessTokenUsingPOST(request: RefreshAccessTokenRequest, type: 'short', accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).refreshShortAccessTokenUsingPOST(request, type, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary register
         * @param {SignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUsingPOST(request: SignUpRequest, options?: any) {
            return AccountControllerApiFp(configuration).registerUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateOTPInitialize
         * @param {UpdateOTPInitializeRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitializeUsingPATCH(request: UpdateOTPInitializeRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).updateOTPInitializeUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateOrganization
         * @param {UpdateOrganizationRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUsingPATCH(request: UpdateOrganizationRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).updateOrganizationUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updatePassword
         * @param {UpdatePasswordRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordUsingPATCH(request: UpdatePasswordRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return AccountControllerApiFp(configuration).updatePasswordUsingPATCH(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary verifyIP
         * @param {string} identifier identifier
         * @param {string} [browser] 
         * @param {string} [ip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIPUsingGET(identifier: string, browser?: string, ip?: string, options?: any) {
            return AccountControllerApiFp(configuration).verifyIPUsingGET(identifier, browser, ip, options)(fetch, basePath);
        },
    };
};

/**
 * AccountControllerApi - object-oriented interface
 * @export
 * @class AccountControllerApi
 * @extends {BaseAPI}
 */
export class AccountControllerApi extends BaseAPI {
    /**
     * 
     * @summary changeAccountName
     * @param {ChangeAccountNameRequest} request request
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public changeAccountNameUsingPATCH(request: ChangeAccountNameRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).changeAccountNameUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createAccessToken
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public createAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).createAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteAccessToken
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public deleteAccessTokenUsingDELETE(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).deleteAccessTokenUsingDELETE(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAccessToken
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccessTokenUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).getAccessTokenUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary login
     * @param {LoginRequest} request request
     * @param {string} [browser] 
     * @param {string} [ip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public loginUsingPOST(request: LoginRequest, browser?: string, ip?: string, options?: any) {
        return AccountControllerApiFp(this.configuration).loginUsingPOST(request, browser, ip, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary refreshShortAccessToken
     * @param {RefreshAccessTokenRequest} request request
     * @param {'short'} type 
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public refreshShortAccessTokenUsingPOST(request: RefreshAccessTokenRequest, type: 'short', accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).refreshShortAccessTokenUsingPOST(request, type, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary register
     * @param {SignUpRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public registerUsingPOST(request: SignUpRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).registerUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateOTPInitialize
     * @param {UpdateOTPInitializeRequest} request request
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOTPInitializeUsingPATCH(request: UpdateOTPInitializeRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOTPInitializeUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateOrganization
     * @param {UpdateOrganizationRequest} request request
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOrganizationUsingPATCH(request: UpdateOrganizationRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOrganizationUsingPATCH(request, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updatePassword
     * @param {UpdatePasswordRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updatePasswordUsingPATCH(request: UpdatePasswordRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return AccountControllerApiFp(this.configuration).updatePasswordUsingPATCH(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary verifyIP
     * @param {string} identifier identifier
     * @param {string} [browser] 
     * @param {string} [ip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public verifyIPUsingGET(identifier: string, browser?: string, ip?: string, options?: any) {
        return AccountControllerApiFp(this.configuration).verifyIPUsingGET(identifier, browser, ip, options)(this.fetch, this.basePath);
    }

}

/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * IdentityControllerApi - fetch parameter creator
 * @export
 */
export const IdentityControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getIdentity
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityUsingGET(accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getIdentityUsingGET.');
            }
            const localVarPath = `/api/v2/identities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityControllerApi - functional programming interface
 * @export
 */
export const IdentityControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getIdentity
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityUsingGET(accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IdentityDTO> {
            const localVarFetchArgs = IdentityControllerApiFetchParamCreator(configuration).getIdentityUsingGET(accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IdentityControllerApi - factory interface
 * @export
 */
export const IdentityControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getIdentity
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityUsingGET(accountId: string, options?: any) {
            return IdentityControllerApiFp(configuration).getIdentityUsingGET(accountId, options)(fetch, basePath);
        },
    };
};

/**
 * IdentityControllerApi - object-oriented interface
 * @export
 * @class IdentityControllerApi
 * @extends {BaseAPI}
 */
export class IdentityControllerApi extends BaseAPI {
    /**
     * 
     * @summary getIdentity
     * @param {string} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityControllerApi
     */
    public getIdentityUsingGET(accountId: string, options?: any) {
        return IdentityControllerApiFp(this.configuration).getIdentityUsingGET(accountId, options)(this.fetch, this.basePath);
    }

}

/**
 * OperationHandlerApi - fetch parameter creator
 * @export
 */
export const OperationHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health/**`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationHandlerApi - functional programming interface
 * @export
 */
export const OperationHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperationHandlerApi - factory interface
 * @export
 */
export const OperationHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET2(body, options)(fetch, basePath);
        },
    };
};

/**
 * OperationHandlerApi - object-oriented interface
 * @export
 * @class OperationHandlerApi
 * @extends {BaseAPI}
 */
export class OperationHandlerApi extends BaseAPI {
    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET1(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET2(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET2(body, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationControllerApi - fetch parameter creator
 * @export
 */
export const OrganizationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createOrganization
         * @param {CreateOrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUsingPOST(request: CreateOrganizationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createOrganizationUsingPOST.');
            }
            const localVarPath = `/api/v2/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createSecret
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecretUsingPOST(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/organizations/secret`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAccountByOrganizationId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationIdUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/organizations/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getOrganization
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/organizations/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchAccountRole
         * @param {string} accountId2 accountId
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest patchAccountRoleRequest
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRoleUsingPATCH(accountId2: string, patchAccountRoleRequest: PatchAccountRoleRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'accountId2' is not null or undefined
            if (accountId2 === null || accountId2 === undefined) {
                throw new RequiredError('accountId2','Required parameter accountId2 was null or undefined when calling patchAccountRoleUsingPATCH.');
            }
            // verify required parameter 'patchAccountRoleRequest' is not null or undefined
            if (patchAccountRoleRequest === null || patchAccountRoleRequest === undefined) {
                throw new RequiredError('patchAccountRoleRequest','Required parameter patchAccountRoleRequest was null or undefined when calling patchAccountRoleUsingPATCH.');
            }
            const localVarPath = `/api/v2/organizations/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId2)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchAccountRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchAccountRoleRequest || {}) : (patchAccountRoleRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationControllerApi - functional programming interface
 * @export
 */
export const OrganizationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createOrganization
         * @param {CreateOrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUsingPOST(request: CreateOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationDTO> {
            const localVarFetchArgs = OrganizationControllerApiFetchParamCreator(configuration).createOrganizationUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createSecret
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecretUsingPOST(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateSecretResponse> {
            const localVarFetchArgs = OrganizationControllerApiFetchParamCreator(configuration).createSecretUsingPOST(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAccountByOrganizationId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationIdUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrgAccountDTO>> {
            const localVarFetchArgs = OrganizationControllerApiFetchParamCreator(configuration).getAccountByOrganizationIdUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getOrganization
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationDTO> {
            const localVarFetchArgs = OrganizationControllerApiFetchParamCreator(configuration).getOrganizationUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchAccountRole
         * @param {string} accountId2 accountId
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest patchAccountRoleRequest
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRoleUsingPATCH(accountId2: string, patchAccountRoleRequest: PatchAccountRoleRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDTO> {
            const localVarFetchArgs = OrganizationControllerApiFetchParamCreator(configuration).patchAccountRoleUsingPATCH(accountId2, patchAccountRoleRequest, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationControllerApi - factory interface
 * @export
 */
export const OrganizationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createOrganization
         * @param {CreateOrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUsingPOST(request: CreateOrganizationRequest, options?: any) {
            return OrganizationControllerApiFp(configuration).createOrganizationUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createSecret
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecretUsingPOST(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return OrganizationControllerApiFp(configuration).createSecretUsingPOST(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAccountByOrganizationId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationIdUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return OrganizationControllerApiFp(configuration).getAccountByOrganizationIdUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getOrganization
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return OrganizationControllerApiFp(configuration).getOrganizationUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchAccountRole
         * @param {string} accountId2 accountId
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest patchAccountRoleRequest
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRoleUsingPATCH(accountId2: string, patchAccountRoleRequest: PatchAccountRoleRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return OrganizationControllerApiFp(configuration).patchAccountRoleUsingPATCH(accountId2, patchAccountRoleRequest, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationControllerApi - object-oriented interface
 * @export
 * @class OrganizationControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationControllerApi extends BaseAPI {
    /**
     * 
     * @summary createOrganization
     * @param {CreateOrganizationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createOrganizationUsingPOST(request: CreateOrganizationRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createOrganizationUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createSecret
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createSecretUsingPOST(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createSecretUsingPOST(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAccountByOrganizationId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAccountByOrganizationIdUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAccountByOrganizationIdUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getOrganization
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getOrganizationUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getOrganizationUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchAccountRole
     * @param {string} accountId2 accountId
     * @param {PatchAccountRoleRequest} patchAccountRoleRequest patchAccountRoleRequest
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public patchAccountRoleUsingPATCH(accountId2: string, patchAccountRoleRequest: PatchAccountRoleRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return OrganizationControllerApiFp(this.configuration).patchAccountRoleUsingPATCH(accountId2, patchAccountRoleRequest, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * WebMvcLinksHandlerApi - fetch parameter creator
 * @export
 */
export const WebMvcLinksHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/actuator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - functional programming interface
 * @export
 */
export const WebMvcLinksHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: { [key: string]: Link; }; }> {
            const localVarFetchArgs = WebMvcLinksHandlerApiFetchParamCreator(configuration).linksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - factory interface
 * @export
 */
export const WebMvcLinksHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any) {
            return WebMvcLinksHandlerApiFp(configuration).linksUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * WebMvcLinksHandlerApi - object-oriented interface
 * @export
 * @class WebMvcLinksHandlerApi
 * @extends {BaseAPI}
 */
export class WebMvcLinksHandlerApi extends BaseAPI {
    /**
     * 
     * @summary links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMvcLinksHandlerApi
     */
    public linksUsingGET(options?: any) {
        return WebMvcLinksHandlerApiFp(this.configuration).linksUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * WithdrawalApprovalControllerApi - fetch parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approve
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveUsingPOST.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancelApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-approval`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancelRejection
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejectionUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelRejectionUsingPOST.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-rejection`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createWithdrawalApproval
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest createWithdrawalApprovalRequest
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'createWithdrawalApprovalRequest' is not null or undefined
            if (createWithdrawalApprovalRequest === null || createWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('createWithdrawalApprovalRequest','Required parameter createWithdrawalApprovalRequest was null or undefined when calling createWithdrawalApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWithdrawalApprovalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createWithdrawalApprovalRequest || {}) : (createWithdrawalApprovalRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalUsingGET(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling getWithdrawalApprovalUsingGET.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWithdrawalApprovals
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reject
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectUsingPOST.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approve
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).approveUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary cancelApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).cancelApprovalUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary cancelRejection
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejectionUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).cancelRejectionUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createWithdrawalApproval
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest createWithdrawalApprovalRequest
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalUsingGET(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).getWithdrawalApprovalUsingGET(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWithdrawalApprovals
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationWithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).getWithdrawalApprovalsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary reject
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawalApprovalDTO> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).rejectUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary approve
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).approveUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary cancelApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).cancelApprovalUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary cancelRejection
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejectionUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).cancelRejectionUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createWithdrawalApproval
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest createWithdrawalApprovalRequest
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalUsingGET(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApprovalUsingGET(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWithdrawalApprovals
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovalsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApprovalsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary reject
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).rejectUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @summary approve
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approveUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approveUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary cancelApproval
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelApprovalUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary cancelRejection
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelRejectionUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelRejectionUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createWithdrawalApproval
     * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest createWithdrawalApprovalRequest
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).createWithdrawalApprovalUsingPOST(createWithdrawalApprovalRequest, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWithdrawalApproval
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApprovalUsingGET(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApprovalUsingGET(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWithdrawalApprovals
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApprovalsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApprovalsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary reject
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public rejectUsingPOST(withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).rejectUsingPOST(withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

