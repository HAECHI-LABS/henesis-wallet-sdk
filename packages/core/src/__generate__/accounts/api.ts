// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenDTO
 */
export interface AccessTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenDTO
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof AccountDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ActivateAllowedIpsRequest
 */
export interface ActivateAllowedIpsRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedIpsRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface AllowedIpDTO
 */
export interface AllowedIpDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface ChangeAccountNameRequest
 */
export interface ChangeAccountNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface Claim
 */
export interface Claim {
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    type?: ClaimTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Claim
     */
    longType?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ClaimTypeEnum {
    LONG = 'LONG',
    SHORT = 'SHORT'
}

/**
 * 
 * @export
 * @interface ClientIdentity
 */
export interface ClientIdentity {
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    browser?: string;
}
/**
 * 
 * @export
 * @interface CreateAllowedIpRequest
 */
export interface CreateAllowedIpRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateSecretResponse
 */
export interface CreateSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateSecretResponse
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalApprovalRequest
 */
export interface CreateWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    masterWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    userWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    walletName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    transferAt: string;
}
/**
 * 
 * @export
 * @interface DeleteAllowedIpRequest
 */
export interface DeleteAllowedIpRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedIpRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    otpKey?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Identity
     */
    roles?: Array<IdentityRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    username?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IdentityRolesEnum {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface IdentityDTO
 */
export interface IdentityDTO {
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof IdentityDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationSecret: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    otpKey: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface InactivateAllowedIpsRequest
 */
export interface InactivateAllowedIpsRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedIpsRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {ClientIdentity}
     * @memberof InlineObject
     */
    clientIdentity?: ClientIdentity;
    /**
     * 
     * @type {LoginRequest}
     * @memberof InlineObject
     */
    request?: LoginRequest;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject1
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeAccountNameRequest}
     * @memberof InlineObject1
     */
    request?: ChangeAccountNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject10
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchAllowedIpLabelRequest}
     * @memberof InlineObject10
     */
    request?: PatchAllowedIpLabelRequest;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject11
     */
    identity?: Identity;
    /**
     * 
     * @type {ActivateAllowedIpsRequest}
     * @memberof InlineObject11
     */
    request?: ActivateAllowedIpsRequest;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject12
     */
    identity?: Identity;
    /**
     * 
     * @type {InactivateAllowedIpsRequest}
     * @memberof InlineObject12
     */
    request?: InactivateAllowedIpsRequest;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject13
     */
    identity?: Identity;
    /**
     * 
     * @type {NotifyRequest}
     * @memberof InlineObject13
     */
    request?: NotifyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject2
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdatePasswordRequest}
     * @memberof InlineObject2
     */
    request?: UpdatePasswordRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject2
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject3
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdateOrganizationRequest}
     * @memberof InlineObject3
     */
    request?: UpdateOrganizationRequest;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject4
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdateOTPInitializeRequest}
     * @memberof InlineObject4
     */
    request?: UpdateOTPInitializeRequest;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject5
     */
    identity?: Identity;
    /**
     * 
     * @type {RefreshAccessTokenRequest}
     * @memberof InlineObject5
     */
    request?: RefreshAccessTokenRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject5
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject6
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateWithdrawalApprovalRequest}
     * @memberof InlineObject6
     */
    createWithdrawalApprovalRequest?: CreateWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject7
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchAccountRoleRequest}
     * @memberof InlineObject7
     */
    patchAccountRoleRequest?: PatchAccountRoleRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject7
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject8
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateAllowedIpRequest}
     * @memberof InlineObject8
     */
    request?: CreateAllowedIpRequest;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject9
     */
    identity?: Identity;
    /**
     * 
     * @type {DeleteAllowedIpRequest}
     * @memberof InlineObject9
     */
    request?: DeleteAllowedIpRequest;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof LoginResponse
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
    /**
     * 
     * @type {OTPDTO}
     * @memberof LoginResponse
     */
    otp: OTPDTO;
}
/**
 * 
 * @export
 * @interface NotifyRequest
 */
export interface NotifyRequest {
    /**
     * 
     * @type {Array<Role>}
     * @memberof NotifyRequest
     */
    targets?: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof NotifyRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof NotifyRequest
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface OTPDTO
 */
export interface OTPDTO {
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface OrgAccountDTO
 */
export interface OrgAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof OrgAccountDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface OrganizationDTO
 */
export interface OrganizationDTO {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    secret: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDTO
     */
    whitelistActivated: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedIpDTO
 */
export interface PaginationAllowedIpDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedIpDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedIpDTO>}
     * @memberof PaginationAllowedIpDTO
     */
    results: Array<AllowedIpDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationWithdrawalApprovalDTO
 */
export interface PaginationWithdrawalApprovalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WithdrawalApprovalDTO>}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    results: Array<WithdrawalApprovalDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountRoleRequest
 */
export interface PatchAccountRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchAllowedIpLabelRequest
 */
export interface PatchAllowedIpLabelRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAllowedIpLabelRequest
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAllowedIpLabelRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RefreshAccessTokenRequest
 */
export interface RefreshAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    organizationId: string;
}
/**
 * 
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface SimpleAccountDTO
 */
export interface SimpleAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface UpdateOTPInitializeRequest
 */
export interface UpdateOTPInitializeRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOTPInitializeRequest
     */
    initialize: boolean;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    newOrgId: string;
}
/**
 * 
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface WithdrawalApprovalDTO
 */
export interface WithdrawalApprovalDTO {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    id: string;
    /**
     * 
     * @type {SimpleAccountDTO}
     * @memberof WithdrawalApprovalDTO
     */
    requester: SimpleAccountDTO;
    /**
     * 
     * @type {Blockchain}
     * @memberof WithdrawalApprovalDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    amount: string;
    /**
     * 
     * @type {WithdrawalApprovalStatus}
     * @memberof WithdrawalApprovalDTO
     */
    status: WithdrawalApprovalStatus;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    masterWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    userWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    toAddress: string;
    /**
     * 
     * @type {Array<SimpleAccountDTO>}
     * @memberof WithdrawalApprovalDTO
     */
    approvedBy: Array<SimpleAccountDTO>;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    transferAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalApprovalStatus {
    PENDING = 'PENDING',
    REJECTED = 'REJECTED',
    APPROVED = 'APPROVED'
}


/**
 * AccountControllerApi - axios parameter creator
 * @export
 */
export const AccountControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountName: async (inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject1' is not null or undefined
            if (inlineObject1 === null || inlineObject1 === undefined) {
                throw new RequiredError('inlineObject1','Required parameter inlineObject1 was null or undefined when calling changeAccountName.');
            }
            const localVarPath = `/api/v2/accounts/name`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken1: async (inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject5' is not null or undefined
            if (inlineObject5 === null || inlineObject5 === undefined) {
                throw new RequiredError('inlineObject5','Required parameter inlineObject5 was null or undefined when calling createAccessToken1.');
            }
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject5 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject5 !== undefined ? inlineObject5 : {}) : (inlineObject5 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessToken: async (identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAccessToken.');
            }
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAccount.');
            }
            const localVarPath = `/api/v2/accounts/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling login.');
            }
            const localVarPath = `/api/v2/accounts/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signUpRequest: SignUpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            if (signUpRequest === null || signUpRequest === undefined) {
                throw new RequiredError('signUpRequest','Required parameter signUpRequest was null or undefined when calling signup.');
            }
            const localVarPath = `/api/v2/accounts/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signUpRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUpRequest !== undefined ? signUpRequest : {}) : (signUpRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitialize: async (inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject4' is not null or undefined
            if (inlineObject4 === null || inlineObject4 === undefined) {
                throw new RequiredError('inlineObject4','Required parameter inlineObject4 was null or undefined when calling updateOTPInitialize.');
            }
            const localVarPath = `/api/v2/accounts/otp-initialize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject4 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {}) : (inlineObject4 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject3' is not null or undefined
            if (inlineObject3 === null || inlineObject3 === undefined) {
                throw new RequiredError('inlineObject3','Required parameter inlineObject3 was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/api/v2/accounts/organization`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject2' is not null or undefined
            if (inlineObject2 === null || inlineObject2 === undefined) {
                throw new RequiredError('inlineObject2','Required parameter inlineObject2 was null or undefined when calling updatePassword.');
            }
            const localVarPath = `/api/v2/accounts/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIP: async (clientIdentity: ClientIdentity, identifier: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientIdentity' is not null or undefined
            if (clientIdentity === null || clientIdentity === undefined) {
                throw new RequiredError('clientIdentity','Required parameter clientIdentity was null or undefined when calling verifyIP.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling verifyIP.');
            }
            const localVarPath = `/api/v2/accounts/login/verify`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientIdentity !== undefined) {
                localVarQueryParameter['clientIdentity'] = clientIdentity;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountControllerApi - functional programming interface
 * @export
 */
export const AccountControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccountName(inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).changeAccountName(inlineObject1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken1(inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).createAccessToken1(inlineObject5, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessToken(identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).deleteAccessToken(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).getAccessToken(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).getAccount(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).login(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signUpRequest: SignUpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).signup(signUpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOTPInitialize(inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updateOTPInitialize(inlineObject4, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updateOrganization(inlineObject3, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updatePassword(inlineObject2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).verifyIP(clientIdentity, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountControllerApi - factory interface
 * @export
 */
export const AccountControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountName(inlineObject1: InlineObject1, options?: any): AxiosPromise<AccountDTO> {
            return AccountControllerApiFp(configuration).changeAccountName(inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken1(inlineObject5: InlineObject5, options?: any): AxiosPromise<AccessTokenDTO> {
            return AccountControllerApiFp(configuration).createAccessToken1(inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessToken(identity?: Identity, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).deleteAccessToken(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(identity: Identity, options?: any): AxiosPromise<AccessTokenDTO> {
            return AccountControllerApiFp(configuration).getAccessToken(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(identity: Identity, options?: any): AxiosPromise<AccountDTO> {
            return AccountControllerApiFp(configuration).getAccount(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(inlineObject: InlineObject, options?: any): AxiosPromise<LoginResponse> {
            return AccountControllerApiFp(configuration).login(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpRequest: SignUpRequest, options?: any): AxiosPromise<SignUpResponse> {
            return AccountControllerApiFp(configuration).signup(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitialize(inlineObject4: InlineObject4, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updateOTPInitialize(inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(inlineObject3: InlineObject3, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updateOrganization(inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(inlineObject2: InlineObject2, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updatePassword(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).verifyIP(clientIdentity, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountControllerApi - object-oriented interface
 * @export
 * @class AccountControllerApi
 * @extends {BaseAPI}
 */
export class AccountControllerApi extends BaseAPI {
    /**
     * 
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public changeAccountName(inlineObject1: InlineObject1, options?: any) {
        return AccountControllerApiFp(this.configuration).changeAccountName(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public createAccessToken1(inlineObject5: InlineObject5, options?: any) {
        return AccountControllerApiFp(this.configuration).createAccessToken1(inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public deleteAccessToken(identity?: Identity, options?: any) {
        return AccountControllerApiFp(this.configuration).deleteAccessToken(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccessToken(identity: Identity, options?: any) {
        return AccountControllerApiFp(this.configuration).getAccessToken(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccount(identity: Identity, options?: any) {
        return AccountControllerApiFp(this.configuration).getAccount(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public login(inlineObject: InlineObject, options?: any) {
        return AccountControllerApiFp(this.configuration).login(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public signup(signUpRequest: SignUpRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).signup(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOTPInitialize(inlineObject4: InlineObject4, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOTPInitialize(inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOrganization(inlineObject3: InlineObject3, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOrganization(inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updatePassword(inlineObject2: InlineObject2, options?: any) {
        return AccountControllerApiFp(this.configuration).updatePassword(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClientIdentity} clientIdentity 
     * @param {string} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any) {
        return AccountControllerApiFp(this.configuration).verifyIP(clientIdentity, identifier, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IdentityControllerApi - axios parameter creator
 * @export
 */
export const IdentityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedIdentity: async (claim: Claim, clientIdentity: ClientIdentity, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'claim' is not null or undefined
            if (claim === null || claim === undefined) {
                throw new RequiredError('claim','Required parameter claim was null or undefined when calling getVerifiedIdentity.');
            }
            // verify required parameter 'clientIdentity' is not null or undefined
            if (clientIdentity === null || clientIdentity === undefined) {
                throw new RequiredError('clientIdentity','Required parameter clientIdentity was null or undefined when calling getVerifiedIdentity.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getVerifiedIdentity.');
            }
            const localVarPath = `/api/v2/identities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (claim !== undefined) {
                localVarQueryParameter['claim'] = claim;
            }

            if (clientIdentity !== undefined) {
                localVarQueryParameter['clientIdentity'] = clientIdentity;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityControllerApi - functional programming interface
 * @export
 */
export const IdentityControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityDTO>> {
            const localVarAxiosArgs = await IdentityControllerApiAxiosParamCreator(configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IdentityControllerApi - factory interface
 * @export
 */
export const IdentityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any): AxiosPromise<IdentityDTO> {
            return IdentityControllerApiFp(configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityControllerApi - object-oriented interface
 * @export
 * @class IdentityControllerApi
 * @extends {BaseAPI}
 */
export class IdentityControllerApi extends BaseAPI {
    /**
     * 
     * @param {Claim} claim 
     * @param {ClientIdentity} clientIdentity 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityControllerApi
     */
    public getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any) {
        return IdentityControllerApiFp(this.configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganizationControllerApi - axios parameter creator
 * @export
 */
export const OrganizationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedIps: async (inlineObject11: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject11' is not null or undefined
            if (inlineObject11 === null || inlineObject11 === undefined) {
                throw new RequiredError('inlineObject11','Required parameter inlineObject11 was null or undefined when calling activateAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/activate-allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject11 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject11 !== undefined ? inlineObject11 : {}) : (inlineObject11 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedIp: async (inlineObject8: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject8' is not null or undefined
            if (inlineObject8 === null || inlineObject8 === undefined) {
                throw new RequiredError('inlineObject8','Required parameter inlineObject8 was null or undefined when calling createAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject8 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject8 !== undefined ? inlineObject8 : {}) : (inlineObject8 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationRequest: CreateOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            if (createOrganizationRequest === null || createOrganizationRequest === undefined) {
                throw new RequiredError('createOrganizationRequest','Required parameter createOrganizationRequest was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/api/v2/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createOrganizationRequest !== undefined ? createOrganizationRequest : {}) : (createOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations/secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedIp: async (allowedIpId: string, inlineObject9: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling deleteAllowedIp.');
            }
            // verify required parameter 'inlineObject9' is not null or undefined
            if (inlineObject9 === null || inlineObject9 === undefined) {
                throw new RequiredError('inlineObject9','Required parameter inlineObject9 was null or undefined when calling deleteAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject9 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject9 !== undefined ? inlineObject9 : {}) : (inlineObject9 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationId: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAccountByOrganizationId.');
            }
            const localVarPath = `/api/v2/organizations/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIp: async (allowedIpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling getAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIps: async (identity: Identity, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedIps.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/api/v2/organizations/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedIps: async (inlineObject12: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject12' is not null or undefined
            if (inlineObject12 === null || inlineObject12 === undefined) {
                throw new RequiredError('inlineObject12','Required parameter inlineObject12 was null or undefined when calling inactivateAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/inactivate-allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject12 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject12 !== undefined ? inlineObject12 : {}) : (inlineObject12 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify: async (inlineObject13: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject13' is not null or undefined
            if (inlineObject13 === null || inlineObject13 === undefined) {
                throw new RequiredError('inlineObject13','Required parameter inlineObject13 was null or undefined when calling notify.');
            }
            const localVarPath = `/api/v2/organizations/notify`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject13 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject13 !== undefined ? inlineObject13 : {}) : (inlineObject13 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRole: async (accountId: string, inlineObject7: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling patchAccountRole.');
            }
            // verify required parameter 'inlineObject7' is not null or undefined
            if (inlineObject7 === null || inlineObject7 === undefined) {
                throw new RequiredError('inlineObject7','Required parameter inlineObject7 was null or undefined when calling patchAccountRole.');
            }
            const localVarPath = `/api/v2/organizations/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject7 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject7 !== undefined ? inlineObject7 : {}) : (inlineObject7 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedIpLabel: async (allowedIpId: string, inlineObject10: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling patchAllowedIpLabel.');
            }
            // verify required parameter 'inlineObject10' is not null or undefined
            if (inlineObject10 === null || inlineObject10 === undefined) {
                throw new RequiredError('inlineObject10','Required parameter inlineObject10 was null or undefined when calling patchAllowedIpLabel.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}/label`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject10 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject10 !== undefined ? inlineObject10 : {}) : (inlineObject10 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationControllerApi - functional programming interface
 * @export
 */
export const OrganizationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedIps(inlineObject11: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).activateAllowedIps(inlineObject11, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedIp(inlineObject8: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createAllowedIp(inlineObject8, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createOrganization(createOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSecretResponse>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createSecret(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedIp(allowedIpId: string, inlineObject9: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).deleteAllowedIp(allowedIpId, inlineObject9, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByOrganizationId(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgAccountDTO>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAccountByOrganizationId(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedIp(allowedIpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAllowedIp(allowedIpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedIps(identity: Identity, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAllowedIps(identity, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getOrganization(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedIps(inlineObject12: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).inactivateAllowedIps(inlineObject12, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notify(inlineObject13: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).notify(inlineObject13, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountRole(accountId: string, inlineObject7: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).patchAccountRole(accountId, inlineObject7, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAllowedIpLabel(allowedIpId: string, inlineObject10: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).patchAllowedIpLabel(allowedIpId, inlineObject10, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationControllerApi - factory interface
 * @export
 */
export const OrganizationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedIps(inlineObject11: InlineObject11, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).activateAllowedIps(inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedIp(inlineObject8: InlineObject8, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).createAllowedIp(inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): AxiosPromise<OrganizationDTO> {
            return OrganizationControllerApiFp(configuration).createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(identity?: Identity, options?: any): AxiosPromise<CreateSecretResponse> {
            return OrganizationControllerApiFp(configuration).createSecret(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedIp(allowedIpId: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).deleteAllowedIp(allowedIpId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationId(identity: Identity, options?: any): AxiosPromise<Array<OrgAccountDTO>> {
            return OrganizationControllerApiFp(configuration).getAccountByOrganizationId(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIp(allowedIpId: string, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).getAllowedIp(allowedIpId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIps(identity: Identity, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).getAllowedIps(identity, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(identity: Identity, options?: any): AxiosPromise<OrganizationDTO> {
            return OrganizationControllerApiFp(configuration).getOrganization(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedIps(inlineObject12: InlineObject12, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).inactivateAllowedIps(inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify(inlineObject13: InlineObject13, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).notify(inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRole(accountId: string, inlineObject7: InlineObject7, options?: any): AxiosPromise<AccountDTO> {
            return OrganizationControllerApiFp(configuration).patchAccountRole(accountId, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedIpLabel(allowedIpId: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).patchAllowedIpLabel(allowedIpId, inlineObject10, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationControllerApi - object-oriented interface
 * @export
 * @class OrganizationControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationControllerApi extends BaseAPI {
    /**
     * 
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public activateAllowedIps(inlineObject11: InlineObject11, options?: any) {
        return OrganizationControllerApiFp(this.configuration).activateAllowedIps(inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createAllowedIp(inlineObject8: InlineObject8, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createAllowedIp(inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrganizationRequest} createOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createSecret(identity?: Identity, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createSecret(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public deleteAllowedIp(allowedIpId: string, inlineObject9: InlineObject9, options?: any) {
        return OrganizationControllerApiFp(this.configuration).deleteAllowedIp(allowedIpId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAccountByOrganizationId(identity: Identity, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAccountByOrganizationId(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAllowedIp(allowedIpId: string, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAllowedIp(allowedIpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAllowedIps(identity: Identity, pageable: Pageable, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAllowedIps(identity, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getOrganization(identity: Identity, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getOrganization(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public inactivateAllowedIps(inlineObject12: InlineObject12, options?: any) {
        return OrganizationControllerApiFp(this.configuration).inactivateAllowedIps(inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject13} inlineObject13 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public notify(inlineObject13: InlineObject13, options?: any) {
        return OrganizationControllerApiFp(this.configuration).notify(inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {InlineObject7} inlineObject7 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public patchAccountRole(accountId: string, inlineObject7: InlineObject7, options?: any) {
        return OrganizationControllerApiFp(this.configuration).patchAccountRole(accountId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public patchAllowedIpLabel(allowedIpId: string, inlineObject10: InlineObject10, options?: any) {
        return OrganizationControllerApiFp(this.configuration).patchAllowedIpLabel(allowedIpId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: async (withdrawalApprovalId: string, identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approve.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApproval: async (withdrawalApprovalId: string, identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-approval`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejection: async (withdrawalApprovalId: string, identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelRejection.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-rejection`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApproval: async (inlineObject6: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject6' is not null or undefined
            if (inlineObject6 === null || inlineObject6 === undefined) {
                throw new RequiredError('inlineObject6','Required parameter inlineObject6 was null or undefined when calling createWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject6 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject6 !== undefined ? inlineObject6 : {}) : (inlineObject6 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApproval: async (identity: Identity, withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getWithdrawalApproval.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling getWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovals: async (identity: Identity, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getWithdrawalApprovals.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWithdrawalApprovals.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject: async (withdrawalApprovalId: string, identity?: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling reject.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof identity !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(identity !== undefined ? identity : {}) : (identity || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approve(withdrawalApprovalId: string, identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).approve(withdrawalApprovalId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelApproval(withdrawalApprovalId: string, identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).cancelApproval(withdrawalApprovalId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelRejection(withdrawalApprovalId: string, identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).cancelRejection(withdrawalApprovalId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawalApproval(inlineObject6: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).createWithdrawalApproval(inlineObject6, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalApproval(identity: Identity, withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).getWithdrawalApproval(identity, withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalApprovals(identity: Identity, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).getWithdrawalApprovals(identity, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reject(withdrawalApprovalId: string, identity?: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).reject(withdrawalApprovalId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(withdrawalApprovalId: string, identity?: Identity, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).approve(withdrawalApprovalId, identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApproval(withdrawalApprovalId: string, identity?: Identity, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).cancelApproval(withdrawalApprovalId, identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejection(withdrawalApprovalId: string, identity?: Identity, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).cancelRejection(withdrawalApprovalId, identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApproval(inlineObject6: InlineObject6, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).createWithdrawalApproval(inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApproval(identity: Identity, withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApproval(identity, withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovals(identity: Identity, pageable: Pageable, options?: any): AxiosPromise<PaginationWithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApprovals(identity, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {Identity} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject(withdrawalApprovalId: string, identity?: Identity, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).reject(withdrawalApprovalId, identity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approve(withdrawalApprovalId: string, identity?: Identity, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approve(withdrawalApprovalId, identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelApproval(withdrawalApprovalId: string, identity?: Identity, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelApproval(withdrawalApprovalId, identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelRejection(withdrawalApprovalId: string, identity?: Identity, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelRejection(withdrawalApprovalId, identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public createWithdrawalApproval(inlineObject6: InlineObject6, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).createWithdrawalApproval(inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApproval(identity: Identity, withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApproval(identity, withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApprovals(identity: Identity, pageable: Pageable, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApprovals(identity, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {Identity} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public reject(withdrawalApprovalId: string, identity?: Identity, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).reject(withdrawalApprovalId, identity, options).then((request) => request(this.axios, this.basePath));
    }

}


