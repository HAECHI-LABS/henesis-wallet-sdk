// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActiveBlockchainDto
 */
export interface ActiveBlockchainDto {
    /**
     * 
     * @type {Plan}
     * @memberof ActiveBlockchainDto
     */
    plan: Plan;
    /**
     * 
     * @type {Blockchain}
     * @memberof ActiveBlockchainDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof ActiveBlockchainDto
     */
    activatedDate: string;
    /**
     * 
     * @type {number}
     * @memberof ActiveBlockchainDto
     */
    usageFeePerPeriod: number;
}
/**
 * 
 * @export
 * @interface BasePlanDto
 */
export interface BasePlanDto {
    /**
     * 
     * @type {string}
     * @memberof BasePlanDto
     */
    termFrom: string;
    /**
     * 
     * @type {string}
     * @memberof BasePlanDto
     */
    termUntil: string;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    unitPeriod: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    blockchainNetworkFeePerPeriod: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    nftUsageFeePerPeriod?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    fungibleTokenFeePerMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    freeFungibleTokenCount?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    nonFungibleTokenFeePerMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    freeNonFungibleTokenCount?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    withdrawalFeeRate?: number;
    /**
     * 
     * @type {number}
     * @memberof BasePlanDto
     */
    gasSavingFeeRate?: number;
    /**
     * 
     * @type {Array<ActiveBlockchainDto>}
     * @memberof BasePlanDto
     */
    blockchainNetworkFeeBlockchains?: Array<ActiveBlockchainDto>;
    /**
     * 
     * @type {Array<ActiveBlockchainDto>}
     * @memberof BasePlanDto
     */
    nftUsageFeeBlockchains?: Array<ActiveBlockchainDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    FILECOIN = 'FILECOIN',
    BINANCESMARTCHAIN = 'BINANCE_SMART_CHAIN',
    LITECOIN = 'LITECOIN',
    BITCOINCASH = 'BITCOIN_CASH'
}

/**
 * 
 * @export
 * @interface BlockchainDto
 */
export interface BlockchainDto {
    /**
     * 
     * @type {Blockchain}
     * @memberof BlockchainDto
     */
    blockchain: Blockchain;
}
/**
 * 
 * @export
 * @interface ChangeBillingPlanStatusRequest
 */
export interface ChangeBillingPlanStatusRequest {
    /**
     * 
     * @type {Plan}
     * @memberof ChangeBillingPlanStatusRequest
     */
    plan: Plan;
    /**
     * 
     * @type {Array<BlockchainDto>}
     * @memberof ChangeBillingPlanStatusRequest
     */
    blockchains: Array<BlockchainDto>;
}
/**
 * 
 * @export
 * @interface ChangeBillingPlanStatusResponse
 */
export interface ChangeBillingPlanStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof ChangeBillingPlanStatusResponse
     */
    planId: string;
    /**
     * 
     * @type {Array<SummarizedBiliingPlanDto>}
     * @memberof ChangeBillingPlanStatusResponse
     */
    summarizedBillingPlans: Array<SummarizedBiliingPlanDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CoinType {
    NATIVE = 'NATIVE',
    TOKEN = 'TOKEN',
    NFT = 'NFT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ContractType {
    A = 'TYPE_A',
    B = 'TYPE_B',
    C = 'TYPE_C',
    E = 'TYPE_E',
    I = 'TYPE_I',
    D = 'TYPE_D',
    F = 'TYPE_F',
    J = 'TYPE_J',
    G = 'TYPE_G',
    H = 'TYPE_H',
    L = 'TYPE_L'
}

/**
 * 
 * @export
 * @interface CreateErc20GasUsageRequest
 */
export interface CreateErc20GasUsageRequest {
    /**
     * 
     * @type {Blockchain}
     * @memberof CreateErc20GasUsageRequest
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof CreateErc20GasUsageRequest
     */
    transfer: string;
    /**
     * 
     * @type {string}
     * @memberof CreateErc20GasUsageRequest
     */
    approve: string;
    /**
     * 
     * @type {string}
     * @memberof CreateErc20GasUsageRequest
     */
    transferFrom: string;
}
/**
 * 
 * @export
 * @interface CreateTermInvoiceResponse
 */
export interface CreateTermInvoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateTermInvoiceResponse
     */
    invoiceId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTermInvoiceResponse
     */
    withdrawalFeeInvoiceId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Currency {
    USD = 'USD',
    KRW = 'KRW'
}

/**
 * 
 * @export
 * @interface DetailedInvoiceDto
 */
export interface DetailedInvoiceDto {
    /**
     * 
     * @type {Language}
     * @memberof DetailedInvoiceDto
     */
    language: Language;
    /**
     * 
     * @type {Currency}
     * @memberof DetailedInvoiceDto
     */
    currency: Currency;
    /**
     * 
     * @type {string}
     * @memberof DetailedInvoiceDto
     */
    invoiceId: string;
    /**
     * 
     * @type {Array<MonthlyDetailedInvoiceDto>}
     * @memberof DetailedInvoiceDto
     */
    monthlyDetailedInvoice?: Array<MonthlyDetailedInvoiceDto>;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface GasSavingFeeDailyBillingDto
 */
export interface GasSavingFeeDailyBillingDto {
    /**
     * 
     * @type {string}
     * @memberof GasSavingFeeDailyBillingDto
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof GasSavingFeeDailyBillingDto
     */
    henesisGasAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GasSavingFeeDailyBillingDto
     */
    customerGasAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GasSavingFeeDailyBillingDto
     */
    savedGasAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GasSavingFeeDailyBillingDto
     */
    closePrice: number;
    /**
     * 
     * @type {number}
     * @memberof GasSavingFeeDailyBillingDto
     */
    gasSavingFee: number;
}
/**
 * 
 * @export
 * @interface GasSavingFeeMonthlyBillingDto
 */
export interface GasSavingFeeMonthlyBillingDto {
    /**
     * 
     * @type {string}
     * @memberof GasSavingFeeMonthlyBillingDto
     */
    billingMonth: string;
    /**
     * 
     * @type {Source}
     * @memberof GasSavingFeeMonthlyBillingDto
     */
    coinSource: Source;
    /**
     * 
     * @type {Array<GasSavingFeeDailyBillingDto>}
     * @memberof GasSavingFeeMonthlyBillingDto
     */
    gasSavingFeeDailyBillings: Array<GasSavingFeeDailyBillingDto>;
}
/**
 * 
 * @export
 * @interface GetInvoicePdfResponse
 */
export interface GetInvoicePdfResponse {
    /**
     * 
     * @type {string}
     * @memberof GetInvoicePdfResponse
     */
    pdfLink: string;
}
/**
 * 
 * @export
 * @interface InvoiceDto
 */
export interface InvoiceDto {
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceDto
     */
    paid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    orgId: string;
    /**
     * 
     * @type {InvoiceType}
     * @memberof InvoiceDto
     */
    invoiceType: InvoiceType;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    billingMonth: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    billingDate: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    paymentDueDate: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    usageFrom: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    usageUntil: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    nonUsageFeeBillingFrom: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    nonUsageFeeBillingUntil?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDto
     */
    pdfLink?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceDto
     */
    isPaid: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum InvoiceType {
    TERMINVOICE = 'TERM_INVOICE',
    TERMWITHDRAWALFEEINVOICE = 'TERM_WITHDRAWAL_FEE_INVOICE',
    ADDITIONALUSAGEFEEINVOICE = 'ADDITIONAL_USAGE_FEE_INVOICE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    KO = 'KO',
    EN = 'EN'
}

/**
 * 
 * @export
 * @interface MonthlyDetailedInvoiceDto
 */
export interface MonthlyDetailedInvoiceDto {
    /**
     * 
     * @type {string}
     * @memberof MonthlyDetailedInvoiceDto
     */
    billingMonth: string;
    /**
     * 
     * @type {Array<UsageFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyBlockchainNetworkFeeBillings?: Array<UsageFeeMonthlyBillingDto>;
    /**
     * 
     * @type {Array<UsageFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyNftUsageFeeBillings?: Array<UsageFeeMonthlyBillingDto>;
    /**
     * 
     * @type {Array<TokenFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyFungibleTokenFeeBillings?: Array<TokenFeeMonthlyBillingDto>;
    /**
     * 
     * @type {Array<TokenFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyNonFungibleTokenFeeBillings?: Array<TokenFeeMonthlyBillingDto>;
    /**
     * 
     * @type {Array<WithdrawalFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyWithdrawalFeeBillings?: Array<WithdrawalFeeMonthlyBillingDto>;
    /**
     * 
     * @type {Array<GasSavingFeeMonthlyBillingDto>}
     * @memberof MonthlyDetailedInvoiceDto
     */
    monthlyGasSavingFeeDailyBillings?: Array<GasSavingFeeMonthlyBillingDto>;
}
/**
 * 
 * @export
 * @interface OrganizationDto
 */
export interface OrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    name: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrganizationDto
     */
    currency: Currency;
    /**
     * 
     * @type {Language}
     * @memberof OrganizationDto
     */
    language: Language;
    /**
     * 
     * @type {ContractType}
     * @memberof OrganizationDto
     */
    contractType: ContractType;
    /**
     * 
     * @type {Source}
     * @memberof OrganizationDto
     */
    coinSource: Source;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDto
     */
    orgId: string;
    /**
     * 
     * @type {BasePlanDto}
     * @memberof OrganizationDto
     */
    basePlan: BasePlanDto;
}
/**
 * 
 * @export
 * @interface PatchErc20GasUsageRequest
 */
export interface PatchErc20GasUsageRequest {
    /**
     * 
     * @type {Blockchain}
     * @memberof PatchErc20GasUsageRequest
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof PatchErc20GasUsageRequest
     */
    transfer: string;
    /**
     * 
     * @type {string}
     * @memberof PatchErc20GasUsageRequest
     */
    approve: string;
    /**
     * 
     * @type {string}
     * @memberof PatchErc20GasUsageRequest
     */
    transferFrom: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Plan {
    BLOCKCHAINNETWORKFEEBILLINGPLAN = 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN',
    NFTUSAGEFEEBILLINGPLAN = 'NFT_USAGE_FEE_BILLING_PLAN',
    FUNGIBLETOKENFEEBILLINGPLAN = 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN',
    NONFUNGIBLETOKENFEEBILLINGPLAN = 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN',
    WITHDRAWALFEEBILLINGPLAN = 'WITHDRAWAL_FEE_BILLING_PLAN',
    GASSAVINGFEEBILLINGPLAN = 'GAS_SAVING_FEE_BILLING_PLAN'
}

/**
 * 
 * @export
 * @interface SaveBillingOrganizationRequest
 */
export interface SaveBillingOrganizationRequest {
    /**
     * 
     * @type {Currency}
     * @memberof SaveBillingOrganizationRequest
     */
    currency: Currency;
    /**
     * 
     * @type {Language}
     * @memberof SaveBillingOrganizationRequest
     */
    language: Language;
    /**
     * 
     * @type {string}
     * @memberof SaveBillingOrganizationRequest
     */
    orgName: string;
    /**
     * 
     * @type {Source}
     * @memberof SaveBillingOrganizationRequest
     */
    coinSource: Source;
    /**
     * 
     * @type {ContractType}
     * @memberof SaveBillingOrganizationRequest
     */
    contractType: ContractType;
    /**
     * 
     * @type {BasePlanDto}
     * @memberof SaveBillingOrganizationRequest
     */
    basePlan: BasePlanDto;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Source {
    GECKO = 'COIN_GECKO',
    MARKETCAP = 'COIN_MARKET_CAP'
}

/**
 * 
 * @export
 * @interface SummarizedBiliingPlanDto
 */
export interface SummarizedBiliingPlanDto {
    /**
     * 
     * @type {Blockchain}
     * @memberof SummarizedBiliingPlanDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {Plan}
     * @memberof SummarizedBiliingPlanDto
     */
    plan: Plan;
    /**
     * 
     * @type {string}
     * @memberof SummarizedBiliingPlanDto
     */
    billingPlanId: string;
    /**
     * 
     * @type {number}
     * @memberof SummarizedBiliingPlanDto
     */
    usageFeePerPeriod: number;
}
/**
 * 
 * @export
 * @interface SummarizedBlockchainNetworkFeeBillingDto
 */
export interface SummarizedBlockchainNetworkFeeBillingDto {
    /**
     * 
     * @type {Array<Blockchain>}
     * @memberof SummarizedBlockchainNetworkFeeBillingDto
     */
    blockchains: Array<Blockchain>;
    /**
     * 
     * @type {number}
     * @memberof SummarizedBlockchainNetworkFeeBillingDto
     */
    totalBlockchainNetworkFee: number;
}
/**
 * 
 * @export
 * @interface SummarizedGasSavingFeeBillingDto
 */
export interface SummarizedGasSavingFeeBillingDto {
    /**
     * 
     * @type {string}
     * @memberof SummarizedGasSavingFeeBillingDto
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedGasSavingFeeBillingDto
     */
    until: string;
    /**
     * 
     * @type {number}
     * @memberof SummarizedGasSavingFeeBillingDto
     */
    totalGasSavingAmount: number;
    /**
     * 
     * @type {number}
     * @memberof SummarizedGasSavingFeeBillingDto
     */
    gasSavingFee: number;
    /**
     * 
     * @type {number}
     * @memberof SummarizedGasSavingFeeBillingDto
     */
    gasSavingFeeRate: number;
}
/**
 * 
 * @export
 * @interface SummarizedInvoiceDto
 */
export interface SummarizedInvoiceDto {
    /**
     * 
     * @type {Language}
     * @memberof SummarizedInvoiceDto
     */
    language: Language;
    /**
     * 
     * @type {Currency}
     * @memberof SummarizedInvoiceDto
     */
    currency: Currency;
    /**
     * 
     * @type {OrganizationDto}
     * @memberof SummarizedInvoiceDto
     */
    organization: OrganizationDto;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    invoiceId: string;
    /**
     * 
     * @type {InvoiceType}
     * @memberof SummarizedInvoiceDto
     */
    invoiceType: InvoiceType;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    usageFrom: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    usageUntil: string;
    /**
     * 
     * @type {number}
     * @memberof SummarizedInvoiceDto
     */
    supplyValue: number;
    /**
     * 
     * @type {number}
     * @memberof SummarizedInvoiceDto
     */
    totalValue: number;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    billingMonth: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    billingDate: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedInvoiceDto
     */
    paymentDueDate: string;
    /**
     * 
     * @type {SummarizedBlockchainNetworkFeeBillingDto}
     * @memberof SummarizedInvoiceDto
     */
    summarizedBlockchainNetworkFeeBilling?: SummarizedBlockchainNetworkFeeBillingDto;
    /**
     * 
     * @type {SummarizedNftUsageFeeBillingDto}
     * @memberof SummarizedInvoiceDto
     */
    summarizedNftUsageFeeBilling?: SummarizedNftUsageFeeBillingDto;
    /**
     * 
     * @type {SummarizedTokenFeeBillingDto}
     * @memberof SummarizedInvoiceDto
     */
    summarizedTokenFeeBilling?: SummarizedTokenFeeBillingDto;
    /**
     * 
     * @type {SummarizedWithdrawalFeeBillingDto}
     * @memberof SummarizedInvoiceDto
     */
    summarizedWithdrawalFeeBilling?: SummarizedWithdrawalFeeBillingDto;
    /**
     * 
     * @type {SummarizedGasSavingFeeBillingDto}
     * @memberof SummarizedInvoiceDto
     */
    summarizedGasSavingFeeBilling?: SummarizedGasSavingFeeBillingDto;
}
/**
 * 
 * @export
 * @interface SummarizedNftUsageFeeBillingDto
 */
export interface SummarizedNftUsageFeeBillingDto {
    /**
     * 
     * @type {Array<Blockchain>}
     * @memberof SummarizedNftUsageFeeBillingDto
     */
    blockchains: Array<Blockchain>;
    /**
     * 
     * @type {number}
     * @memberof SummarizedNftUsageFeeBillingDto
     */
    totalNftUsageFee: number;
}
/**
 * 
 * @export
 * @interface SummarizedTokenFeeBillingDto
 */
export interface SummarizedTokenFeeBillingDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SummarizedTokenFeeBillingDto
     */
    tokens: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SummarizedTokenFeeBillingDto
     */
    totalTokenFee: number;
}
/**
 * 
 * @export
 * @interface SummarizedWithdrawalFeeBillingDto
 */
export interface SummarizedWithdrawalFeeBillingDto {
    /**
     * 
     * @type {string}
     * @memberof SummarizedWithdrawalFeeBillingDto
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedWithdrawalFeeBillingDto
     */
    until: string;
    /**
     * 
     * @type {number}
     * @memberof SummarizedWithdrawalFeeBillingDto
     */
    totalWithdrawalAmount: number;
    /**
     * 
     * @type {number}
     * @memberof SummarizedWithdrawalFeeBillingDto
     */
    withdrawalFee: number;
    /**
     * 
     * @type {number}
     * @memberof SummarizedWithdrawalFeeBillingDto
     */
    withdrawalFeeRate: number;
}
/**
 * 
 * @export
 * @interface TokenFeeMonthlyBillingDto
 */
export interface TokenFeeMonthlyBillingDto {
    /**
     * 
     * @type {Blockchain}
     * @memberof TokenFeeMonthlyBillingDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {boolean}
     * @memberof TokenFeeMonthlyBillingDto
     */
    free?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenFeeMonthlyBillingDto
     */
    billingMonth: string;
    /**
     * 
     * @type {number}
     * @memberof TokenFeeMonthlyBillingDto
     */
    coinId: number;
    /**
     * 
     * @type {CoinType}
     * @memberof TokenFeeMonthlyBillingDto
     */
    tokenType: CoinType;
    /**
     * 
     * @type {string}
     * @memberof TokenFeeMonthlyBillingDto
     */
    tokenName: string;
    /**
     * 
     * @type {string}
     * @memberof TokenFeeMonthlyBillingDto
     */
    tokenSymbol: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenFeeMonthlyBillingDto
     */
    isFree: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenFeeMonthlyBillingDto
     */
    usageFrom: string;
    /**
     * 
     * @type {string}
     * @memberof TokenFeeMonthlyBillingDto
     */
    usageUntil: string;
    /**
     * 
     * @type {number}
     * @memberof TokenFeeMonthlyBillingDto
     */
    usageFee: number;
}
/**
 * 
 * @export
 * @interface UsageFeeMonthlyBillingDto
 */
export interface UsageFeeMonthlyBillingDto {
    /**
     * 
     * @type {Blockchain}
     * @memberof UsageFeeMonthlyBillingDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof UsageFeeMonthlyBillingDto
     */
    billingMonth: string;
    /**
     * 
     * @type {string}
     * @memberof UsageFeeMonthlyBillingDto
     */
    usageFrom: string;
    /**
     * 
     * @type {string}
     * @memberof UsageFeeMonthlyBillingDto
     */
    usageUntil: string;
    /**
     * 
     * @type {number}
     * @memberof UsageFeeMonthlyBillingDto
     */
    usageFee: number;
    /**
     * 
     * @type {number}
     * @memberof UsageFeeMonthlyBillingDto
     */
    discountRate: number;
}
/**
 * 
 * @export
 * @interface WithdrawalFeeDailyBillingDto
 */
export interface WithdrawalFeeDailyBillingDto {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    date: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    coinSymbol: string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    closePrice: number;
    /**
     * 
     * @type {number}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    withdrawalAmount: number;
    /**
     * 
     * @type {number}
     * @memberof WithdrawalFeeDailyBillingDto
     */
    withdrawalFee: number;
}
/**
 * 
 * @export
 * @interface WithdrawalFeeMonthlyBillingDto
 */
export interface WithdrawalFeeMonthlyBillingDto {
    /**
     * 
     * @type {Blockchain}
     * @memberof WithdrawalFeeMonthlyBillingDto
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {Source}
     * @memberof WithdrawalFeeMonthlyBillingDto
     */
    coinSource: Source;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalFeeMonthlyBillingDto
     */
    billingMonth: string;
    /**
     * 
     * @type {Array<WithdrawalFeeDailyBillingDto>}
     * @memberof WithdrawalFeeMonthlyBillingDto
     */
    withdrawalFeeDailyBillings: Array<WithdrawalFeeDailyBillingDto>;
}

/**
 * InvoiceControllerApi - axios parameter creator
 * @export
 */
export const InvoiceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTermInvoice: async (orgId: string, date: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling createTermInvoice.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling createTermInvoice.');
            }
            const localVarPath = `/api/v1/invoices/organizations/{orgId}/create-term-invoice`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedInvoice: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getDetailedInvoice.');
            }
            const localVarPath = `/api/v1/invoices/{invoiceId}/detailed`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoicePdf.');
            }
            const localVarPath = `/api/v1/invoices/{invoiceId}/download`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: async (orgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling getInvoices.');
            }
            const localVarPath = `/api/v1/invoices/organizations/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedInvoice: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getSummarizedInvoice.');
            }
            const localVarPath = `/api/v1/invoices/{invoiceId}/summarized`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceControllerApi - functional programming interface
 * @export
 */
export const InvoiceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTermInvoice(orgId: string, date: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTermInvoiceResponse>> {
            const localVarAxiosArgs = await InvoiceControllerApiAxiosParamCreator(configuration).createTermInvoice(orgId, date, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailedInvoice(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedInvoiceDto>> {
            const localVarAxiosArgs = await InvoiceControllerApiAxiosParamCreator(configuration).getDetailedInvoice(invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePdf(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoicePdfResponse>> {
            const localVarAxiosArgs = await InvoiceControllerApiAxiosParamCreator(configuration).getInvoicePdf(invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoices(orgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceDto>>> {
            const localVarAxiosArgs = await InvoiceControllerApiAxiosParamCreator(configuration).getInvoices(orgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummarizedInvoice(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SummarizedInvoiceDto>> {
            const localVarAxiosArgs = await InvoiceControllerApiAxiosParamCreator(configuration).getSummarizedInvoice(invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InvoiceControllerApi - factory interface
 * @export
 */
export const InvoiceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTermInvoice(orgId: string, date: string, options?: any): AxiosPromise<CreateTermInvoiceResponse> {
            return InvoiceControllerApiFp(configuration).createTermInvoice(orgId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedInvoice(invoiceId: string, options?: any): AxiosPromise<DetailedInvoiceDto> {
            return InvoiceControllerApiFp(configuration).getDetailedInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePdf(invoiceId: string, options?: any): AxiosPromise<GetInvoicePdfResponse> {
            return InvoiceControllerApiFp(configuration).getInvoicePdf(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(orgId: string, options?: any): AxiosPromise<Array<InvoiceDto>> {
            return InvoiceControllerApiFp(configuration).getInvoices(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedInvoice(invoiceId: string, options?: any): AxiosPromise<SummarizedInvoiceDto> {
            return InvoiceControllerApiFp(configuration).getSummarizedInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceControllerApi - object-oriented interface
 * @export
 * @class InvoiceControllerApi
 * @extends {BaseAPI}
 */
export class InvoiceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public createTermInvoice(orgId: string, date: string, options?: any) {
        return InvoiceControllerApiFp(this.configuration).createTermInvoice(orgId, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public getDetailedInvoice(invoiceId: string, options?: any) {
        return InvoiceControllerApiFp(this.configuration).getDetailedInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public getInvoicePdf(invoiceId: string, options?: any) {
        return InvoiceControllerApiFp(this.configuration).getInvoicePdf(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public getInvoices(orgId: string, options?: any) {
        return InvoiceControllerApiFp(this.configuration).getInvoices(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceControllerApi
     */
    public getSummarizedInvoice(invoiceId: string, options?: any) {
        return InvoiceControllerApiFp(this.configuration).getSummarizedInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganizationControllerApi - axios parameter creator
 * @export
 */
export const OrganizationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBillingPlans: async (orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling activateBillingPlans.');
            }
            // verify required parameter 'changeBillingPlanStatusRequest' is not null or undefined
            if (changeBillingPlanStatusRequest === null || changeBillingPlanStatusRequest === undefined) {
                throw new RequiredError('changeBillingPlanStatusRequest','Required parameter changeBillingPlanStatusRequest was null or undefined when calling activateBillingPlans.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}/activate-billings`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeBillingPlanStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeBillingPlanStatusRequest !== undefined ? changeBillingPlanStatusRequest : {}) : (changeBillingPlanStatusRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateBillingPlans: async (orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling deactivateBillingPlans.');
            }
            // verify required parameter 'changeBillingPlanStatusRequest' is not null or undefined
            if (changeBillingPlanStatusRequest === null || changeBillingPlanStatusRequest === undefined) {
                throw new RequiredError('changeBillingPlanStatusRequest','Required parameter changeBillingPlanStatusRequest was null or undefined when calling deactivateBillingPlans.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}/deactivate-billings`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeBillingPlanStatusRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeBillingPlanStatusRequest !== undefined ? changeBillingPlanStatusRequest : {}) : (changeBillingPlanStatusRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockchains: async (orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling getActiveBlockchains.');
            }
            // verify required parameter 'plan' is not null or undefined
            if (plan === null || plan === undefined) {
                throw new RequiredError('plan','Required parameter plan was null or undefined when calling getActiveBlockchains.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}/active-blockchains`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveBlockchains: async (orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling getInactiveBlockchains.');
            }
            // verify required parameter 'plan' is not null or undefined
            if (plan === null || plan === undefined) {
                throw new RequiredError('plan','Required parameter plan was null or undefined when calling getInactiveBlockchains.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}/inactive-blockchains`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (orgId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SaveBillingOrganizationRequest} saveBillingOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBillingOrganization: async (orgId: string, saveBillingOrganizationRequest: SaveBillingOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            if (orgId === null || orgId === undefined) {
                throw new RequiredError('orgId','Required parameter orgId was null or undefined when calling saveBillingOrganization.');
            }
            // verify required parameter 'saveBillingOrganizationRequest' is not null or undefined
            if (saveBillingOrganizationRequest === null || saveBillingOrganizationRequest === undefined) {
                throw new RequiredError('saveBillingOrganizationRequest','Required parameter saveBillingOrganizationRequest was null or undefined when calling saveBillingOrganization.');
            }
            const localVarPath = `/api/v1/organizations/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBillingOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBillingOrganizationRequest !== undefined ? saveBillingOrganizationRequest : {}) : (saveBillingOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationControllerApi - functional programming interface
 * @export
 */
export const OrganizationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeBillingPlanStatusResponse>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).activateBillingPlans(orgId, changeBillingPlanStatusRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeBillingPlanStatusResponse>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).deactivateBillingPlans(orgId, changeBillingPlanStatusRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getActiveBlockchains(orgId, plan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInactiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getInactiveBlockchains(orgId, plan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(orgId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDto>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getOrganization(orgId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationDto>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getOrganizations(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SaveBillingOrganizationRequest} saveBillingOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveBillingOrganization(orgId: string, saveBillingOrganizationRequest: SaveBillingOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDto>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).saveBillingOrganization(orgId, saveBillingOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationControllerApi - factory interface
 * @export
 */
export const OrganizationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any): AxiosPromise<ChangeBillingPlanStatusResponse> {
            return OrganizationControllerApiFp(configuration).activateBillingPlans(orgId, changeBillingPlanStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any): AxiosPromise<ChangeBillingPlanStatusResponse> {
            return OrganizationControllerApiFp(configuration).deactivateBillingPlans(orgId, changeBillingPlanStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any): AxiosPromise<Array<string>> {
            return OrganizationControllerApiFp(configuration).getActiveBlockchains(orgId, plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any): AxiosPromise<Array<string>> {
            return OrganizationControllerApiFp(configuration).getInactiveBlockchains(orgId, plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(orgId: string, options?: any): AxiosPromise<OrganizationDto> {
            return OrganizationControllerApiFp(configuration).getOrganization(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(options?: any): AxiosPromise<Array<OrganizationDto>> {
            return OrganizationControllerApiFp(configuration).getOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SaveBillingOrganizationRequest} saveBillingOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBillingOrganization(orgId: string, saveBillingOrganizationRequest: SaveBillingOrganizationRequest, options?: any): AxiosPromise<OrganizationDto> {
            return OrganizationControllerApiFp(configuration).saveBillingOrganization(orgId, saveBillingOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationControllerApi - object-oriented interface
 * @export
 * @class OrganizationControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public activateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).activateBillingPlans(orgId, changeBillingPlanStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {ChangeBillingPlanStatusRequest} changeBillingPlanStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public deactivateBillingPlans(orgId: string, changeBillingPlanStatusRequest: ChangeBillingPlanStatusRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).deactivateBillingPlans(orgId, changeBillingPlanStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getActiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any) {
        return OrganizationControllerApiFp(this.configuration).getActiveBlockchains(orgId, plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN'} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getInactiveBlockchains(orgId: string, plan: 'BLOCKCHAIN_NETWORK_FEE_BILLING_PLAN' | 'NFT_USAGE_FEE_BILLING_PLAN' | 'FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'NON_FUNGIBLE_TOKEN_FEE_BILLING_PLAN' | 'WITHDRAWAL_FEE_BILLING_PLAN' | 'GAS_SAVING_FEE_BILLING_PLAN', options?: any) {
        return OrganizationControllerApiFp(this.configuration).getInactiveBlockchains(orgId, plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getOrganization(orgId: string, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getOrganization(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getOrganizations(options?: any) {
        return OrganizationControllerApiFp(this.configuration).getOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {SaveBillingOrganizationRequest} saveBillingOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public saveBillingOrganization(orgId: string, saveBillingOrganizationRequest: SaveBillingOrganizationRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).saveBillingOrganization(orgId, saveBillingOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SupportControllerApi - axios parameter creator
 * @export
 */
export const SupportControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} coinId 
         * @param {CreateErc20GasUsageRequest} createErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc20GasUsage: async (coinId: number, createErc20GasUsageRequest: CreateErc20GasUsageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling createErc20GasUsage.');
            }
            // verify required parameter 'createErc20GasUsageRequest' is not null or undefined
            if (createErc20GasUsageRequest === null || createErc20GasUsageRequest === undefined) {
                throw new RequiredError('createErc20GasUsageRequest','Required parameter createErc20GasUsageRequest was null or undefined when calling createErc20GasUsage.');
            }
            const localVarPath = `/api/v1/supports/erc20-gas-usage/{coinId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createErc20GasUsageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createErc20GasUsageRequest !== undefined ? createErc20GasUsageRequest : {}) : (createErc20GasUsageRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} coinId 
         * @param {PatchErc20GasUsageRequest} patchErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchErc20GasUsage: async (coinId: number, patchErc20GasUsageRequest: PatchErc20GasUsageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling patchErc20GasUsage.');
            }
            // verify required parameter 'patchErc20GasUsageRequest' is not null or undefined
            if (patchErc20GasUsageRequest === null || patchErc20GasUsageRequest === undefined) {
                throw new RequiredError('patchErc20GasUsageRequest','Required parameter patchErc20GasUsageRequest was null or undefined when calling patchErc20GasUsage.');
            }
            const localVarPath = `/api/v1/supports/erc20-gas-usage/{coinId}`
                .replace(`{${"coinId"}}`, encodeURIComponent(String(coinId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchErc20GasUsageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchErc20GasUsageRequest !== undefined ? patchErc20GasUsageRequest : {}) : (patchErc20GasUsageRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportControllerApi - functional programming interface
 * @export
 */
export const SupportControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} coinId 
         * @param {CreateErc20GasUsageRequest} createErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createErc20GasUsage(coinId: number, createErc20GasUsageRequest: CreateErc20GasUsageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SupportControllerApiAxiosParamCreator(configuration).createErc20GasUsage(coinId, createErc20GasUsageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} coinId 
         * @param {PatchErc20GasUsageRequest} patchErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchErc20GasUsage(coinId: number, patchErc20GasUsageRequest: PatchErc20GasUsageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SupportControllerApiAxiosParamCreator(configuration).patchErc20GasUsage(coinId, patchErc20GasUsageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SupportControllerApi - factory interface
 * @export
 */
export const SupportControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} coinId 
         * @param {CreateErc20GasUsageRequest} createErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createErc20GasUsage(coinId: number, createErc20GasUsageRequest: CreateErc20GasUsageRequest, options?: any): AxiosPromise<void> {
            return SupportControllerApiFp(configuration).createErc20GasUsage(coinId, createErc20GasUsageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} coinId 
         * @param {PatchErc20GasUsageRequest} patchErc20GasUsageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchErc20GasUsage(coinId: number, patchErc20GasUsageRequest: PatchErc20GasUsageRequest, options?: any): AxiosPromise<void> {
            return SupportControllerApiFp(configuration).patchErc20GasUsage(coinId, patchErc20GasUsageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportControllerApi - object-oriented interface
 * @export
 * @class SupportControllerApi
 * @extends {BaseAPI}
 */
export class SupportControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} coinId 
     * @param {CreateErc20GasUsageRequest} createErc20GasUsageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportControllerApi
     */
    public createErc20GasUsage(coinId: number, createErc20GasUsageRequest: CreateErc20GasUsageRequest, options?: any) {
        return SupportControllerApiFp(this.configuration).createErc20GasUsage(coinId, createErc20GasUsageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} coinId 
     * @param {PatchErc20GasUsageRequest} patchErc20GasUsageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportControllerApi
     */
    public patchErc20GasUsage(coinId: number, patchErc20GasUsageRequest: PatchErc20GasUsageRequest, options?: any) {
        return SupportControllerApiFp(this.configuration).patchErc20GasUsage(coinId, patchErc20GasUsageRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


