// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateAllowedAddressesRequest
 */
export interface ActivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistedWalletId?: string;
    /**
     * 
     * @type {number}
     * @memberof AllowedAddressDTO
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof AllowedAddressDTO
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof AllowedAddressDTO
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AllowedCoinType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceDTO
     */
    coinId: number;
    /**
     * 
     * @type {CoinType}
     * @memberof BalanceDTO
     */
    coinType: CoinType;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableAmount: string;
}
/**
 * 
 * @export
 * @interface BatchTransactionDTO
 */
export interface BatchTransactionDTO {
    /**
     * 
     * @type {TransactionDTO}
     * @memberof BatchTransactionDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof BatchTransactionDTO
     */
    message: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface CallEventDTO
 */
export interface CallEventDTO {
    /**
     * 
     * @type {number}
     * @memberof CallEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof CallEventDTO
     */
    status: EventStatus;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface ChangeWalletNameRequest
 */
export interface ChangeWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CoinDTO
 */
export interface CoinDTO {
    /**
     * 
     * @type {number}
     * @memberof CoinDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    desc: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof CoinDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {Array<string>}
     * @memberof CoinDTO
     */
    attributes: Array<CoinDTOAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum CoinDTOAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CoinType {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    TOKEN = 'TOKEN'
}

/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateAllowedAddressRequest
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof CreateAllowedAddressRequest
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof CreateAllowedAddressRequest
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateBatchTransactionRequest
 */
export interface CreateBatchTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    walletId: string;
    /**
     * 
     * @type {Array<SignedMultiSigPayloadDTO>}
     * @memberof CreateBatchTransactionRequest
     */
    signedMultiSigPayloads: Array<SignedMultiSigPayloadDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateCoinRequest
 */
export interface CreateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCoinRequest
     */
    attributes: Array<CreateCoinRequestAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateCoinRequestAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}
/**
 * 
 * @export
 * @interface CreateMasterWalletRequest
 */
export interface CreateMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface CreateMasterWalletRequestV1
 */
export interface CreateMasterWalletRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestV1
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestV1
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface CreateMultiSigTransactionRequest
 */
export interface CreateMultiSigTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    walletId: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateMultiSigTransactionRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateMultiSigTransactionRequestV1
 */
export interface CreateMultiSigTransactionRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    walletId: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateUserWalletRequest
 */
export interface CreateUserWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    salt: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateUserWalletRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {WalletType}
     * @memberof CreateWithdrawalPolicyRequest
     */
    walletType: WalletType;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: CreateWithdrawalPolicyRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateWithdrawalPolicyRequestTypeEnum {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}

/**
 * 
 * @export
 * @interface DeleteAllowedAddressRequest
 */
export interface DeleteAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EventStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    REPLACED = 'REPLACED',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED'
}

/**
 * 
 * @export
 * @interface GetGasPriceResponse
 */
export interface GetGasPriceResponse {
    /**
     * 
     * @type {string}
     * @memberof GetGasPriceResponse
     */
    gasPrice: string;
}
/**
 * 
 * @export
 * @interface HenesisKeyBalanceDTO
 */
export interface HenesisKeyBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof HenesisKeyBalanceDTO
     */
    coinId: number;
    /**
     * 
     * @type {CoinType}
     * @memberof HenesisKeyBalanceDTO
     */
    coinType: CoinType;
}
/**
 * 
 * @export
 * @interface InactivateAllowedAddressesRequest
 */
export interface InactivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof MasterWalletDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {WalletStatus}
     * @memberof MasterWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MasterWalletDTO
     */
    whitelistActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface MethodGasUsageDTO
 */
export interface MethodGasUsageDTO {
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof MethodGasUsageDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    estimatedGasConsumption: string;
}
/**
 * 
 * @export
 * @interface MultiSigPayloadDTO
 */
export interface MultiSigPayloadDTO {
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletNonce: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    hexData: string;
}
/**
 * 
 * @export
 * @interface NonceDTO
 */
export interface NonceDTO {
    /**
     * 
     * @type {string}
     * @memberof NonceDTO
     */
    nonce: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationCallEventDTO
 */
export interface PaginationCallEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationCallEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<CallEventDTO>}
     * @memberof PaginationCallEventDTO
     */
    results: Array<CallEventDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransactionDTO
 */
export interface PaginationTransactionDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransactionDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransactionDTO>}
     * @memberof PaginationTransactionDTO
     */
    results: Array<TransactionDTO>;
}
/**
 * 
 * @export
 * @interface PaginationUserWalletDTO
 */
export interface PaginationUserWalletDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationUserWalletDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<UserWalletDTO>}
     * @memberof PaginationUserWalletDTO
     */
    results: Array<UserWalletDTO>;
}
/**
 * 
 * @export
 * @interface PaginationValueTransferEventDTO
 */
export interface PaginationValueTransferEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationValueTransferEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<ValueTransferEventDTO>}
     * @memberof PaginationValueTransferEventDTO
     */
    results: Array<ValueTransferEventDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}
/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasPrice: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasLimit: string;
}
/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface RetryCreateWalletRequest
 */
export interface RetryCreateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequest
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface RetryCreateWalletRequestV1
 */
export interface RetryCreateWalletRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequestV1
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface SignedMultiSigPayloadDTO
 */
export interface SignedMultiSigPayloadDTO {
    /**
     * 
     * @type {string}
     * @memberof SignedMultiSigPayloadDTO
     */
    signature: string;
    /**
     * 
     * @type {MultiSigPayloadDTO}
     * @memberof SignedMultiSigPayloadDTO
     */
    multiSigPayload: MultiSigPayloadDTO;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof TransactionDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    sender: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    error?: string;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof TransactionDTO
     */
    status: TransactionStatus;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof TransactionDTO
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {RawTransactionDTO}
     * @memberof TransactionDTO
     */
    rawTransaction: RawTransactionDTO;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransactionStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    MINED = 'MINED',
    REVERTED = 'REVERTED',
    CONFIRMED = 'CONFIRMED',
    REPLACED = 'REPLACED'
}

/**
 * 
 * @export
 * @interface UpdateAccountKeyRequest
 */
export interface UpdateAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface UpdateCoinRequest
 */
export interface UpdateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCoinRequest
     */
    attributes: Array<UpdateCoinRequestAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateCoinRequestAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @interface UserWalletDTO
 */
export interface UserWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    blockchain: UserWalletDTOBlockchainEnum;
    /**
     * 
     * @type {WalletStatus}
     * @memberof UserWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWalletDTOBlockchainEnum {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressRequest
 */
export interface ValidateIsAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateIsAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {number}
     * @memberof ValidateIsAllowedAddressRequest
     */
    coinId: number;
}
/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressResponse
 */
export interface ValidateIsAllowedAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateIsAllowedAddressResponse
     */
    isValid: boolean;
}
/**
 * 
 * @export
 * @interface ValueTransferEventDTO
 */
export interface ValueTransferEventDTO {
    /**
     * 
     * @type {number}
     * @memberof ValueTransferEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof ValueTransferEventDTO
     */
    status: EventStatus;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {ValueTransferType}
     * @memberof ValueTransferEventDTO
     */
    transferType: ValueTransferType;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    walletName?: string;
    /**
     * 
     * @type {WalletType}
     * @memberof ValueTransferEventDTO
     */
    walletType?: WalletType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ValueTransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    ACTIVE = 'ACTIVE',
    CREATING = 'CREATING',
    FAILED = 'FAILED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletType {
    MASTERWALLET = 'MASTER_WALLET',
    USERWALLET = 'USER_WALLET'
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {WalletType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletType: WalletType;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WhitelistType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalPolicyType {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}


/**
 * CoinControllerApi - axios parameter creator
 * @export
 */
export const CoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin2: async (symbol: string, blockchain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin2.');
            }
            // verify required parameter 'blockchain' is not null or undefined
            if (blockchain === null || blockchain === undefined) {
                throw new RequiredError('blockchain','Required parameter blockchain was null or undefined when calling getCoin2.');
            }
            const localVarPath = `/api/v1/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinControllerApi - functional programming interface
 * @export
 */
export const CoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await CoinControllerApiAxiosParamCreator(configuration).getAllCoins(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin2(symbol: string, blockchain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await CoinControllerApiAxiosParamCreator(configuration).getCoin2(symbol, blockchain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CoinControllerApi - factory interface
 * @export
 */
export const CoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins(options?: any): AxiosPromise<Array<CoinDTO>> {
            return CoinControllerApiFp(configuration).getAllCoins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin2(symbol: string, blockchain: string, options?: any): AxiosPromise<CoinDTO> {
            return CoinControllerApiFp(configuration).getCoin2(symbol, blockchain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinControllerApi - object-oriented interface
 * @export
 * @class CoinControllerApi
 * @extends {BaseAPI}
 */
export class CoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getAllCoins(options?: any) {
        return CoinControllerApiFp(this.configuration).getAllCoins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {string} blockchain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getCoin2(symbol: string, blockchain: string, options?: any) {
        return CoinControllerApiFp(this.configuration).getCoin2(symbol, blockchain, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthCoinControllerApi - axios parameter creator
 * @export
 */
export const EthCoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin: async (createCoinRequest: CreateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoinRequest' is not null or undefined
            if (createCoinRequest === null || createCoinRequest === undefined) {
                throw new RequiredError('createCoinRequest','Required parameter createCoinRequest was null or undefined when calling createCoin.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCoinRequest !== undefined ? createCoinRequest : {}) : (createCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoin.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins1: async (flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getAllCoins1.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin: async (updateCoinRequest: UpdateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCoinRequest' is not null or undefined
            if (updateCoinRequest === null || updateCoinRequest === undefined) {
                throw new RequiredError('updateCoinRequest','Required parameter updateCoinRequest was null or undefined when calling patchCoin.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateCoinRequest !== undefined ? updateCoinRequest : {}) : (updateCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthCoinControllerApi - functional programming interface
 * @export
 */
export const EthCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoin(createCoinRequest: CreateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).createCoin(createCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoin(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).deleteCoin(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins1(flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).getAllCoins1(flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).getCoin(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).patchCoin(updateCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthCoinControllerApi - factory interface
 * @export
 */
export const EthCoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin(createCoinRequest: CreateCoinRequest, options?: any): AxiosPromise<CoinDTO> {
            return EthCoinControllerApiFp(configuration).createCoin(createCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin(symbol: string, options?: any): AxiosPromise<void> {
            return EthCoinControllerApiFp(configuration).deleteCoin(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins1(flag: boolean, options?: any): AxiosPromise<Array<CoinDTO>> {
            return EthCoinControllerApiFp(configuration).getAllCoins1(flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin(symbol: string, options?: any): AxiosPromise<CoinDTO> {
            return EthCoinControllerApiFp(configuration).getCoin(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any): AxiosPromise<void> {
            return EthCoinControllerApiFp(configuration).patchCoin(updateCoinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthCoinControllerApi - object-oriented interface
 * @export
 * @class EthCoinControllerApi
 * @extends {BaseAPI}
 */
export class EthCoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCoinRequest} createCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public createCoin(createCoinRequest: CreateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).createCoin(createCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public deleteCoin(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).deleteCoin(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getAllCoins1(flag: boolean, options?: any) {
        return EthCoinControllerApiFp(this.configuration).getAllCoins1(flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getCoin(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).getCoin(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCoinRequest} updateCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).patchCoin(updateCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthEventControllerApi - axios parameter creator
 * @export
 */
export const EthEventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getCallEvents.');
            }
            const localVarPath = `/api/v2/eth/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getValueTransferEvents.');
            }
            const localVarPath = `/api/v2/eth/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthEventControllerApi - functional programming interface
 * @export
 */
export const EthEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await EthEventControllerApiAxiosParamCreator(configuration).getCallEvents(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await EthEventControllerApiAxiosParamCreator(configuration).getValueTransferEvents(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthEventControllerApi - factory interface
 * @export
 */
export const EthEventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return EthEventControllerApiFp(configuration).getCallEvents(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return EthEventControllerApiFp(configuration).getValueTransferEvents(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthEventControllerApi - object-oriented interface
 * @export
 * @class EthEventControllerApi
 * @extends {BaseAPI}
 */
export class EthEventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getCallEvents(pageable: Pageable, specs: object, options?: any) {
        return EthEventControllerApiFp(this.configuration).getCallEvents(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getValueTransferEvents(pageable: Pageable, specs: object, options?: any) {
        return EthEventControllerApiFp(this.configuration).getValueTransferEvents(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthGasPriceControllerApi - axios parameter creator
 * @export
 */
export const EthGasPriceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPrice: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/eth/gas-price`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthGasPriceControllerApi - functional programming interface
 * @export
 */
export const EthGasPriceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasPrice(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGasPriceResponse>> {
            const localVarAxiosArgs = await EthGasPriceControllerApiAxiosParamCreator(configuration).getGasPrice(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthGasPriceControllerApi - factory interface
 * @export
 */
export const EthGasPriceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPrice(options?: any): AxiosPromise<GetGasPriceResponse> {
            return EthGasPriceControllerApiFp(configuration).getGasPrice(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthGasPriceControllerApi - object-oriented interface
 * @export
 * @class EthGasPriceControllerApi
 * @extends {BaseAPI}
 */
export class EthGasPriceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthGasPriceControllerApi
     */
    public getGasPrice(options?: any) {
        return EthGasPriceControllerApiFp(this.configuration).getGasPrice(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthHenesisKeyControllerApi - axios parameter creator
 * @export
 */
export const EthHenesisKeyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/eth/henesis-keys/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/eth/henesis-keys/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const EthHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).createHenesisKey(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).createTransaction(createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKey(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKey(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKeyBalance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyBalanceDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKeyBalance(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - factory interface
 * @export
 */
export const EthHenesisKeyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return EthHenesisKeyControllerApiFp(configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransactionDTO> {
            return EthHenesisKeyControllerApiFp(configuration).createTransaction(createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey(options?: any): AxiosPromise<KeyDTO> {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance(options?: any): AxiosPromise<HenesisKeyBalanceDTO> {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKeyBalance(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class EthHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class EthHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createTransaction(createTransactionRequest: CreateTransactionRequest, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createTransaction(createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKey(options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKeyBalance(options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalance(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthMethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const EthMethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsages.');
            }
            const localVarPath = `/api/v2/eth/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const EthMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await EthMethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - factory interface
 * @export
 */
export const EthMethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages(name: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return EthMethodGasUsageControllerApiFp(configuration).getMethodGasUsages(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class EthMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class EthMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthMethodGasUsageControllerApi
     */
    public getMethodGasUsages(name: string, options?: any) {
        return EthMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthTransactionControllerApi - axios parameter creator
 * @export
 */
export const EthTransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getAllTransactions.');
            }
            const localVarPath = `/api/v2/eth/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById.');
            }
            const localVarPath = `/api/v2/eth/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthTransactionControllerApi - functional programming interface
 * @export
 */
export const EthTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await EthTransactionControllerApiAxiosParamCreator(configuration).getAllTransactions(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthTransactionControllerApiAxiosParamCreator(configuration).getTransactionById(transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthTransactionControllerApi - factory interface
 * @export
 */
export const EthTransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return EthTransactionControllerApiFp(configuration).getAllTransactions(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return EthTransactionControllerApiFp(configuration).getTransactionById(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthTransactionControllerApi - object-oriented interface
 * @export
 * @class EthTransactionControllerApi
 * @extends {BaseAPI}
 */
export class EthTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getAllTransactions(pageable: Pageable, specs: object, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getAllTransactions(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getTransactionById(transactionId: string, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getTransactionById(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthWalletControllerApi - axios parameter creator
 * @export
 */
export const EthWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet: async (createMasterWalletRequest: CreateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMasterWalletRequest' is not null or undefined
            if (createMasterWalletRequest === null || createMasterWalletRequest === undefined) {
                throw new RequiredError('createMasterWalletRequest','Required parameter createMasterWalletRequest was null or undefined when calling createMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMasterWalletRequest !== undefined ? createMasterWalletRequest : {}) : (createMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet: async (walletId: string, createUserWalletRequest: CreateUserWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet.');
            }
            // verify required parameter 'createUserWalletRequest' is not null or undefined
            if (createUserWalletRequest === null || createUserWalletRequest === undefined) {
                throw new RequiredError('createUserWalletRequest','Required parameter createUserWalletRequest was null or undefined when calling createUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserWalletRequest !== undefined ? createUserWalletRequest : {}) : (createUserWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPolicies.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllWalletWithdrawalPolicies.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId1: async (walletId: string, coinId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance: async (walletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance: async (walletId: string, userWalletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey: async (walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey.');
            }
            // verify required parameter 'updateAccountKeyRequest' is not null or undefined
            if (updateAccountKeyRequest === null || updateAccountKeyRequest === undefined) {
                throw new RequiredError('updateAccountKeyRequest','Required parameter updateAccountKeyRequest was null or undefined when calling patchAccountKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAccountKeyRequest !== undefined ? updateAccountKeyRequest : {}) : (updateAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName: async (walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchUserWalletName.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy: async (walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet: async (walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet.');
            }
            // verify required parameter 'retryCreateWalletRequest' is not null or undefined
            if (retryCreateWalletRequest === null || retryCreateWalletRequest === undefined) {
                throw new RequiredError('retryCreateWalletRequest','Required parameter retryCreateWalletRequest was null or undefined when calling retryCreateMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequest !== undefined ? retryCreateWalletRequest : {}) : (retryCreateWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet: async (walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet.');
            }
            // verify required parameter 'retryCreateWalletRequest' is not null or undefined
            if (retryCreateWalletRequest === null || retryCreateWalletRequest === undefined) {
                throw new RequiredError('retryCreateWalletRequest','Required parameter retryCreateWalletRequest was null or undefined when calling retryCreateUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequest !== undefined ? retryCreateWalletRequest : {}) : (retryCreateWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction: async (createBatchTransactionRequest: CreateBatchTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBatchTransactionRequest' is not null or undefined
            if (createBatchTransactionRequest === null || createBatchTransactionRequest === undefined) {
                throw new RequiredError('createBatchTransactionRequest','Required parameter createBatchTransactionRequest was null or undefined when calling sendBatchTransaction.');
            }
            const localVarPath = `/api/v2/eth/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBatchTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBatchTransactionRequest !== undefined ? createBatchTransactionRequest : {}) : (createBatchTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMultiSigTransactionRequest' is not null or undefined
            if (createMultiSigTransactionRequest === null || createMultiSigTransactionRequest === undefined) {
                throw new RequiredError('createMultiSigTransactionRequest','Required parameter createMultiSigTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/eth/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMultiSigTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMultiSigTransactionRequest !== undefined ? createMultiSigTransactionRequest : {}) : (createMultiSigTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWalletControllerApi - functional programming interface
 * @export
 */
export const EthWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createMasterWallet(createMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createUserWallet(walletId, createUserWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWalletWithdrawalPolicies(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllWalletWithdrawalPolicies(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddressesByCoinId1(walletId: string, coinId: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllowedAddressesByCoinId1(walletId, coinId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance(walletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance(walletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWallets(sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWallet(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance(walletId: string, userWalletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance(walletId, userWalletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWallets(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchAccountKey(walletId, updateAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchUserWalletName(walletId, userWalletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy(walletId, policyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet(walletId, retryCreateWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet(walletId, userWalletId, retryCreateWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction(createBatchTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).sendTransaction(createMultiSigTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthWalletControllerApi - factory interface
 * @export
 */
export const EthWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).createMasterWallet(createMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).createUserWallet(walletId, createUserWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).getAllWalletWithdrawalPolicies(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId1(walletId: string, coinId: number, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).getAllowedAddressesByCoinId1(walletId, coinId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletAccountKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance(walletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return EthWalletControllerApiFp(configuration).getMasterWalletBalance(walletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletNonce(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return EthWalletControllerApiFp(configuration).getMasterWallets(sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet(walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).getUserWallet(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance(walletId: string, userWalletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return EthWalletControllerApiFp(configuration).getUserWalletBalance(walletId, userWalletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return EthWalletControllerApiFp(configuration).getUserWalletNonce(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return EthWalletControllerApiFp(configuration).getUserWallets(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).patchAccountKey(walletId, updateAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).patchMasterWalletName(walletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).patchUserWalletName(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy(walletId, policyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).retryCreateMasterWallet(walletId, retryCreateWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).retryCreateUserWallet(walletId, userWalletId, retryCreateWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return EthWalletControllerApiFp(configuration).sendBatchTransaction(createBatchTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any): AxiosPromise<TransactionDTO> {
            return EthWalletControllerApiFp(configuration).sendTransaction(createMultiSigTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return EthWalletControllerApiFp(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthWalletControllerApi - object-oriented interface
 * @export
 * @class EthWalletControllerApi
 * @extends {BaseAPI}
 */
export class EthWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMasterWalletRequest} createMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createMasterWallet(createMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateUserWalletRequest} createUserWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createUserWallet(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createUserWallet(walletId, createUserWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllWalletWithdrawalPolicies(walletId: string, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPolicies(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddress(walletId: string, allowedAddressId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {number} coinId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddressesByCoinId1(walletId: string, coinId: number, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddressesByCoinId1(walletId, coinId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWallet(walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletAccountKey(walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletAccountKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletBalance(walletId: string, symbol?: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletBalance(walletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletInitialKey(walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletNonce(walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletNonce(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWallets(sort: Sort, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWallets(sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWallet(walletId: string, userWalletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWallet(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletBalance(walletId: string, userWalletId: string, symbol?: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletBalance(walletId, userWalletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletNonce(walletId: string, userWalletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletNonce(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWallets(walletId: string, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWallets(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchAccountKey(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchAccountKey(walletId, updateAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchMasterWalletName(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchUserWalletName(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchUserWalletName(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} policyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchWalletWithdrawalPolicy(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy(walletId, policyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateMasterWallet(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateMasterWallet(walletId, retryCreateWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateUserWallet(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateUserWallet(walletId, userWalletId, retryCreateWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendBatchTransaction(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendBatchTransaction(createBatchTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendTransaction(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendTransaction(createMultiSigTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return EthWalletControllerApiFp(this.configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const EthWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransactionDTO> {
            return EthWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return EthWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class EthWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class EthWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EventControllerApi - axios parameter creator
 * @export
 */
export const EventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents2: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents2.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getCallEvents2.');
            }
            const localVarPath = `/api/v1/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents2: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents2.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getValueTransferEvents2.');
            }
            const localVarPath = `/api/v1/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventControllerApi - functional programming interface
 * @export
 */
export const EventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents2(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await EventControllerApiAxiosParamCreator(configuration).getCallEvents2(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents2(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await EventControllerApiAxiosParamCreator(configuration).getValueTransferEvents2(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventControllerApi - factory interface
 * @export
 */
export const EventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents2(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return EventControllerApiFp(configuration).getCallEvents2(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents2(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return EventControllerApiFp(configuration).getValueTransferEvents2(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventControllerApi - object-oriented interface
 * @export
 * @class EventControllerApi
 * @extends {BaseAPI}
 */
export class EventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getCallEvents2(pageable: Pageable, specs: object, options?: any) {
        return EventControllerApiFp(this.configuration).getCallEvents2(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getValueTransferEvents2(pageable: Pageable, specs: object, options?: any) {
        return EventControllerApiFp(this.configuration).getValueTransferEvents2(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayCoinControllerApi - axios parameter creator
 * @export
 */
export const KlayCoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin1: async (createCoinRequest: CreateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoinRequest' is not null or undefined
            if (createCoinRequest === null || createCoinRequest === undefined) {
                throw new RequiredError('createCoinRequest','Required parameter createCoinRequest was null or undefined when calling createCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCoinRequest !== undefined ? createCoinRequest : {}) : (createCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin1: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins2: async (flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getAllCoins2.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin1: async (updateCoinRequest: UpdateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCoinRequest' is not null or undefined
            if (updateCoinRequest === null || updateCoinRequest === undefined) {
                throw new RequiredError('updateCoinRequest','Required parameter updateCoinRequest was null or undefined when calling patchCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateCoinRequest !== undefined ? updateCoinRequest : {}) : (updateCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayCoinControllerApi - functional programming interface
 * @export
 */
export const KlayCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoin1(createCoinRequest: CreateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).createCoin1(createCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoin1(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).deleteCoin1(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins2(flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).getAllCoins2(flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin1(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).getCoin1(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).patchCoin1(updateCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayCoinControllerApi - factory interface
 * @export
 */
export const KlayCoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin1(createCoinRequest: CreateCoinRequest, options?: any): AxiosPromise<CoinDTO> {
            return KlayCoinControllerApiFp(configuration).createCoin1(createCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin1(symbol: string, options?: any): AxiosPromise<void> {
            return KlayCoinControllerApiFp(configuration).deleteCoin1(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins2(flag: boolean, options?: any): AxiosPromise<Array<CoinDTO>> {
            return KlayCoinControllerApiFp(configuration).getAllCoins2(flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1(symbol: string, options?: any): AxiosPromise<CoinDTO> {
            return KlayCoinControllerApiFp(configuration).getCoin1(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any): AxiosPromise<void> {
            return KlayCoinControllerApiFp(configuration).patchCoin1(updateCoinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayCoinControllerApi - object-oriented interface
 * @export
 * @class KlayCoinControllerApi
 * @extends {BaseAPI}
 */
export class KlayCoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCoinRequest} createCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public createCoin1(createCoinRequest: CreateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).createCoin1(createCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public deleteCoin1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).deleteCoin1(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getAllCoins2(flag: boolean, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getAllCoins2(flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getCoin1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getCoin1(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCoinRequest} updateCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).patchCoin1(updateCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayEventControllerApi - axios parameter creator
 * @export
 */
export const KlayEventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents1: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getCallEvents1.');
            }
            const localVarPath = `/api/v2/klay/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents1: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getValueTransferEvents1.');
            }
            const localVarPath = `/api/v2/klay/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayEventControllerApi - functional programming interface
 * @export
 */
export const KlayEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents1(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await KlayEventControllerApiAxiosParamCreator(configuration).getCallEvents1(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents1(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await KlayEventControllerApiAxiosParamCreator(configuration).getValueTransferEvents1(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayEventControllerApi - factory interface
 * @export
 */
export const KlayEventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents1(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return KlayEventControllerApiFp(configuration).getCallEvents1(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents1(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return KlayEventControllerApiFp(configuration).getValueTransferEvents1(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayEventControllerApi - object-oriented interface
 * @export
 * @class KlayEventControllerApi
 * @extends {BaseAPI}
 */
export class KlayEventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getCallEvents1(pageable: Pageable, specs: object, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getCallEvents1(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getValueTransferEvents1(pageable: Pageable, specs: object, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getValueTransferEvents1(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayGasPriceControllerApi - axios parameter creator
 * @export
 */
export const KlayGasPriceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPrice1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/klay/gas-price`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayGasPriceControllerApi - functional programming interface
 * @export
 */
export const KlayGasPriceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasPrice1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGasPriceResponse>> {
            const localVarAxiosArgs = await KlayGasPriceControllerApiAxiosParamCreator(configuration).getGasPrice1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayGasPriceControllerApi - factory interface
 * @export
 */
export const KlayGasPriceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPrice1(options?: any): AxiosPromise<GetGasPriceResponse> {
            return KlayGasPriceControllerApiFp(configuration).getGasPrice1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayGasPriceControllerApi - object-oriented interface
 * @export
 * @class KlayGasPriceControllerApi
 * @extends {BaseAPI}
 */
export class KlayGasPriceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayGasPriceControllerApi
     */
    public getGasPrice1(options?: any) {
        return KlayGasPriceControllerApiFp(this.configuration).getGasPrice1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayHenesisKeyControllerApi - axios parameter creator
 * @export
 */
export const KlayHenesisKeyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey1: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction1: async (createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling createTransaction1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/klay/henesis-keys/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/klay/henesis-keys/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const KlayHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).createHenesisKey1(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction1(createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).createTransaction1(createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKey1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKey1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKeyBalance1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyBalanceDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKeyBalance1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - factory interface
 * @export
 */
export const KlayHenesisKeyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).createHenesisKey1(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction1(createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransactionDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).createTransaction1(createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey1(options?: any): AxiosPromise<KeyDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKey1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance1(options?: any): AxiosPromise<HenesisKeyBalanceDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKeyBalance1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class KlayHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class KlayHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createHenesisKey1(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createTransaction1(createTransactionRequest: CreateTransactionRequest, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createTransaction1(createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKey1(options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKey1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKeyBalance1(options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalance1(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayMethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const KlayMethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages1: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsages1.');
            }
            const localVarPath = `/api/v2/klay/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages1(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await KlayMethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages1(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - factory interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages1(name: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return KlayMethodGasUsageControllerApiFp(configuration).getMethodGasUsages1(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class KlayMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class KlayMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayMethodGasUsageControllerApi
     */
    public getMethodGasUsages1(name: string, options?: any) {
        return KlayMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages1(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayTransactionControllerApi - axios parameter creator
 * @export
 */
export const KlayTransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions1: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getAllTransactions1.');
            }
            const localVarPath = `/api/v2/klay/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById1: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById1.');
            }
            const localVarPath = `/api/v2/klay/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - functional programming interface
 * @export
 */
export const KlayTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions1(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await KlayTransactionControllerApiAxiosParamCreator(configuration).getAllTransactions1(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById1(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayTransactionControllerApiAxiosParamCreator(configuration).getTransactionById1(transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - factory interface
 * @export
 */
export const KlayTransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions1(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return KlayTransactionControllerApiFp(configuration).getAllTransactions1(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById1(transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return KlayTransactionControllerApiFp(configuration).getTransactionById1(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayTransactionControllerApi - object-oriented interface
 * @export
 * @class KlayTransactionControllerApi
 * @extends {BaseAPI}
 */
export class KlayTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getAllTransactions1(pageable: Pageable, specs: object, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getAllTransactions1(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getTransactionById1(transactionId: string, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getTransactionById1(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayWalletControllerApi - axios parameter creator
 * @export
 */
export const KlayWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses1.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress1.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1: async (createMasterWalletRequest: CreateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMasterWalletRequest' is not null or undefined
            if (createMasterWalletRequest === null || createMasterWalletRequest === undefined) {
                throw new RequiredError('createMasterWalletRequest','Required parameter createMasterWalletRequest was null or undefined when calling createMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMasterWalletRequest !== undefined ? createMasterWalletRequest : {}) : (createMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet1: async (walletId: string, createUserWalletRequest: CreateUserWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet1.');
            }
            // verify required parameter 'createUserWalletRequest' is not null or undefined
            if (createUserWalletRequest === null || createUserWalletRequest === undefined) {
                throw new RequiredError('createUserWalletRequest','Required parameter createUserWalletRequest was null or undefined when calling createUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserWalletRequest !== undefined ? createUserWalletRequest : {}) : (createUserWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies1: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPolicies1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllWalletWithdrawalPolicies1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId2: async (walletId: string, coinId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance1: async (walletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1: async (sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets1.');
            }
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet1: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance1: async (walletId: string, userWalletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce1: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets1: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses1.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey1: async (walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey1.');
            }
            // verify required parameter 'updateAccountKeyRequest' is not null or undefined
            if (updateAccountKeyRequest === null || updateAccountKeyRequest === undefined) {
                throw new RequiredError('updateAccountKeyRequest','Required parameter updateAccountKeyRequest was null or undefined when calling patchAccountKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAccountKeyRequest !== undefined ? updateAccountKeyRequest : {}) : (updateAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1: async (walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName1.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchMasterWalletName1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName1: async (walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName1.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchUserWalletName1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1: async (walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet1: async (walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet1.');
            }
            // verify required parameter 'retryCreateWalletRequest' is not null or undefined
            if (retryCreateWalletRequest === null || retryCreateWalletRequest === undefined) {
                throw new RequiredError('retryCreateWalletRequest','Required parameter retryCreateWalletRequest was null or undefined when calling retryCreateMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequest !== undefined ? retryCreateWalletRequest : {}) : (retryCreateWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet1: async (walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet1.');
            }
            // verify required parameter 'retryCreateWalletRequest' is not null or undefined
            if (retryCreateWalletRequest === null || retryCreateWalletRequest === undefined) {
                throw new RequiredError('retryCreateWalletRequest','Required parameter retryCreateWalletRequest was null or undefined when calling retryCreateUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequest !== undefined ? retryCreateWalletRequest : {}) : (retryCreateWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction1: async (createBatchTransactionRequest: CreateBatchTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBatchTransactionRequest' is not null or undefined
            if (createBatchTransactionRequest === null || createBatchTransactionRequest === undefined) {
                throw new RequiredError('createBatchTransactionRequest','Required parameter createBatchTransactionRequest was null or undefined when calling sendBatchTransaction1.');
            }
            const localVarPath = `/api/v2/klay/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBatchTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBatchTransactionRequest !== undefined ? createBatchTransactionRequest : {}) : (createBatchTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1: async (createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMultiSigTransactionRequest' is not null or undefined
            if (createMultiSigTransactionRequest === null || createMultiSigTransactionRequest === undefined) {
                throw new RequiredError('createMultiSigTransactionRequest','Required parameter createMultiSigTransactionRequest was null or undefined when calling sendTransaction1.');
            }
            const localVarPath = `/api/v2/klay/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMultiSigTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMultiSigTransactionRequest !== undefined ? createMultiSigTransactionRequest : {}) : (createMultiSigTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress1.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWalletControllerApi - functional programming interface
 * @export
 */
export const KlayWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet1(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createMasterWallet1(createMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet1(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createUserWallet1(walletId, createUserWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllWalletWithdrawalPolicies1(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress1(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddressesByCoinId2(walletId: string, coinId: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllowedAddressesByCoinId2(walletId, coinId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWallet1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance1(walletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance1(walletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets1(sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWallets1(sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet1(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWallet1(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance1(walletId: string, userWalletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance1(walletId, userWalletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce1(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce1(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets1(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWallets1(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey1(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchAccountKey1(walletId, updateAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName1(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName1(walletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName1(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchUserWalletName1(walletId, userWalletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy1(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy1(walletId, policyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet1(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet1(walletId, retryCreateWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet1(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet1(walletId, userWalletId, retryCreateWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction1(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction1(createBatchTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction1(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).sendTransaction1(createMultiSigTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayWalletControllerApi - factory interface
 * @export
 */
export const KlayWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).createMasterWallet1(createMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet1(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).createUserWallet1(walletId, createUserWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).getAllWalletWithdrawalPolicies1(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).getAllowedAddress1(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId2(walletId: string, coinId: number, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).getAllowedAddressesByCoinId2(walletId, coinId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWallet1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey1(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletAccountKey1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance1(walletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletBalance1(walletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletInitialKey1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce1(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletNonce1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1(sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return KlayWalletControllerApiFp(configuration).getMasterWallets1(sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet1(walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWallet1(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance1(walletId: string, userWalletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return KlayWalletControllerApiFp(configuration).getUserWalletBalance1(walletId, userWalletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce1(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWalletNonce1(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets1(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWallets1(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey1(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).patchAccountKey1(walletId, updateAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).patchMasterWalletName1(walletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName1(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).patchUserWalletName1(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy1(walletId, policyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet1(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).retryCreateMasterWallet1(walletId, retryCreateWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet1(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).retryCreateUserWallet1(walletId, userWalletId, retryCreateWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction1(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return KlayWalletControllerApiFp(configuration).sendBatchTransaction1(createBatchTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any): AxiosPromise<TransactionDTO> {
            return KlayWalletControllerApiFp(configuration).sendTransaction1(createMultiSigTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return KlayWalletControllerApiFp(configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayWalletControllerApi - object-oriented interface
 * @export
 * @class KlayWalletControllerApi
 * @extends {BaseAPI}
 */
export class KlayWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMasterWalletRequest} createMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createMasterWallet1(createMasterWalletRequest: CreateMasterWalletRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createMasterWallet1(createMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateUserWalletRequest} createUserWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createUserWallet1(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createUserWallet1(walletId, createUserWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPolicies1(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddress1(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {number} coinId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddressesByCoinId2(walletId: string, coinId: number, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddressesByCoinId2(walletId, coinId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWallet1(walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWallet1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletAccountKey1(walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletAccountKey1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletBalance1(walletId: string, symbol?: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletBalance1(walletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletInitialKey1(walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletInitialKey1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletNonce1(walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletNonce1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWallets1(sort: Sort, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWallets1(sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWallet1(walletId: string, userWalletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWallet1(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletBalance1(walletId: string, userWalletId: string, symbol?: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletBalance1(walletId, userWalletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletNonce1(walletId: string, userWalletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletNonce1(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWallets1(walletId: string, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWallets1(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchAccountKey1(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchAccountKey1(walletId, updateAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchMasterWalletName1(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchMasterWalletName1(walletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchUserWalletName1(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchUserWalletName1(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} policyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchWalletWithdrawalPolicy1(walletId: string, policyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy1(walletId, policyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateMasterWallet1(walletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateMasterWallet1(walletId, retryCreateWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {RetryCreateWalletRequest} retryCreateWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateUserWallet1(walletId: string, userWalletId: string, retryCreateWalletRequest: RetryCreateWalletRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateUserWallet1(walletId, userWalletId, retryCreateWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendBatchTransaction1(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendBatchTransaction1(createBatchTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMultiSigTransactionRequest} createMultiSigTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendTransaction1(createMultiSigTransactionRequest: CreateMultiSigTransactionRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendTransaction1(createMultiSigTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const KlayWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval1.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval1.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransactionDTO> {
            return KlayWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return KlayWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class KlayWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class KlayWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const MethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages2: async (blockchain?: string, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const MethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages2(blockchain?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await MethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages2(blockchain, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MethodGasUsageControllerApi - factory interface
 * @export
 */
export const MethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages2(blockchain?: string, name?: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return MethodGasUsageControllerApiFp(configuration).getMethodGasUsages2(blockchain, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class MethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class MethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [blockchain] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodGasUsageControllerApi
     */
    public getMethodGasUsages2(blockchain?: string, name?: string, options?: any) {
        return MethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages2(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransactionControllerApi - axios parameter creator
 * @export
 */
export const TransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions2: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions2.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getAllTransactions2.');
            }
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById2: async (blockchain: string, transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            if (blockchain === null || blockchain === undefined) {
                throw new RequiredError('blockchain','Required parameter blockchain was null or undefined when calling getTransactionById2.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById2.');
            }
            const localVarPath = `/api/v1/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionControllerApi - functional programming interface
 * @export
 */
export const TransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions2(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await TransactionControllerApiAxiosParamCreator(configuration).getAllTransactions2(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById2(blockchain: string, transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await TransactionControllerApiAxiosParamCreator(configuration).getTransactionById2(blockchain, transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransactionControllerApi - factory interface
 * @export
 */
export const TransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions2(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return TransactionControllerApiFp(configuration).getAllTransactions2(pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById2(blockchain: string, transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return TransactionControllerApiFp(configuration).getTransactionById2(blockchain, transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionControllerApi - object-oriented interface
 * @export
 * @class TransactionControllerApi
 * @extends {BaseAPI}
 */
export class TransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionControllerApi
     */
    public getAllTransactions2(pageable: Pageable, specs: object, options?: any) {
        return TransactionControllerApiFp(this.configuration).getAllTransactions2(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} blockchain 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionControllerApi
     */
    public getTransactionById2(blockchain: string, transactionId: string, options?: any) {
        return TransactionControllerApiFp(this.configuration).getTransactionById2(blockchain, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMasterWalletRequestV1} createMasterWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2: async (createMasterWalletRequestV1: CreateMasterWalletRequestV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMasterWalletRequestV1' is not null or undefined
            if (createMasterWalletRequestV1 === null || createMasterWalletRequestV1 === undefined) {
                throw new RequiredError('createMasterWalletRequestV1','Required parameter createMasterWalletRequestV1 was null or undefined when calling createMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMasterWalletRequestV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMasterWalletRequestV1 !== undefined ? createMasterWalletRequestV1 : {}) : (createMasterWalletRequestV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet2: async (walletId: string, createUserWalletRequest: CreateUserWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet2.');
            }
            // verify required parameter 'createUserWalletRequest' is not null or undefined
            if (createUserWalletRequest === null || createUserWalletRequest === undefined) {
                throw new RequiredError('createUserWalletRequest','Required parameter createUserWalletRequest was null or undefined when calling createUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserWalletRequest !== undefined ? createUserWalletRequest : {}) : (createUserWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance2: async (walletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2: async (sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets2.');
            }
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet2: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance2: async (walletId: string, userWalletId: string, symbol?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce2: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets2: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey2: async (walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey2.');
            }
            // verify required parameter 'updateAccountKeyRequest' is not null or undefined
            if (updateAccountKeyRequest === null || updateAccountKeyRequest === undefined) {
                throw new RequiredError('updateAccountKeyRequest','Required parameter updateAccountKeyRequest was null or undefined when calling patchAccountKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAccountKeyRequest !== undefined ? updateAccountKeyRequest : {}) : (updateAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2: async (walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName2.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchMasterWalletName2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName2: async (walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName2.');
            }
            // verify required parameter 'changeWalletNameRequest' is not null or undefined
            if (changeWalletNameRequest === null || changeWalletNameRequest === undefined) {
                throw new RequiredError('changeWalletNameRequest','Required parameter changeWalletNameRequest was null or undefined when calling patchUserWalletName2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeWalletNameRequest !== undefined ? changeWalletNameRequest : {}) : (changeWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet2: async (walletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet2.');
            }
            // verify required parameter 'retryCreateWalletRequestV1' is not null or undefined
            if (retryCreateWalletRequestV1 === null || retryCreateWalletRequestV1 === undefined) {
                throw new RequiredError('retryCreateWalletRequestV1','Required parameter retryCreateWalletRequestV1 was null or undefined when calling retryCreateMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequestV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequestV1 !== undefined ? retryCreateWalletRequestV1 : {}) : (retryCreateWalletRequestV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet2: async (walletId: string, userWalletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet2.');
            }
            // verify required parameter 'retryCreateWalletRequestV1' is not null or undefined
            if (retryCreateWalletRequestV1 === null || retryCreateWalletRequestV1 === undefined) {
                throw new RequiredError('retryCreateWalletRequestV1','Required parameter retryCreateWalletRequestV1 was null or undefined when calling retryCreateUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof retryCreateWalletRequestV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(retryCreateWalletRequestV1 !== undefined ? retryCreateWalletRequestV1 : {}) : (retryCreateWalletRequestV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction2: async (createBatchTransactionRequest: CreateBatchTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBatchTransactionRequest' is not null or undefined
            if (createBatchTransactionRequest === null || createBatchTransactionRequest === undefined) {
                throw new RequiredError('createBatchTransactionRequest','Required parameter createBatchTransactionRequest was null or undefined when calling sendBatchTransaction2.');
            }
            const localVarPath = `/api/v1/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBatchTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBatchTransactionRequest !== undefined ? createBatchTransactionRequest : {}) : (createBatchTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequestV1} createMultiSigTransactionRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2: async (createMultiSigTransactionRequestV1: CreateMultiSigTransactionRequestV1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMultiSigTransactionRequestV1' is not null or undefined
            if (createMultiSigTransactionRequestV1 === null || createMultiSigTransactionRequestV1 === undefined) {
                throw new RequiredError('createMultiSigTransactionRequestV1','Required parameter createMultiSigTransactionRequestV1 was null or undefined when calling sendTransaction2.');
            }
            const localVarPath = `/api/v1/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMultiSigTransactionRequestV1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMultiSigTransactionRequestV1 !== undefined ? createMultiSigTransactionRequestV1 : {}) : (createMultiSigTransactionRequestV1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMasterWalletRequestV1} createMasterWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet2(createMasterWalletRequestV1: CreateMasterWalletRequestV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet2(createMasterWalletRequestV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet2(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createUserWallet2(walletId, createUserWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance2(walletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance2(walletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets2(sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets2(sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet2(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWallet2(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance2(walletId: string, userWalletId: string, symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance2(walletId, userWalletId, symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce2(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce2(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets2(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWallets2(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey2(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchAccountKey2(walletId, updateAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName2(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName2(walletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName2(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchUserWalletName2(walletId, userWalletId, changeWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet2(walletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet2(walletId, retryCreateWalletRequestV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet2(walletId: string, userWalletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet2(walletId, userWalletId, retryCreateWalletRequestV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction2(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction2(createBatchTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequestV1} createMultiSigTransactionRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction2(createMultiSigTransactionRequestV1: CreateMultiSigTransactionRequestV1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction2(createMultiSigTransactionRequestV1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateMasterWalletRequestV1} createMasterWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2(createMasterWalletRequestV1: CreateMasterWalletRequestV1, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet2(createMasterWalletRequestV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateUserWalletRequest} createUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet2(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).createUserWallet2(walletId, createUserWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey2(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletAccountKey2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance2(walletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return WalletControllerApiFp(configuration).getMasterWalletBalance2(walletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce2(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletNonce2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2(sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets2(sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet2(walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).getUserWallet2(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance2(walletId: string, userWalletId: string, symbol?: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return WalletControllerApiFp(configuration).getUserWalletBalance2(walletId, userWalletId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce2(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return WalletControllerApiFp(configuration).getUserWalletNonce2(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets2(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return WalletControllerApiFp(configuration).getUserWallets2(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey2(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchAccountKey2(walletId, updateAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName2(walletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {ChangeWalletNameRequest} changeWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName2(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).patchUserWalletName2(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet2(walletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).retryCreateMasterWallet2(walletId, retryCreateWalletRequestV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet2(walletId: string, userWalletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).retryCreateUserWallet2(walletId, userWalletId, retryCreateWalletRequestV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction2(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return WalletControllerApiFp(configuration).sendBatchTransaction2(createBatchTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMultiSigTransactionRequestV1} createMultiSigTransactionRequestV1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2(createMultiSigTransactionRequestV1: CreateMultiSigTransactionRequestV1, options?: any): AxiosPromise<TransactionDTO> {
            return WalletControllerApiFp(configuration).sendTransaction2(createMultiSigTransactionRequestV1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateMasterWalletRequestV1} createMasterWalletRequestV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet2(createMasterWalletRequestV1: CreateMasterWalletRequestV1, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet2(createMasterWalletRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateUserWalletRequest} createUserWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createUserWallet2(walletId: string, createUserWalletRequest: CreateUserWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createUserWallet2(walletId, createUserWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet2(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletAccountKey2(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletAccountKey2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletBalance2(walletId: string, symbol?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletBalance2(walletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey2(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletNonce2(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletNonce2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets2(sort: Sort, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets2(sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWallet2(walletId: string, userWalletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWallet2(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletBalance2(walletId: string, userWalletId: string, symbol?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWalletBalance2(walletId, userWalletId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletNonce2(walletId: string, userWalletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWalletNonce2(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWallets2(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWallets2(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {UpdateAccountKeyRequest} updateAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchAccountKey2(walletId: string, updateAccountKeyRequest: UpdateAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchAccountKey2(walletId, updateAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName2(walletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName2(walletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {ChangeWalletNameRequest} changeWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchUserWalletName2(walletId: string, userWalletId: string, changeWalletNameRequest: ChangeWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchUserWalletName2(walletId, userWalletId, changeWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public retryCreateMasterWallet2(walletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any) {
        return WalletControllerApiFp(this.configuration).retryCreateMasterWallet2(walletId, retryCreateWalletRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {RetryCreateWalletRequestV1} retryCreateWalletRequestV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public retryCreateUserWallet2(walletId: string, userWalletId: string, retryCreateWalletRequestV1: RetryCreateWalletRequestV1, options?: any) {
        return WalletControllerApiFp(this.configuration).retryCreateUserWallet2(walletId, userWalletId, retryCreateWalletRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateBatchTransactionRequest} createBatchTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendBatchTransaction2(createBatchTransactionRequest: CreateBatchTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendBatchTransaction2(createBatchTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMultiSigTransactionRequestV1} createMultiSigTransactionRequestV1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction2(createMultiSigTransactionRequestV1: CreateMultiSigTransactionRequestV1, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction2(createMultiSigTransactionRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

}


