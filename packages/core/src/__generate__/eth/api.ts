/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://dev.wallet.henesis.io/docs/v2/eth".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ActivateAllowedAddressRequest
 */
export interface ActivateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressRequest
     */
    otpCode: string;
}

/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
}

/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    coinType: BalanceDTO.CoinTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableAmount: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    symbol: string;
}

/**
 * @export
 * @namespace BalanceDTO
 */
export namespace BalanceDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum CoinTypeEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        TOKEN = <any> 'TOKEN'
    }
}

/**
 * 
 * @export
 * @interface BatchTransactionDTO
 */
export interface BatchTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof BatchTransactionDTO
     */
    message: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof BatchTransactionDTO
     */
    transaction: TransactionDTO;
}

/**
 * 
 * @export
 * @interface CallEventDTO
 */
export interface CallEventDTO {
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {number}
     * @memberof CallEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    status: CallEventDTO.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    walletId: string;
}

/**
 * @export
 * @namespace CallEventDTO
 */
export namespace CallEventDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDINGAPPROVAL = <any> 'PENDING_APPROVAL',
        REJECTED = <any> 'REJECTED',
        REQUESTED = <any> 'REQUESTED',
        PENDING = <any> 'PENDING',
        FAILED = <any> 'FAILED',
        REPLACED = <any> 'REPLACED',
        MINED = <any> 'MINED',
        CONFIRMED = <any> 'CONFIRMED'
    }
}

/**
 * 
 * @export
 * @interface ChangeWalletNameRequest
 */
export interface ChangeWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeWalletNameRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CoinDTO
 */
export interface CoinDTO {
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    blockchain: CoinDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    desc: string;
    /**
     * 
     * @type {number}
     * @memberof CoinDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    symbol: string;
}

/**
 * @export
 * @namespace CoinDTO
 */
export namespace CoinDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
}

/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    coinId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}

/**
 * 
 * @export
 * @interface CreateBatchTransactionRequest
 */
export interface CreateBatchTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {Array<SignedMultiSigPayloadDTO>}
     * @memberof CreateBatchTransactionRequest
     */
    signedMultiSigPayloads: Array<SignedMultiSigPayloadDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    walletId: string;
}

/**
 * 
 * @export
 * @interface CreateCoinRequest
 */
export interface CreateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    symbol: string;
}

/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}

/**
 * 
 * @export
 * @interface CreateMasterWalletRequest
 */
export interface CreateMasterWalletRequest {
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateMultiSigTransactionRequest
 */
export interface CreateMultiSigTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateMultiSigTransactionRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    walletId: string;
}

/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    value: string;
}

/**
 * 
 * @export
 * @interface CreateUserWalletRequest
 */
export interface CreateUserWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    salt: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateUserWalletRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
}

/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: CreateWithdrawalPolicyRequest.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    walletType: CreateWithdrawalPolicyRequest.WalletTypeEnum;
}

/**
 * @export
 * @namespace CreateWithdrawalPolicyRequest
 */
export namespace CreateWithdrawalPolicyRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DAILY = <any> 'DAILY',
        TRANSACTION = <any> 'TRANSACTION'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WalletTypeEnum {
        MASTERWALLET = <any> 'MASTER_WALLET',
        USERWALLET = <any> 'USER_WALLET'
    }
}

/**
 * 
 * @export
 * @interface HenesisKeyBalanceDTO
 */
export interface HenesisKeyBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    coinType: HenesisKeyBalanceDTO.CoinTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    symbol: string;
}

/**
 * @export
 * @namespace HenesisKeyBalanceDTO
 */
export namespace HenesisKeyBalanceDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum CoinTypeEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        TOKEN = <any> 'TOKEN'
    }
}

/**
 * 
 * @export
 * @interface InactivateAllowedAddressRequest
 */
export interface InactivateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressRequest
     */
    otpCode: string;
}

/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    templated?: boolean;
}

/**
 * 
 * @export
 * @interface MapstringLink
 */
export interface MapstringLink {
    [key: string]: Link;

}

/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    blockchain: MasterWalletDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    status: MasterWalletDTO.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}

/**
 * @export
 * @namespace MasterWalletDTO
 */
export namespace MasterWalletDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        CREATING = <any> 'CREATING'
    }
}

/**
 * 
 * @export
 * @interface MethodGasUsageDTO
 */
export interface MethodGasUsageDTO {
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    blockchain: MethodGasUsageDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    estimatedGasConsumption: string;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    name: string;
}

/**
 * @export
 * @namespace MethodGasUsageDTO
 */
export namespace MethodGasUsageDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _425TOOEARLY = <any> '425 TOO_EARLY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}

/**
 * 
 * @export
 * @interface MultiSigPayloadDTO
 */
export interface MultiSigPayloadDTO {
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    hexData: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletNonce: string;
}

/**
 * 
 * @export
 * @interface NonceDTO
 */
export interface NonceDTO {
    /**
     * 
     * @type {string}
     * @memberof NonceDTO
     */
    nonce: string;
}

/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}

/**
 * 
 * @export
 * @interface PaginationCallEventDTO
 */
export interface PaginationCallEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationCallEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<CallEventDTO>}
     * @memberof PaginationCallEventDTO
     */
    results: Array<CallEventDTO>;
}

/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}

/**
 * 
 * @export
 * @interface PaginationTransactionDTO
 */
export interface PaginationTransactionDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransactionDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransactionDTO>}
     * @memberof PaginationTransactionDTO
     */
    results: Array<TransactionDTO>;
}

/**
 * 
 * @export
 * @interface PaginationUserWalletDTO
 */
export interface PaginationUserWalletDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationUserWalletDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<UserWalletDTO>}
     * @memberof PaginationUserWalletDTO
     */
    results: Array<UserWalletDTO>;
}

/**
 * 
 * @export
 * @interface PaginationValueTransferEventDTO
 */
export interface PaginationValueTransferEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationValueTransferEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<ValueTransferEventDTO>}
     * @memberof PaginationValueTransferEventDTO
     */
    results: Array<ValueTransferEventDTO>;
}

/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}

/**
 * 
 * @export
 * @interface PatchAllowedAddressLabelRequest
 */
export interface PatchAllowedAddressLabelRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAllowedAddressLabelRequest
     */
    label: string;
}

/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode?: string;
}

/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasLimit: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasPrice: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    value: string;
}

/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}

/**
 * 
 * @export
 * @interface RetryCreateWalletRequest
 */
export interface RetryCreateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequest
     */
    gasPrice?: string;
}

/**
 * 
 * @export
 * @interface SignedMultiSigPayloadDTO
 */
export interface SignedMultiSigPayloadDTO {
    /**
     * 
     * @type {MultiSigPayloadDTO}
     * @memberof SignedMultiSigPayloadDTO
     */
    multiSigPayload: MultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof SignedMultiSigPayloadDTO
     */
    signature: string;
}

/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    blockchain: TransactionDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    keyId: string;
    /**
     * 
     * @type {RawTransactionDTO}
     * @memberof TransactionDTO
     */
    rawTransaction: RawTransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    sender: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof TransactionDTO
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    status: TransactionDTO.StatusEnum;
}

/**
 * @export
 * @namespace TransactionDTO
 */
export namespace TransactionDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDINGAPPROVAL = <any> 'PENDING_APPROVAL',
        REJECTED = <any> 'REJECTED',
        REQUESTED = <any> 'REQUESTED',
        PENDING = <any> 'PENDING',
        FAILED = <any> 'FAILED',
        MINED = <any> 'MINED',
        REVERTED = <any> 'REVERTED',
        CONFIRMED = <any> 'CONFIRMED',
        REPLACED = <any> 'REPLACED'
    }
}

/**
 * 
 * @export
 * @interface UpdateAccountKeyRequest
 */
export interface UpdateAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    otpCode?: string;
}

/**
 * 
 * @export
 * @interface UpdateCoinRequest
 */
export interface UpdateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    symbol: string;
}

/**
 * 
 * @export
 * @interface UserWalletDTO
 */
export interface UserWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    blockchain: UserWalletDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    status: UserWalletDTO.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    updatedAt: string;
}

/**
 * @export
 * @namespace UserWalletDTO
 */
export namespace UserWalletDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        CREATING = <any> 'CREATING'
    }
}

/**
 * 
 * @export
 * @interface ValueTransferEventDTO
 */
export interface ValueTransferEventDTO {
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    from: string;
    /**
     * 
     * @type {number}
     * @memberof ValueTransferEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    status: ValueTransferEventDTO.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transferType: ValueTransferEventDTO.TransferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    walletId: string;
}

/**
 * @export
 * @namespace ValueTransferEventDTO
 */
export namespace ValueTransferEventDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDINGAPPROVAL = <any> 'PENDING_APPROVAL',
        REJECTED = <any> 'REJECTED',
        REQUESTED = <any> 'REQUESTED',
        PENDING = <any> 'PENDING',
        FAILED = <any> 'FAILED',
        REPLACED = <any> 'REPLACED',
        MINED = <any> 'MINED',
        CONFIRMED = <any> 'CONFIRMED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransferTypeEnum {
        WITHDRAWAL = <any> 'WITHDRAWAL',
        DEPOSIT = <any> 'DEPOSIT'
    }
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: WalletWithdrawalPolicyDTO.BlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WalletWithdrawalPolicyDTO.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletType: WalletWithdrawalPolicyDTO.WalletTypeEnum;
}

/**
 * @export
 * @namespace WalletWithdrawalPolicyDTO
 */
export namespace WalletWithdrawalPolicyDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum BlockchainEnum {
        ETHEREUM = <any> 'ETHEREUM',
        KLAYTN = <any> 'KLAYTN',
        BITCOIN = <any> 'BITCOIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DAILY = <any> 'DAILY',
        TRANSACTION = <any> 'TRANSACTION'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WalletTypeEnum {
        MASTERWALLET = <any> 'MASTER_WALLET',
        USERWALLET = <any> 'USER_WALLET'
    }
}


/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * EthCoinControllerApi - fetch parameter creator
 * @export
 */
export const EthCoinControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST(request: CreateCoinRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createCoinUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCoinRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE(symbol: string, options: any = {}): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoinUsingDELETE.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllCoins
         * @param {'true'} flag flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET1(flag: 'true', options: any = {}): FetchArgs {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getAllCoinsUsingGET1.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET(symbol: string, options: any = {}): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoinUsingGET.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH(request: UpdateCoinRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchCoinUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCoinRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthCoinControllerApi - functional programming interface
 * @export
 */
export const EthCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST(request: CreateCoinRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoinDTO> {
            const localVarFetchArgs = EthCoinControllerApiFetchParamCreator(configuration).createCoinUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE(symbol: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthCoinControllerApiFetchParamCreator(configuration).deleteCoinUsingDELETE(symbol, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllCoins
         * @param {'true'} flag flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET1(flag: 'true', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CoinDTO>> {
            const localVarFetchArgs = EthCoinControllerApiFetchParamCreator(configuration).getAllCoinsUsingGET1(flag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET(symbol: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoinDTO> {
            const localVarFetchArgs = EthCoinControllerApiFetchParamCreator(configuration).getCoinUsingGET(symbol, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH(request: UpdateCoinRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthCoinControllerApiFetchParamCreator(configuration).patchCoinUsingPATCH(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthCoinControllerApi - factory interface
 * @export
 */
export const EthCoinControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST(request: CreateCoinRequest, options?: any) {
            return EthCoinControllerApiFp(configuration).createCoinUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE(symbol: string, options?: any) {
            return EthCoinControllerApiFp(configuration).deleteCoinUsingDELETE(symbol, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllCoins
         * @param {'true'} flag flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET1(flag: 'true', options?: any) {
            return EthCoinControllerApiFp(configuration).getAllCoinsUsingGET1(flag, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET(symbol: string, options?: any) {
            return EthCoinControllerApiFp(configuration).getCoinUsingGET(symbol, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH(request: UpdateCoinRequest, options?: any) {
            return EthCoinControllerApiFp(configuration).patchCoinUsingPATCH(request, options)(fetch, basePath);
        },
    };
};

/**
 * EthCoinControllerApi - object-oriented interface
 * @export
 * @class EthCoinControllerApi
 * @extends {BaseAPI}
 */
export class EthCoinControllerApi extends BaseAPI {
    /**
     * 
     * @summary createCoin
     * @param {CreateCoinRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public createCoinUsingPOST(request: CreateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).createCoinUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteCoin
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public deleteCoinUsingDELETE(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).deleteCoinUsingDELETE(symbol, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllCoins
     * @param {'true'} flag flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getAllCoinsUsingGET1(flag: 'true', options?: any) {
        return EthCoinControllerApiFp(this.configuration).getAllCoinsUsingGET1(flag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCoin
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getCoinUsingGET(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).getCoinUsingGET(symbol, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchCoin
     * @param {UpdateCoinRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public patchCoinUsingPATCH(request: UpdateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).patchCoinUsingPATCH(request, options)(this.fetch, this.basePath);
    }

}

/**
 * EthEventControllerApi - fetch parameter creator
 * @export
 */
export const EthEventControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/call-events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/value-transfer-events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthEventControllerApi - functional programming interface
 * @export
 */
export const EthEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationCallEventDTO> {
            const localVarFetchArgs = EthEventControllerApiFetchParamCreator(configuration).getCallEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationValueTransferEventDTO> {
            const localVarFetchArgs = EthEventControllerApiFetchParamCreator(configuration).getValueTransferEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthEventControllerApi - factory interface
 * @export
 */
export const EthEventControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthEventControllerApiFp(configuration).getCallEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthEventControllerApiFp(configuration).getValueTransferEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
    };
};

/**
 * EthEventControllerApi - object-oriented interface
 * @export
 * @class EthEventControllerApi
 * @extends {BaseAPI}
 */
export class EthEventControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCallEvents
     * @param {number} [offset] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getCallEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthEventControllerApiFp(this.configuration).getCallEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getValueTransferEvents
     * @param {number} [offset] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getValueTransferEventsUsingGET(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthEventControllerApiFp(this.configuration).getValueTransferEventsUsingGET(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

}

/**
 * EthHenesisKeyControllerApi - fetch parameter creator
 * @export
 */
export const EthHenesisKeyControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST(createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKeyUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateHenesisKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createHenesisKeyRequest || {}) : (createHenesisKeyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createTransactionUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/henesis-keys/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/henesis-keys/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const EthHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = EthHenesisKeyControllerApiFetchParamCreator(configuration).createHenesisKeyUsingPOST(createHenesisKeyRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = EthHenesisKeyControllerApiFetchParamCreator(configuration).createTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HenesisKeyBalanceDTO> {
            const localVarFetchArgs = EthHenesisKeyControllerApiFetchParamCreator(configuration).getHenesisKeyBalanceUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = EthHenesisKeyControllerApiFetchParamCreator(configuration).getHenesisKeyUsingGET(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - factory interface
 * @export
 */
export const EthHenesisKeyControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
            return EthHenesisKeyControllerApiFp(configuration).createHenesisKeyUsingPOST(createHenesisKeyRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthHenesisKeyControllerApiFp(configuration).createTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKeyBalanceUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKeyUsingGET(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * EthHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class EthHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class EthHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @summary createHenesisKey
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createHenesisKeyUsingPOST(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createHenesisKeyUsingPOST(createHenesisKeyRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createTransaction
     * @param {CreateTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createTransactionUsingPOST(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHenesisKeyBalance
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKeyBalanceUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalanceUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHenesisKey
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKeyUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKeyUsingGET(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * EthMethodGasUsageControllerApi - fetch parameter creator
 * @export
 */
export const EthMethodGasUsageControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsagesUsingGET.');
            }
            const localVarPath = `/api/v2/eth/method-gas-usages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const EthMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MethodGasUsageDTO> {
            const localVarFetchArgs = EthMethodGasUsageControllerApiFetchParamCreator(configuration).getMethodGasUsagesUsingGET(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - factory interface
 * @export
 */
export const EthMethodGasUsageControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET(name: string, options?: any) {
            return EthMethodGasUsageControllerApiFp(configuration).getMethodGasUsagesUsingGET(name, options)(fetch, basePath);
        },
    };
};

/**
 * EthMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class EthMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class EthMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @summary getMethodGasUsages
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthMethodGasUsageControllerApi
     */
    public getMethodGasUsagesUsingGET(name: string, options?: any) {
        return EthMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsagesUsingGET(name, options)(this.fetch, this.basePath);
    }

}

/**
 * EthTransactionControllerApi - fetch parameter creator
 * @export
 */
export const EthTransactionControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionByIdUsingGET.');
            }
            const localVarPath = `/api/v2/eth/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthTransactionControllerApi - functional programming interface
 * @export
 */
export const EthTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationTransactionDTO> {
            const localVarFetchArgs = EthTransactionControllerApiFetchParamCreator(configuration).getAllTransactionsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = EthTransactionControllerApiFetchParamCreator(configuration).getTransactionByIdUsingGET(transactionId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthTransactionControllerApi - factory interface
 * @export
 */
export const EthTransactionControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthTransactionControllerApiFp(configuration).getAllTransactionsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthTransactionControllerApiFp(configuration).getTransactionByIdUsingGET(transactionId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * EthTransactionControllerApi - object-oriented interface
 * @export
 * @class EthTransactionControllerApi
 * @extends {BaseAPI}
 */
export class EthTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllTransactions
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getAllTransactionsUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getAllTransactionsUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTransactionById
     * @param {string} transactionId transactionId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getTransactionByIdUsingGET(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getTransactionByIdUsingGET(transactionId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * EthWalletControllerApi - fetch parameter creator
 * @export
 */
export const EthWalletControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling activateAllowedAddressUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling activateAllowedAddressUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddressUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/activate`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActivateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createAllowedAddressUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddressUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createMasterWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMasterWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createUserWalletUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicyUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicyUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(needOTP || {}) : (needOTP || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddressUsingDELETE.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddressUsingDELETE.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPoliciesUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddressUsingGET.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKeyUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET1(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getMasterWalletBalanceUsingGET1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalanceUsingGET1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKeyUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/wallets/{walletId}/nonce`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }

            if (unsorted !== undefined) {
                localVarQueryParameter['unsorted'] = unsorted;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {'true'} flag flag
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET1(flag: 'true', userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getUserWalletBalanceUsingGET1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalanceUsingGET1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalanceUsingGET1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/nonce`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletUsingGET.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletsUsingGET.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling inactivateAllowedAddressUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling inactivateAllowedAddressUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddressUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/inactivate`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InactivateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'updateAccountKeyRequest' is not null or undefined
            if (updateAccountKeyRequest === null || updateAccountKeyRequest === undefined) {
                throw new RequiredError('updateAccountKeyRequest','Required parameter updateAccountKeyRequest was null or undefined when calling patchAccountKeyUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKeyUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAccountKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateAccountKeyRequest || {}) : (updateAccountKeyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling patchAllowedAddressLabelUsingPATCH.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchAllowedAddressLabelUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAllowedAddressLabelUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}/label`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchAllowedAddressLabelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchMasterWalletNameUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletNameUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeWalletNameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchUserWalletNameUsingPATCH.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletNameUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletNameUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeWalletNameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchWithdrawalPolicyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest || {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling retryCreateMasterWalletUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetryCreateWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling retryCreateUserWalletUsingPOST.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWalletUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetryCreateWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling sendBatchTransactionUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/batch-transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBatchTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling sendTransactionUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/wallets/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMultiSigTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWalletControllerApi - functional programming interface
 * @export
 */
export const EthWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).activateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).createAllowedAddressUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).createMasterWalletUsingPOST(request, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).createUserWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).deleteAllowedAddressUsingDELETE(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationWalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getAllWalletWithdrawalPoliciesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getAllowedAddressUsingGET(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationAllowedAddressDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getAllowedAddressesUsingGET(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletAccountKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET1(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BalanceDTO>> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletBalanceUsingGET1(flag, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NonceDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletNonceUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MasterWalletDTO>> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {'true'} flag flag
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET1(flag: 'true', userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BalanceDTO>> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getUserWalletBalanceUsingGET1(flag, userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NonceDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getUserWalletNonceUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getUserWalletUsingGET(userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationUserWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).getUserWalletsUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).inactivateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).patchAccountKeyUsingPATCH(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).patchAllowedAddressLabelUsingPATCH(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).patchMasterWalletNameUsingPATCH(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).patchUserWalletNameUsingPATCH(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).retryCreateMasterWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).retryCreateUserWalletUsingPOST(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BatchTransactionDTO>> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).sendBatchTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = EthWalletControllerApiFetchParamCreator(configuration).sendTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthWalletControllerApi - factory interface
 * @export
 */
export const EthWalletControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).activateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).createAllowedAddressUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).createMasterWalletUsingPOST(request, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).createUserWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).deleteAllowedAddressUsingDELETE(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthWalletControllerApiFp(configuration).getAllWalletWithdrawalPoliciesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getAllowedAddressUsingGET(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthWalletControllerApiFp(configuration).getAllowedAddressesUsingGET(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletAccountKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET1(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletBalanceUsingGET1(flag, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET(options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletNonceUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any) {
            return EthWalletControllerApiFp(configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {'true'} flag flag
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET1(flag: 'true', userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getUserWalletBalanceUsingGET1(flag, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET(options?: any) {
            return EthWalletControllerApiFp(configuration).getUserWalletNonceUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).getUserWalletUsingGET(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return EthWalletControllerApiFp(configuration).getUserWalletsUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).inactivateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).patchAccountKeyUsingPATCH(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).patchAllowedAddressLabelUsingPATCH(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).patchMasterWalletNameUsingPATCH(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).patchUserWalletNameUsingPATCH(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).retryCreateMasterWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).retryCreateUserWalletUsingPOST(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).sendBatchTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWalletControllerApiFp(configuration).sendTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * EthWalletControllerApi - object-oriented interface
 * @export
 * @class EthWalletControllerApi
 * @extends {BaseAPI}
 */
export class EthWalletControllerApi extends BaseAPI {
    /**
     * 
     * @summary activateAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {ActivateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public activateAllowedAddressUsingPOST(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).activateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createAllowedAddress
     * @param {CreateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createAllowedAddressUsingPOST(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createAllowedAddressUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createMasterWallet
     * @param {CreateMasterWalletRequest} request request
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createMasterWalletUsingPOST(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createMasterWalletUsingPOST(request, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createUserWallet
     * @param {CreateUserWalletRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createUserWalletUsingPOST(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createUserWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createWalletWithdrawalPolicy
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public deleteAllowedAddressUsingDELETE(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).deleteAllowedAddressUsingDELETE(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllWalletWithdrawalPolicies
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllWalletWithdrawalPoliciesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPoliciesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddressUsingGET(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddressUsingGET(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllowedAddresses
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [coinId] coin_id
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddressesUsingGET(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddressesUsingGET(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletAccountKey
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletAccountKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletAccountKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletBalance
     * @param {'true'} flag flag
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletBalanceUsingGET1(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletBalanceUsingGET1(flag, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletInitialKey
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletNonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletNonceUsingGET(options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletNonceUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallet
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallets
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sorted] 
     * @param {boolean} [unsorted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWalletBalance
     * @param {'true'} flag flag
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletBalanceUsingGET1(flag: 'true', userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletBalanceUsingGET1(flag, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWalletNonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletNonceUsingGET(options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletNonceUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWallet
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletUsingGET(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletUsingGET(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWallets
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletsUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletsUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary inactivateAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {InactivateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public inactivateAllowedAddressUsingPOST(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).inactivateAllowedAddressUsingPOST(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchAccountKey
     * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchAccountKeyUsingPATCH(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchAccountKeyUsingPATCH(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchAllowedAddressLabel
     * @param {string} allowedAddressId allowedAddressId
     * @param {PatchAllowedAddressLabelRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchAllowedAddressLabelUsingPATCH(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchAllowedAddressLabelUsingPATCH(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchMasterWalletName
     * @param {ChangeWalletNameRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchMasterWalletNameUsingPATCH(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchMasterWalletNameUsingPATCH(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchUserWalletName
     * @param {ChangeWalletNameRequest} request request
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchUserWalletNameUsingPATCH(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchUserWalletNameUsingPATCH(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchWalletWithdrawalPolicy
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
     * @param {string} policyId policyId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary retryCreateMasterWallet
     * @param {RetryCreateWalletRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateMasterWalletUsingPOST(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateMasterWalletUsingPOST(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary retryCreateUserWallet
     * @param {RetryCreateWalletRequest} request request
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateUserWalletUsingPOST(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateUserWalletUsingPOST(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendBatchTransaction
     * @param {CreateBatchTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendBatchTransactionUsingPOST(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendBatchTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendTransaction
     * @param {CreateMultiSigTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendTransactionUsingPOST(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendTransactionUsingPOST(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * EthWithdrawalApprovalControllerApi - fetch parameter creator
 * @export
 */
export const EthWithdrawalApprovalControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApprovalUsingPOST.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApproveWithdrawalApprovalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest || {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApprovalUsingPOST.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RejectWithdrawalApprovalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest || {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = EthWithdrawalApprovalControllerApiFetchParamCreator(configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EthWithdrawalApprovalControllerApiFetchParamCreator(configuration).rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return EthWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * EthWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class EthWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class EthWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @summary approveWithdrawalApproval
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary rejectWithdrawalApproval
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApprovalUsingPOST(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayCoinControllerApi - fetch parameter creator
 * @export
 */
export const KlayCoinControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST1(request: CreateCoinRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createCoinUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCoinRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE1(symbol: string, options: any = {}): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoinUsingDELETE1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllCoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET2(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET1(symbol: string, options: any = {}): FetchArgs {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoinUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH1(request: UpdateCoinRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchCoinUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCoinRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayCoinControllerApi - functional programming interface
 * @export
 */
export const KlayCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST1(request: CreateCoinRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoinDTO> {
            const localVarFetchArgs = KlayCoinControllerApiFetchParamCreator(configuration).createCoinUsingPOST1(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE1(symbol: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayCoinControllerApiFetchParamCreator(configuration).deleteCoinUsingDELETE1(symbol, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllCoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CoinDTO>> {
            const localVarFetchArgs = KlayCoinControllerApiFetchParamCreator(configuration).getAllCoinsUsingGET2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET1(symbol: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoinDTO> {
            const localVarFetchArgs = KlayCoinControllerApiFetchParamCreator(configuration).getCoinUsingGET1(symbol, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH1(request: UpdateCoinRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayCoinControllerApiFetchParamCreator(configuration).patchCoinUsingPATCH1(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayCoinControllerApi - factory interface
 * @export
 */
export const KlayCoinControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createCoin
         * @param {CreateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinUsingPOST1(request: CreateCoinRequest, options?: any) {
            return KlayCoinControllerApiFp(configuration).createCoinUsingPOST1(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinUsingDELETE1(symbol: string, options?: any) {
            return KlayCoinControllerApiFp(configuration).deleteCoinUsingDELETE1(symbol, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllCoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoinsUsingGET2(options?: any) {
            return KlayCoinControllerApiFp(configuration).getAllCoinsUsingGET2(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getCoin
         * @param {string} symbol symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinUsingGET1(symbol: string, options?: any) {
            return KlayCoinControllerApiFp(configuration).getCoinUsingGET1(symbol, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchCoin
         * @param {UpdateCoinRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoinUsingPATCH1(request: UpdateCoinRequest, options?: any) {
            return KlayCoinControllerApiFp(configuration).patchCoinUsingPATCH1(request, options)(fetch, basePath);
        },
    };
};

/**
 * KlayCoinControllerApi - object-oriented interface
 * @export
 * @class KlayCoinControllerApi
 * @extends {BaseAPI}
 */
export class KlayCoinControllerApi extends BaseAPI {
    /**
     * 
     * @summary createCoin
     * @param {CreateCoinRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public createCoinUsingPOST1(request: CreateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).createCoinUsingPOST1(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteCoin
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public deleteCoinUsingDELETE1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).deleteCoinUsingDELETE1(symbol, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllCoins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getAllCoinsUsingGET2(options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getAllCoinsUsingGET2(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getCoin
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getCoinUsingGET1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getCoinUsingGET1(symbol, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchCoin
     * @param {UpdateCoinRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public patchCoinUsingPATCH1(request: UpdateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).patchCoinUsingPATCH1(request, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayEventControllerApi - fetch parameter creator
 * @export
 */
export const KlayEventControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/call-events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/value-transfer-events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayEventControllerApi - functional programming interface
 * @export
 */
export const KlayEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationCallEventDTO> {
            const localVarFetchArgs = KlayEventControllerApiFetchParamCreator(configuration).getCallEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationValueTransferEventDTO> {
            const localVarFetchArgs = KlayEventControllerApiFetchParamCreator(configuration).getValueTransferEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayEventControllerApi - factory interface
 * @export
 */
export const KlayEventControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getCallEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayEventControllerApiFp(configuration).getCallEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getValueTransferEvents
         * @param {number} [offset] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayEventControllerApiFp(configuration).getValueTransferEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
    };
};

/**
 * KlayEventControllerApi - object-oriented interface
 * @export
 * @class KlayEventControllerApi
 * @extends {BaseAPI}
 */
export class KlayEventControllerApi extends BaseAPI {
    /**
     * 
     * @summary getCallEvents
     * @param {number} [offset] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getCallEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getCallEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getValueTransferEvents
     * @param {number} [offset] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getValueTransferEventsUsingGET1(offset?: number, pageNumber?: number, pageSize?: number, paged?: boolean, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getValueTransferEventsUsingGET1(offset, pageNumber, pageSize, paged, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayHenesisKeyControllerApi - fetch parameter creator
 * @export
 */
export const KlayHenesisKeyControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST1(createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKeyUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateHenesisKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createHenesisKeyRequest || {}) : (createHenesisKeyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST1(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createTransactionUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/henesis-keys/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/henesis-keys/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const KlayHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = KlayHenesisKeyControllerApiFetchParamCreator(configuration).createHenesisKeyUsingPOST1(createHenesisKeyRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST1(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = KlayHenesisKeyControllerApiFetchParamCreator(configuration).createTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HenesisKeyBalanceDTO> {
            const localVarFetchArgs = KlayHenesisKeyControllerApiFetchParamCreator(configuration).getHenesisKeyBalanceUsingGET1(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = KlayHenesisKeyControllerApiFetchParamCreator(configuration).getHenesisKeyUsingGET1(accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - factory interface
 * @export
 */
export const KlayHenesisKeyControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createHenesisKey
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKeyUsingPOST1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
            return KlayHenesisKeyControllerApiFp(configuration).createHenesisKeyUsingPOST1(createHenesisKeyRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createTransaction
         * @param {CreateTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionUsingPOST1(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayHenesisKeyControllerApiFp(configuration).createTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHenesisKeyBalance
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalanceUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKeyBalanceUsingGET1(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHenesisKey
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKeyUsingGET1(accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * KlayHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class KlayHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class KlayHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @summary createHenesisKey
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest createHenesisKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createHenesisKeyUsingPOST1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createHenesisKeyUsingPOST1(createHenesisKeyRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createTransaction
     * @param {CreateTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createTransactionUsingPOST1(request: CreateTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHenesisKeyBalance
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKeyBalanceUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalanceUsingGET1(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHenesisKey
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKeyUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKeyUsingGET1(accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayMethodGasUsageControllerApi - fetch parameter creator
 * @export
 */
export const KlayMethodGasUsageControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET1(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsagesUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/method-gas-usages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET1(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MethodGasUsageDTO> {
            const localVarFetchArgs = KlayMethodGasUsageControllerApiFetchParamCreator(configuration).getMethodGasUsagesUsingGET1(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - factory interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getMethodGasUsages
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsagesUsingGET1(name: string, options?: any) {
            return KlayMethodGasUsageControllerApiFp(configuration).getMethodGasUsagesUsingGET1(name, options)(fetch, basePath);
        },
    };
};

/**
 * KlayMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class KlayMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class KlayMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @summary getMethodGasUsages
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayMethodGasUsageControllerApi
     */
    public getMethodGasUsagesUsingGET1(name: string, options?: any) {
        return KlayMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsagesUsingGET1(name, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayTransactionControllerApi - fetch parameter creator
 * @export
 */
export const KlayTransactionControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET1(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET1(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionByIdUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - functional programming interface
 * @export
 */
export const KlayTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET1(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationTransactionDTO> {
            const localVarFetchArgs = KlayTransactionControllerApiFetchParamCreator(configuration).getAllTransactionsUsingGET1(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET1(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = KlayTransactionControllerApiFetchParamCreator(configuration).getTransactionByIdUsingGET1(transactionId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - factory interface
 * @export
 */
export const KlayTransactionControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAllTransactions
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactionsUsingGET1(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayTransactionControllerApiFp(configuration).getAllTransactionsUsingGET1(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTransactionById
         * @param {string} transactionId transactionId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByIdUsingGET1(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayTransactionControllerApiFp(configuration).getTransactionByIdUsingGET1(transactionId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * KlayTransactionControllerApi - object-oriented interface
 * @export
 * @class KlayTransactionControllerApi
 * @extends {BaseAPI}
 */
export class KlayTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllTransactions
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getAllTransactionsUsingGET1(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getAllTransactionsUsingGET1(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTransactionById
     * @param {string} transactionId transactionId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getTransactionByIdUsingGET1(transactionId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getTransactionByIdUsingGET1(transactionId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayWalletControllerApi - fetch parameter creator
 * @export
 */
export const KlayWalletControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST1(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling activateAllowedAddressUsingPOST1.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling activateAllowedAddressUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddressUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/activate`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActivateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST1(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createAllowedAddressUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddressUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST1(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createMasterWalletUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMasterWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST1(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createUserWalletUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWalletUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicyUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicyUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(needOTP || {}) : (needOTP || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddressUsingDELETE1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddressUsingDELETE1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPoliciesUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddressUsingGET1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET1(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKeyUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET3(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getMasterWalletBalanceUsingGET3.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalanceUsingGET3.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKeyUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/wallets/{walletId}/nonce`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sorted !== undefined) {
                localVarQueryParameter['sorted'] = sorted;
            }

            if (unsorted !== undefined) {
                localVarQueryParameter['unsorted'] = unsorted;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET2(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalanceUsingGET2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalanceUsingGET2.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/nonce`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET1(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletUsingGET1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletsUsingGET1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(searchKeys || {}) : (searchKeys || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST1(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling inactivateAllowedAddressUsingPOST1.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling inactivateAllowedAddressUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddressUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/inactivate`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InactivateAllowedAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH1(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'updateAccountKeyRequest' is not null or undefined
            if (updateAccountKeyRequest === null || updateAccountKeyRequest === undefined) {
                throw new RequiredError('updateAccountKeyRequest','Required parameter updateAccountKeyRequest was null or undefined when calling patchAccountKeyUsingPATCH1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKeyUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAccountKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateAccountKeyRequest || {}) : (updateAccountKeyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH1(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling patchAllowedAddressLabelUsingPATCH1.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchAllowedAddressLabelUsingPATCH1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAllowedAddressLabelUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}/label`
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchAllowedAddressLabelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH1(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchMasterWalletNameUsingPATCH1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletNameUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeWalletNameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH1(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling patchUserWalletNameUsingPATCH1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletNameUsingPATCH1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletNameUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeWalletNameRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH1.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchWithdrawalPolicyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest || {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST1(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling retryCreateMasterWalletUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWalletUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetryCreateWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST1(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling retryCreateUserWalletUsingPOST1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWalletUsingPOST1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWalletUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetryCreateWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST1(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling sendBatchTransactionUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/batch-transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBatchTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST1(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling sendTransactionUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/wallets/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMultiSigTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWalletControllerApi - functional programming interface
 * @export
 */
export const KlayWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST1(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).activateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST1(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).createAllowedAddressUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST1(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).createMasterWalletUsingPOST1(request, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST1(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).createUserWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).deleteAllowedAddressUsingDELETE1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationWalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getAllWalletWithdrawalPoliciesUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getAllowedAddressUsingGET1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET1(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationAllowedAddressDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getAllowedAddressesUsingGET1(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletAccountKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET3(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BalanceDTO>> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletBalanceUsingGET3(flag, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletInitialKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NonceDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletNonceUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletUsingGET1(walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MasterWalletDTO>> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getMasterWalletsUsingGET1(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET2(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BalanceDTO>> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getUserWalletBalanceUsingGET2(userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NonceDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getUserWalletNonceUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET1(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getUserWalletUsingGET1(userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationUserWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).getUserWalletsUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST1(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).inactivateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH1(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).patchAccountKeyUsingPATCH1(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH1(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllowedAddressDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).patchAllowedAddressLabelUsingPATCH1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH1(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).patchMasterWalletNameUsingPATCH1(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH1(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).patchUserWalletNameUsingPATCH1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST1(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).retryCreateMasterWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST1(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserWalletDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).retryCreateUserWalletUsingPOST1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST1(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BatchTransactionDTO>> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).sendBatchTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST1(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = KlayWalletControllerApiFetchParamCreator(configuration).sendTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayWalletControllerApi - factory interface
 * @export
 */
export const KlayWalletControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary activateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {ActivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddressUsingPOST1(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).activateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createAllowedAddress
         * @param {CreateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddressUsingPOST1(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).createAllowedAddressUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createMasterWallet
         * @param {CreateMasterWalletRequest} request request
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWalletUsingPOST1(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).createMasterWalletUsingPOST1(request, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createUserWallet
         * @param {CreateUserWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWalletUsingPOST1(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).createUserWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddressUsingDELETE1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).deleteAllowedAddressUsingDELETE1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllWalletWithdrawalPolicies
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPoliciesUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayWalletControllerApiFp(configuration).getAllWalletWithdrawalPoliciesUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressUsingGET1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getAllowedAddressUsingGET1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllowedAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [coinId] coin_id
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesUsingGET1(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayWalletControllerApiFp(configuration).getAllowedAddressesUsingGET1(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletAccountKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletAccountKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletBalance
         * @param {'true'} flag flag
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalanceUsingGET3(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletBalanceUsingGET3(flag, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletInitialKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonceUsingGET1(options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletNonceUsingGET1(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sorted] 
         * @param {boolean} [unsorted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any) {
            return KlayWalletControllerApiFp(configuration).getMasterWalletsUsingGET1(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWalletBalance
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceUsingGET2(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getUserWalletBalanceUsingGET2(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWalletNonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonceUsingGET1(options?: any) {
            return KlayWalletControllerApiFp(configuration).getUserWalletNonceUsingGET1(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWallet
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletUsingGET1(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).getUserWalletUsingGET1(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserWallets
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {any} [searchKeys] searchKeys
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletsUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return KlayWalletControllerApiFp(configuration).getUserWalletsUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary inactivateAllowedAddress
         * @param {string} allowedAddressId allowedAddressId
         * @param {InactivateAllowedAddressRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddressUsingPOST1(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).inactivateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchAccountKey
         * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKeyUsingPATCH1(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).patchAccountKeyUsingPATCH1(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchAllowedAddressLabel
         * @param {string} allowedAddressId allowedAddressId
         * @param {PatchAllowedAddressLabelRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedAddressLabelUsingPATCH1(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).patchAllowedAddressLabelUsingPATCH1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH1(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).patchMasterWalletNameUsingPATCH1(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchUserWalletName
         * @param {ChangeWalletNameRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletNameUsingPATCH1(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).patchUserWalletNameUsingPATCH1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} policyId policyId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary retryCreateMasterWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWalletUsingPOST1(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).retryCreateMasterWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary retryCreateUserWallet
         * @param {RetryCreateWalletRequest} request request
         * @param {string} userWalletId userWalletId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWalletUsingPOST1(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).retryCreateUserWalletUsingPOST1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendBatchTransaction
         * @param {CreateBatchTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransactionUsingPOST1(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).sendBatchTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateMultiSigTransactionRequest} request request
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST1(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWalletControllerApiFp(configuration).sendTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * KlayWalletControllerApi - object-oriented interface
 * @export
 * @class KlayWalletControllerApi
 * @extends {BaseAPI}
 */
export class KlayWalletControllerApi extends BaseAPI {
    /**
     * 
     * @summary activateAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {ActivateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public activateAllowedAddressUsingPOST1(allowedAddressId: string, request: ActivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).activateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createAllowedAddress
     * @param {CreateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createAllowedAddressUsingPOST1(request: CreateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createAllowedAddressUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createMasterWallet
     * @param {CreateMasterWalletRequest} request request
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createMasterWalletUsingPOST1(request: CreateMasterWalletRequest, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createMasterWalletUsingPOST1(request, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createUserWallet
     * @param {CreateUserWalletRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createUserWalletUsingPOST1(request: CreateUserWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createUserWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createWalletWithdrawalPolicy
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicyUsingPOST1(createWithdrawalPolicyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public deleteAllowedAddressUsingDELETE1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).deleteAllowedAddressUsingDELETE1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllWalletWithdrawalPolicies
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllWalletWithdrawalPoliciesUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPoliciesUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddressUsingGET1(allowedAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddressUsingGET1(allowedAddressId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllowedAddresses
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [coinId] coin_id
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddressesUsingGET1(walletId: string, accountId?: string, coinId?: number, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddressesUsingGET1(walletId, accountId, coinId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletAccountKey
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletAccountKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletAccountKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletBalance
     * @param {'true'} flag flag
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletBalanceUsingGET3(flag: 'true', walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletBalanceUsingGET3(flag, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletInitialKey
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletInitialKeyUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletInitialKeyUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletNonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletNonceUsingGET1(options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletNonceUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallet
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletUsingGET1(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletUsingGET1(walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallets
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sorted] 
     * @param {boolean} [unsorted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletsUsingGET1(accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sorted?: boolean, unsorted?: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletsUsingGET1(accountId, organizationId, otpKey, roles, searchKeys, sorted, unsorted, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWalletBalance
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletBalanceUsingGET2(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletBalanceUsingGET2(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWalletNonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletNonceUsingGET1(options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletNonceUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWallet
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletUsingGET1(userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletUsingGET1(userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserWallets
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {any} [searchKeys] searchKeys
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletsUsingGET1(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, searchKeys?: any, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletsUsingGET1(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, roles, searchKeys, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary inactivateAllowedAddress
     * @param {string} allowedAddressId allowedAddressId
     * @param {InactivateAllowedAddressRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public inactivateAllowedAddressUsingPOST1(allowedAddressId: string, request: InactivateAllowedAddressRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).inactivateAllowedAddressUsingPOST1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchAccountKey
     * @param {UpdateAccountKeyRequest} updateAccountKeyRequest updateAccountKeyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchAccountKeyUsingPATCH1(updateAccountKeyRequest: UpdateAccountKeyRequest, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchAccountKeyUsingPATCH1(updateAccountKeyRequest, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchAllowedAddressLabel
     * @param {string} allowedAddressId allowedAddressId
     * @param {PatchAllowedAddressLabelRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchAllowedAddressLabelUsingPATCH1(allowedAddressId: string, request: PatchAllowedAddressLabelRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchAllowedAddressLabelUsingPATCH1(allowedAddressId, request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchMasterWalletName
     * @param {ChangeWalletNameRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchMasterWalletNameUsingPATCH1(request: ChangeWalletNameRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchMasterWalletNameUsingPATCH1(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchUserWalletName
     * @param {ChangeWalletNameRequest} request request
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchUserWalletNameUsingPATCH1(request: ChangeWalletNameRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchUserWalletNameUsingPATCH1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchWalletWithdrawalPolicy
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
     * @param {string} policyId policyId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, policyId: string, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicyUsingPATCH1(patchWithdrawalPolicyRequest, policyId, walletId, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary retryCreateMasterWallet
     * @param {RetryCreateWalletRequest} request request
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateMasterWalletUsingPOST1(request: RetryCreateWalletRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateMasterWalletUsingPOST1(request, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary retryCreateUserWallet
     * @param {RetryCreateWalletRequest} request request
     * @param {string} userWalletId userWalletId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateUserWalletUsingPOST1(request: RetryCreateWalletRequest, userWalletId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateUserWalletUsingPOST1(request, userWalletId, walletId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendBatchTransaction
     * @param {CreateBatchTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendBatchTransactionUsingPOST1(request: CreateBatchTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendBatchTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendTransaction
     * @param {CreateMultiSigTransactionRequest} request request
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendTransactionUsingPOST1(request: CreateMultiSigTransactionRequest, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendTransactionUsingPOST1(request, accountId, needOTP, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * KlayWithdrawalApprovalControllerApi - fetch parameter creator
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApprovalUsingPOST1.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApprovalUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApproveWithdrawalApprovalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest || {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options: any = {}): FetchArgs {
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApprovalUsingPOST1.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApprovalUsingPOST1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RejectWithdrawalApprovalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest || {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionDTO> {
            const localVarFetchArgs = KlayWithdrawalApprovalControllerApiFetchParamCreator(configuration).approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KlayWithdrawalApprovalControllerApiFetchParamCreator(configuration).rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
            return KlayWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(fetch, basePath);
        },
    };
};

/**
 * KlayWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class KlayWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class KlayWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @summary approveWithdrawalApproval
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApprovalUsingPOST1(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary rejectWithdrawalApproval
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest rejectWithdrawalApprovalRequest
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, organizationId?: string, otpKey?: string, roles?: Array<'COIN' | 'VIEWER' | 'ADMIN' | 'HAECHI' | 'SPENDER'>, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApprovalUsingPOST1(rejectWithdrawalApprovalRequest, withdrawalApprovalId, accountId, organizationId, otpKey, roles, options)(this.fetch, this.basePath);
    }

}

/**
 * OperationHandlerApi - fetch parameter creator
 * @export
 */
export const OperationHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health/**`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationHandlerApi - functional programming interface
 * @export
 */
export const OperationHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperationHandlerApi - factory interface
 * @export
 */
export const OperationHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET2(body, options)(fetch, basePath);
        },
    };
};

/**
 * OperationHandlerApi - object-oriented interface
 * @export
 * @class OperationHandlerApi
 * @extends {BaseAPI}
 */
export class OperationHandlerApi extends BaseAPI {
    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET1(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET2(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET2(body, options)(this.fetch, this.basePath);
    }

}

/**
 * WebMvcLinksHandlerApi - fetch parameter creator
 * @export
 */
export const WebMvcLinksHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/actuator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - functional programming interface
 * @export
 */
export const WebMvcLinksHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: { [key: string]: Link; }; }> {
            const localVarFetchArgs = WebMvcLinksHandlerApiFetchParamCreator(configuration).linksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - factory interface
 * @export
 */
export const WebMvcLinksHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any) {
            return WebMvcLinksHandlerApiFp(configuration).linksUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * WebMvcLinksHandlerApi - object-oriented interface
 * @export
 * @class WebMvcLinksHandlerApi
 * @extends {BaseAPI}
 */
export class WebMvcLinksHandlerApi extends BaseAPI {
    /**
     * 
     * @summary links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMvcLinksHandlerApi
     */
    public linksUsingGET(options?: any) {
        return WebMvcLinksHandlerApiFp(this.configuration).linksUsingGET(options)(this.fetch, this.basePath);
    }

}

