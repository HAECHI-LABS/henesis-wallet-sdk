// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateAllowedAddressesRequest
 */
export interface ActivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistedWalletId?: string;
    /**
     * 
     * @type {number}
     * @memberof AllowedAddressDTO
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof AllowedAddressDTO
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof AllowedAddressDTO
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AllowedCoinType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceDTO
     */
    coinId: number;
    /**
     * 
     * @type {CoinType}
     * @memberof BalanceDTO
     */
    coinType: CoinType;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableAmount: string;
}
/**
 * 
 * @export
 * @interface BatchTransactionDTO
 */
export interface BatchTransactionDTO {
    /**
     * 
     * @type {TransactionDTO}
     * @memberof BatchTransactionDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof BatchTransactionDTO
     */
    message: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface CallEventDTO
 */
export interface CallEventDTO {
    /**
     * 
     * @type {number}
     * @memberof CallEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof CallEventDTO
     */
    status: EventStatus;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof CallEventDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface ChangeWalletNameRequest
 */
export interface ChangeWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ChangeWalletNameRequestV1
 */
export interface ChangeWalletNameRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof ChangeWalletNameRequestV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeWalletNameRequestV1
     */
    blockchain?: string;
}
/**
 * 
 * @export
 * @interface CoinDTO
 */
export interface CoinDTO {
    /**
     * 
     * @type {number}
     * @memberof CoinDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CoinDTO
     */
    desc: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof CoinDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {Array<string>}
     * @memberof CoinDTO
     */
    attributes: Array<CoinDTOAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum CoinDTOAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CoinType {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    TOKEN = 'TOKEN'
}

/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateAllowedAddressRequest
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof CreateAllowedAddressRequest
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof CreateAllowedAddressRequest
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateBatchTransactionRequest
 */
export interface CreateBatchTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    walletId: string;
    /**
     * 
     * @type {Array<SignedMultiSigPayloadDTO>}
     * @memberof CreateBatchTransactionRequest
     */
    signedMultiSigPayloads: Array<SignedMultiSigPayloadDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateCoinRequest
 */
export interface CreateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCoinRequest
     */
    attributes: Array<CreateCoinRequestAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateCoinRequestAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}
/**
 * 
 * @export
 * @interface CreateMasterWalletRequest
 */
export interface CreateMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface CreateMasterWalletRequestV1
 */
export interface CreateMasterWalletRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestV1
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestV1
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestV1
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface CreateMultiSigTransactionRequest
 */
export interface CreateMultiSigTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    walletId: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateMultiSigTransactionRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateMultiSigTransactionRequestV1
 */
export interface CreateMultiSigTransactionRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    walletId: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMultiSigTransactionRequestV1
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasLimit?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateUserWalletRequest
 */
export interface CreateUserWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    salt: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof CreateUserWalletRequest
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserWalletRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {WalletWithdrawalPolicyWalletType}
     * @memberof CreateWithdrawalPolicyRequest
     */
    walletType: WalletWithdrawalPolicyWalletType;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: CreateWithdrawalPolicyRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateWithdrawalPolicyRequestTypeEnum {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}

/**
 * 
 * @export
 * @interface DeleteAllowedAddressRequest
 */
export interface DeleteAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EventStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    REPLACED = 'REPLACED',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED'
}

/**
 * 
 * @export
 * @interface HenesisKeyBalanceDTO
 */
export interface HenesisKeyBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyBalanceDTO
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof HenesisKeyBalanceDTO
     */
    coinId: number;
    /**
     * 
     * @type {CoinType}
     * @memberof HenesisKeyBalanceDTO
     */
    coinType: CoinType;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    otpKey?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Identity
     */
    roles?: Array<IdentityRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    username?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IdentityRolesEnum {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface InactivateAllowedAddressesRequest
 */
export interface InactivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateTransactionRequest}
     * @memberof InlineObject
     */
    request?: CreateTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject1
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMasterWalletRequest}
     * @memberof InlineObject1
     */
    request?: CreateMasterWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject10
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateWithdrawalPolicyRequest}
     * @memberof InlineObject10
     */
    createWithdrawalPolicyRequest?: CreateWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject11
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchWithdrawalPolicyRequest}
     * @memberof InlineObject11
     */
    patchWithdrawalPolicyRequest?: PatchWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject12
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateAllowedAddressRequest}
     * @memberof InlineObject12
     */
    request?: CreateAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject13
     */
    identity?: Identity;
    /**
     * 
     * @type {DeleteAllowedAddressRequest}
     * @memberof InlineObject13
     */
    request?: DeleteAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject14
     */
    identity?: Identity;
    /**
     * 
     * @type {ActivateAllowedAddressesRequest}
     * @memberof InlineObject14
     */
    request?: ActivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject15
     */
    identity?: Identity;
    /**
     * 
     * @type {InactivateAllowedAddressesRequest}
     * @memberof InlineObject15
     */
    request?: InactivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject16
     */
    identity?: Identity;
    /**
     * 
     * @type {ValidateIsAllowedAddressRequest}
     * @memberof InlineObject16
     */
    request?: ValidateIsAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject17
     */
    identity?: Identity;
    /**
     * 
     * @type {ApproveWithdrawalApprovalRequest}
     * @memberof InlineObject17
     */
    approveWithdrawalApprovalRequest?: ApproveWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject18
     */
    identity?: Identity;
    /**
     * 
     * @type {RejectWithdrawalApprovalRequest}
     * @memberof InlineObject18
     */
    rejectWithdrawalApprovalRequest?: RejectWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject19
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMasterWalletRequest}
     * @memberof InlineObject19
     */
    request?: CreateMasterWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject2
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequest}
     * @memberof InlineObject2
     */
    request?: ChangeWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject20
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequest}
     * @memberof InlineObject20
     */
    request?: ChangeWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject21
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdateAccountKeyRequest}
     * @memberof InlineObject21
     */
    updateAccountKeyRequest?: UpdateAccountKeyRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject21
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject22
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateUserWalletRequest}
     * @memberof InlineObject22
     */
    request?: CreateUserWalletRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject22
     */
    needOtp?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject23
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequest}
     * @memberof InlineObject23
     */
    request?: ChangeWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject24
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMultiSigTransactionRequest}
     * @memberof InlineObject24
     */
    request?: CreateMultiSigTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject24
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject25
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateBatchTransactionRequest}
     * @memberof InlineObject25
     */
    request?: CreateBatchTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject25
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject26
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequest}
     * @memberof InlineObject26
     */
    request?: RetryCreateWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject27
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequest}
     * @memberof InlineObject27
     */
    request?: RetryCreateWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject28
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateWithdrawalPolicyRequest}
     * @memberof InlineObject28
     */
    createWithdrawalPolicyRequest?: CreateWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject29
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchWithdrawalPolicyRequest}
     * @memberof InlineObject29
     */
    patchWithdrawalPolicyRequest?: PatchWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject3
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdateAccountKeyRequest}
     * @memberof InlineObject3
     */
    updateAccountKeyRequest?: UpdateAccountKeyRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject3
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject30
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateAllowedAddressRequest}
     * @memberof InlineObject30
     */
    request?: CreateAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject31
     */
    identity?: Identity;
    /**
     * 
     * @type {DeleteAllowedAddressRequest}
     * @memberof InlineObject31
     */
    request?: DeleteAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject32
     */
    identity?: Identity;
    /**
     * 
     * @type {ActivateAllowedAddressesRequest}
     * @memberof InlineObject32
     */
    request?: ActivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject33
 */
export interface InlineObject33 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject33
     */
    identity?: Identity;
    /**
     * 
     * @type {InactivateAllowedAddressesRequest}
     * @memberof InlineObject33
     */
    request?: InactivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject34
 */
export interface InlineObject34 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject34
     */
    identity?: Identity;
    /**
     * 
     * @type {ValidateIsAllowedAddressRequest}
     * @memberof InlineObject34
     */
    request?: ValidateIsAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject35
 */
export interface InlineObject35 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject35
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateTransactionRequest}
     * @memberof InlineObject35
     */
    request?: CreateTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject35
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject36
 */
export interface InlineObject36 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject36
     */
    identity?: Identity;
    /**
     * 
     * @type {ApproveWithdrawalApprovalRequest}
     * @memberof InlineObject36
     */
    approveWithdrawalApprovalRequest?: ApproveWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject37
 */
export interface InlineObject37 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject37
     */
    identity?: Identity;
    /**
     * 
     * @type {RejectWithdrawalApprovalRequest}
     * @memberof InlineObject37
     */
    rejectWithdrawalApprovalRequest?: RejectWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject38
 */
export interface InlineObject38 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject38
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMasterWalletRequestV1}
     * @memberof InlineObject38
     */
    request?: CreateMasterWalletRequestV1;
}
/**
 * 
 * @export
 * @interface InlineObject39
 */
export interface InlineObject39 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject39
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequestV1}
     * @memberof InlineObject39
     */
    request?: ChangeWalletNameRequestV1;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject4
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateUserWalletRequest}
     * @memberof InlineObject4
     */
    request?: CreateUserWalletRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject4
     */
    needOtp?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject40
 */
export interface InlineObject40 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject40
     */
    identity?: Identity;
    /**
     * 
     * @type {UpdateAccountKeyRequest}
     * @memberof InlineObject40
     */
    updateAccountKeyRequest?: UpdateAccountKeyRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject40
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject41
 */
export interface InlineObject41 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject41
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateUserWalletRequest}
     * @memberof InlineObject41
     */
    request?: CreateUserWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject42
 */
export interface InlineObject42 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject42
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequest}
     * @memberof InlineObject42
     */
    request?: ChangeWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject43
 */
export interface InlineObject43 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject43
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMultiSigTransactionRequestV1}
     * @memberof InlineObject43
     */
    request?: CreateMultiSigTransactionRequestV1;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject43
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject44
 */
export interface InlineObject44 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject44
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateBatchTransactionRequest}
     * @memberof InlineObject44
     */
    request?: CreateBatchTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject44
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject45
 */
export interface InlineObject45 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject45
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequestV1}
     * @memberof InlineObject45
     */
    request?: RetryCreateWalletRequestV1;
}
/**
 * 
 * @export
 * @interface InlineObject46
 */
export interface InlineObject46 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject46
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequestV1}
     * @memberof InlineObject46
     */
    request?: RetryCreateWalletRequestV1;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject5
     */
    identity?: Identity;
    /**
     * 
     * @type {ChangeWalletNameRequest}
     * @memberof InlineObject5
     */
    request?: ChangeWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject6
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateMultiSigTransactionRequest}
     * @memberof InlineObject6
     */
    request?: CreateMultiSigTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject6
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject7
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateBatchTransactionRequest}
     * @memberof InlineObject7
     */
    request?: CreateBatchTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject7
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject8
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequest}
     * @memberof InlineObject8
     */
    request?: RetryCreateWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject9
     */
    identity?: Identity;
    /**
     * 
     * @type {RetryCreateWalletRequest}
     * @memberof InlineObject9
     */
    request?: RetryCreateWalletRequest;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof MasterWalletDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {WalletStatus}
     * @memberof MasterWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MasterWalletDTO
     */
    whitelistActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface MethodGasUsageDTO
 */
export interface MethodGasUsageDTO {
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof MethodGasUsageDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MethodGasUsageDTO
     */
    estimatedGasConsumption: string;
}
/**
 * 
 * @export
 * @interface MultiSigPayloadDTO
 */
export interface MultiSigPayloadDTO {
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    walletNonce: string;
    /**
     * 
     * @type {string}
     * @memberof MultiSigPayloadDTO
     */
    hexData: string;
}
/**
 * 
 * @export
 * @interface NonceDTO
 */
export interface NonceDTO {
    /**
     * 
     * @type {string}
     * @memberof NonceDTO
     */
    nonce: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationCallEventDTO
 */
export interface PaginationCallEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationCallEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<CallEventDTO>}
     * @memberof PaginationCallEventDTO
     */
    results: Array<CallEventDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransactionDTO
 */
export interface PaginationTransactionDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransactionDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransactionDTO>}
     * @memberof PaginationTransactionDTO
     */
    results: Array<TransactionDTO>;
}
/**
 * 
 * @export
 * @interface PaginationUserWalletDTO
 */
export interface PaginationUserWalletDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationUserWalletDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<UserWalletDTO>}
     * @memberof PaginationUserWalletDTO
     */
    results: Array<UserWalletDTO>;
}
/**
 * 
 * @export
 * @interface PaginationValueTransferEventDTO
 */
export interface PaginationValueTransferEventDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationValueTransferEventDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<ValueTransferEventDTO>}
     * @memberof PaginationValueTransferEventDTO
     */
    results: Array<ValueTransferEventDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}
/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasPrice: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasLimit: string;
}
/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface RetryCreateWalletRequest
 */
export interface RetryCreateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequest
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface RetryCreateWalletRequestV1
 */
export interface RetryCreateWalletRequestV1 {
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequestV1
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryCreateWalletRequestV1
     */
    gasPrice?: string;
}
/**
 * 
 * @export
 * @interface SignedMultiSigPayloadDTO
 */
export interface SignedMultiSigPayloadDTO {
    /**
     * 
     * @type {string}
     * @memberof SignedMultiSigPayloadDTO
     */
    signature: string;
    /**
     * 
     * @type {MultiSigPayloadDTO}
     * @memberof SignedMultiSigPayloadDTO
     */
    multiSigPayload: MultiSigPayloadDTO;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof TransactionDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    sender: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    error?: string;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof TransactionDTO
     */
    status: TransactionStatus;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    keyId: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {SignedMultiSigPayloadDTO}
     * @memberof TransactionDTO
     */
    signedMultiSigPayload: SignedMultiSigPayloadDTO;
    /**
     * 
     * @type {RawTransactionDTO}
     * @memberof TransactionDTO
     */
    rawTransaction: RawTransactionDTO;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransactionStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    MINED = 'MINED',
    REVERTED = 'REVERTED',
    CONFIRMED = 'CONFIRMED',
    REPLACED = 'REPLACED'
}

/**
 * 
 * @export
 * @interface UpdateAccountKeyRequest
 */
export interface UpdateAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface UpdateCoinRequest
 */
export interface UpdateCoinRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCoinRequest
     */
    desc: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCoinRequest
     */
    flag: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCoinRequest
     */
    attributes: Array<UpdateCoinRequestAttributesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateCoinRequestAttributesEnum {
    STANDARD = 'ERC20_STANDARD',
    NONSTANDARDRETURNTYPE = 'ERC20_NON_STANDARD_RETURN_TYPE'
}

/**
 * 
 * @export
 * @interface UserWalletDTO
 */
export interface UserWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    blockchain: UserWalletDTOBlockchainEnum;
    /**
     * 
     * @type {WalletStatus}
     * @memberof UserWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletDTO
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWalletDTOBlockchainEnum {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressRequest
 */
export interface ValidateIsAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateIsAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {number}
     * @memberof ValidateIsAllowedAddressRequest
     */
    coinId: number;
}
/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressResponse
 */
export interface ValidateIsAllowedAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateIsAllowedAddressResponse
     */
    isValid: boolean;
}
/**
 * 
 * @export
 * @interface ValueTransferEventDTO
 */
export interface ValueTransferEventDTO {
    /**
     * 
     * @type {number}
     * @memberof ValueTransferEventDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockchain: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof ValueTransferEventDTO
     */
    status: EventStatus;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    masterWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {ValueTransferType}
     * @memberof ValueTransferEventDTO
     */
    transferType: ValueTransferType;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    blockHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ValueTransferEventDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ValueTransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    ACTIVE = 'ACTIVE',
    CREATING = 'CREATING',
    FAILED = 'FAILED'
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {WalletWithdrawalPolicyWalletType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletType: WalletWithdrawalPolicyWalletType;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletWithdrawalPolicyWalletType {
    MASTERWALLET = 'MASTER_WALLET',
    USERWALLET = 'USER_WALLET'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WhitelistType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalPolicyType {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}


/**
 * CoinControllerApi - axios parameter creator
 * @export
 */
export const CoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin2: async (symbol: string, blockchain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin2.');
            }
            // verify required parameter 'blockchain' is not null or undefined
            if (blockchain === null || blockchain === undefined) {
                throw new RequiredError('blockchain','Required parameter blockchain was null or undefined when calling getCoin2.');
            }
            const localVarPath = `/api/v1/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinControllerApi - functional programming interface
 * @export
 */
export const CoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await CoinControllerApiAxiosParamCreator(configuration).getAllCoins(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin2(symbol: string, blockchain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await CoinControllerApiAxiosParamCreator(configuration).getCoin2(symbol, blockchain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CoinControllerApi - factory interface
 * @export
 */
export const CoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins(options?: any): AxiosPromise<Array<CoinDTO>> {
            return CoinControllerApiFp(configuration).getAllCoins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} blockchain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin2(symbol: string, blockchain: string, options?: any): AxiosPromise<CoinDTO> {
            return CoinControllerApiFp(configuration).getCoin2(symbol, blockchain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinControllerApi - object-oriented interface
 * @export
 * @class CoinControllerApi
 * @extends {BaseAPI}
 */
export class CoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getAllCoins(options?: any) {
        return CoinControllerApiFp(this.configuration).getAllCoins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {string} blockchain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinControllerApi
     */
    public getCoin2(symbol: string, blockchain: string, options?: any) {
        return CoinControllerApiFp(this.configuration).getCoin2(symbol, blockchain, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthCoinControllerApi - axios parameter creator
 * @export
 */
export const EthCoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin: async (createCoinRequest: CreateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoinRequest' is not null or undefined
            if (createCoinRequest === null || createCoinRequest === undefined) {
                throw new RequiredError('createCoinRequest','Required parameter createCoinRequest was null or undefined when calling createCoin.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCoinRequest !== undefined ? createCoinRequest : {}) : (createCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoin.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins1: async (flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getAllCoins1.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin.');
            }
            const localVarPath = `/api/v2/eth/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin: async (updateCoinRequest: UpdateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCoinRequest' is not null or undefined
            if (updateCoinRequest === null || updateCoinRequest === undefined) {
                throw new RequiredError('updateCoinRequest','Required parameter updateCoinRequest was null or undefined when calling patchCoin.');
            }
            const localVarPath = `/api/v2/eth/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateCoinRequest !== undefined ? updateCoinRequest : {}) : (updateCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthCoinControllerApi - functional programming interface
 * @export
 */
export const EthCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoin(createCoinRequest: CreateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).createCoin(createCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoin(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).deleteCoin(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins1(flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).getAllCoins1(flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).getCoin(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthCoinControllerApiAxiosParamCreator(configuration).patchCoin(updateCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthCoinControllerApi - factory interface
 * @export
 */
export const EthCoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin(createCoinRequest: CreateCoinRequest, options?: any): AxiosPromise<CoinDTO> {
            return EthCoinControllerApiFp(configuration).createCoin(createCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin(symbol: string, options?: any): AxiosPromise<void> {
            return EthCoinControllerApiFp(configuration).deleteCoin(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins1(flag: boolean, options?: any): AxiosPromise<Array<CoinDTO>> {
            return EthCoinControllerApiFp(configuration).getAllCoins1(flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin(symbol: string, options?: any): AxiosPromise<CoinDTO> {
            return EthCoinControllerApiFp(configuration).getCoin(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any): AxiosPromise<void> {
            return EthCoinControllerApiFp(configuration).patchCoin(updateCoinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthCoinControllerApi - object-oriented interface
 * @export
 * @class EthCoinControllerApi
 * @extends {BaseAPI}
 */
export class EthCoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCoinRequest} createCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public createCoin(createCoinRequest: CreateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).createCoin(createCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public deleteCoin(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).deleteCoin(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getAllCoins1(flag: boolean, options?: any) {
        return EthCoinControllerApiFp(this.configuration).getAllCoins1(flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public getCoin(symbol: string, options?: any) {
        return EthCoinControllerApiFp(this.configuration).getCoin(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCoinRequest} updateCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthCoinControllerApi
     */
    public patchCoin(updateCoinRequest: UpdateCoinRequest, options?: any) {
        return EthCoinControllerApiFp(this.configuration).patchCoin(updateCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthEventControllerApi - axios parameter creator
 * @export
 */
export const EthEventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents.');
            }
            const localVarPath = `/api/v2/eth/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents.');
            }
            const localVarPath = `/api/v2/eth/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthEventControllerApi - functional programming interface
 * @export
 */
export const EthEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await EthEventControllerApiAxiosParamCreator(configuration).getCallEvents(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await EthEventControllerApiAxiosParamCreator(configuration).getValueTransferEvents(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthEventControllerApi - factory interface
 * @export
 */
export const EthEventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents(pageable: Pageable, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return EthEventControllerApiFp(configuration).getCallEvents(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents(pageable: Pageable, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return EthEventControllerApiFp(configuration).getValueTransferEvents(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthEventControllerApi - object-oriented interface
 * @export
 * @class EthEventControllerApi
 * @extends {BaseAPI}
 */
export class EthEventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getCallEvents(pageable: Pageable, options?: any) {
        return EthEventControllerApiFp(this.configuration).getCallEvents(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthEventControllerApi
     */
    public getValueTransferEvents(pageable: Pageable, options?: any) {
        return EthEventControllerApiFp(this.configuration).getValueTransferEvents(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthHenesisKeyControllerApi - axios parameter creator
 * @export
 */
export const EthHenesisKeyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getHenesisKey.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getHenesisKeyBalance.');
            }
            const localVarPath = `/api/v2/eth/henesis-keys/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const EthHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).createHenesisKey(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).createTransaction(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKey(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKey(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKeyBalance(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyBalanceDTO>> {
            const localVarAxiosArgs = await EthHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKeyBalance(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthHenesisKeyControllerApi - factory interface
 * @export
 */
export const EthHenesisKeyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return EthHenesisKeyControllerApiFp(configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(inlineObject: InlineObject, options?: any): AxiosPromise<TransactionDTO> {
            return EthHenesisKeyControllerApiFp(configuration).createTransaction(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey(identity: Identity, options?: any): AxiosPromise<KeyDTO> {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKey(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance(identity: Identity, options?: any): AxiosPromise<HenesisKeyBalanceDTO> {
            return EthHenesisKeyControllerApiFp(configuration).getHenesisKeyBalance(identity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class EthHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class EthHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public createTransaction(inlineObject: InlineObject, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).createTransaction(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKey(identity: Identity, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKey(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthHenesisKeyControllerApi
     */
    public getHenesisKeyBalance(identity: Identity, options?: any) {
        return EthHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalance(identity, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthMethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const EthMethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsages.');
            }
            const localVarPath = `/api/v2/eth/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const EthMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await EthMethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthMethodGasUsageControllerApi - factory interface
 * @export
 */
export const EthMethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages(name: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return EthMethodGasUsageControllerApiFp(configuration).getMethodGasUsages(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class EthMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class EthMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthMethodGasUsageControllerApi
     */
    public getMethodGasUsages(name: string, options?: any) {
        return EthMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthTransactionControllerApi - axios parameter creator
 * @export
 */
export const EthTransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (identity: Identity, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllTransactions.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions.');
            }
            const localVarPath = `/api/v2/eth/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (identity: Identity, transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getTransactionById.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById.');
            }
            const localVarPath = `/api/v2/eth/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthTransactionControllerApi - functional programming interface
 * @export
 */
export const EthTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(identity: Identity, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await EthTransactionControllerApiAxiosParamCreator(configuration).getAllTransactions(identity, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(identity: Identity, transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthTransactionControllerApiAxiosParamCreator(configuration).getTransactionById(identity, transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthTransactionControllerApi - factory interface
 * @export
 */
export const EthTransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(identity: Identity, pageable: Pageable, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return EthTransactionControllerApiFp(configuration).getAllTransactions(identity, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(identity: Identity, transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return EthTransactionControllerApiFp(configuration).getTransactionById(identity, transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthTransactionControllerApi - object-oriented interface
 * @export
 * @class EthTransactionControllerApi
 * @extends {BaseAPI}
 */
export class EthTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getAllTransactions(identity: Identity, pageable: Pageable, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getAllTransactions(identity, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthTransactionControllerApi
     */
    public getTransactionById(identity: Identity, transactionId: string, options?: any) {
        return EthTransactionControllerApiFp(this.configuration).getTransactionById(identity, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthWalletControllerApi - axios parameter creator
 * @export
 */
export const EthWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses: async (walletId: string, inlineObject14: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses.');
            }
            // verify required parameter 'inlineObject14' is not null or undefined
            if (inlineObject14 === null || inlineObject14 === undefined) {
                throw new RequiredError('inlineObject14','Required parameter inlineObject14 was null or undefined when calling activateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject14 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject14 !== undefined ? inlineObject14 : {}) : (inlineObject14 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress: async (walletId: string, inlineObject12: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress.');
            }
            // verify required parameter 'inlineObject12' is not null or undefined
            if (inlineObject12 === null || inlineObject12 === undefined) {
                throw new RequiredError('inlineObject12','Required parameter inlineObject12 was null or undefined when calling createAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject12 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject12 !== undefined ? inlineObject12 : {}) : (inlineObject12 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet: async (inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject1' is not null or undefined
            if (inlineObject1 === null || inlineObject1 === undefined) {
                throw new RequiredError('inlineObject1','Required parameter inlineObject1 was null or undefined when calling createMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet: async (walletId: string, inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet.');
            }
            // verify required parameter 'inlineObject4' is not null or undefined
            if (inlineObject4 === null || inlineObject4 === undefined) {
                throw new RequiredError('inlineObject4','Required parameter inlineObject4 was null or undefined when calling createUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject4 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {}) : (inlineObject4 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy: async (walletId: string, inlineObject10: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            // verify required parameter 'inlineObject10' is not null or undefined
            if (inlineObject10 === null || inlineObject10 === undefined) {
                throw new RequiredError('inlineObject10','Required parameter inlineObject10 was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject10 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject10 !== undefined ? inlineObject10 : {}) : (inlineObject10 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress: async (walletId: string, allowedAddressId: string, inlineObject13: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'inlineObject13' is not null or undefined
            if (inlineObject13 === null || inlineObject13 === undefined) {
                throw new RequiredError('inlineObject13','Required parameter inlineObject13 was null or undefined when calling deleteAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject13 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject13 !== undefined ? inlineObject13 : {}) : (inlineObject13 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllWalletWithdrawalPolicies.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPolicies.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllWalletWithdrawalPolicies.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress: async (identity: Identity, walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId1: async (identity: Identity, walletId: string, coinId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddressesByCoinId1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (walletId: string, identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletAccountKey.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance1: async (identity: Identity, walletId: string, flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletBalance1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance1.');
            }
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getMasterWalletBalance1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletInitialKey.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (identity: Identity, sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallets.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/eth/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet: async (identity: Identity, walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallet.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance1: async (identity: Identity, walletId: string, userWalletId: string, flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWalletBalance1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance1.');
            }
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getUserWalletBalance1.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallets.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses: async (walletId: string, inlineObject15: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses.');
            }
            // verify required parameter 'inlineObject15' is not null or undefined
            if (inlineObject15 === null || inlineObject15 === undefined) {
                throw new RequiredError('inlineObject15','Required parameter inlineObject15 was null or undefined when calling inactivateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject15 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject15 !== undefined ? inlineObject15 : {}) : (inlineObject15 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey: async (walletId: string, inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey.');
            }
            // verify required parameter 'inlineObject3' is not null or undefined
            if (inlineObject3 === null || inlineObject3 === undefined) {
                throw new RequiredError('inlineObject3','Required parameter inlineObject3 was null or undefined when calling patchAccountKey.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'inlineObject2' is not null or undefined
            if (inlineObject2 === null || inlineObject2 === undefined) {
                throw new RequiredError('inlineObject2','Required parameter inlineObject2 was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName: async (walletId: string, userWalletId: string, inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName.');
            }
            // verify required parameter 'inlineObject5' is not null or undefined
            if (inlineObject5 === null || inlineObject5 === undefined) {
                throw new RequiredError('inlineObject5','Required parameter inlineObject5 was null or undefined when calling patchUserWalletName.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject5 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject5 !== undefined ? inlineObject5 : {}) : (inlineObject5 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy: async (walletId: string, policyId: string, inlineObject11: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'inlineObject11' is not null or undefined
            if (inlineObject11 === null || inlineObject11 === undefined) {
                throw new RequiredError('inlineObject11','Required parameter inlineObject11 was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject11 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject11 !== undefined ? inlineObject11 : {}) : (inlineObject11 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet: async (walletId: string, inlineObject8: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet.');
            }
            // verify required parameter 'inlineObject8' is not null or undefined
            if (inlineObject8 === null || inlineObject8 === undefined) {
                throw new RequiredError('inlineObject8','Required parameter inlineObject8 was null or undefined when calling retryCreateMasterWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject8 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject8 !== undefined ? inlineObject8 : {}) : (inlineObject8 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet: async (walletId: string, userWalletId: string, inlineObject9: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet.');
            }
            // verify required parameter 'inlineObject9' is not null or undefined
            if (inlineObject9 === null || inlineObject9 === undefined) {
                throw new RequiredError('inlineObject9','Required parameter inlineObject9 was null or undefined when calling retryCreateUserWallet.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject9 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject9 !== undefined ? inlineObject9 : {}) : (inlineObject9 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction: async (inlineObject7: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject7' is not null or undefined
            if (inlineObject7 === null || inlineObject7 === undefined) {
                throw new RequiredError('inlineObject7','Required parameter inlineObject7 was null or undefined when calling sendBatchTransaction.');
            }
            const localVarPath = `/api/v2/eth/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject7 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject7 !== undefined ? inlineObject7 : {}) : (inlineObject7 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (inlineObject6: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject6' is not null or undefined
            if (inlineObject6 === null || inlineObject6 === undefined) {
                throw new RequiredError('inlineObject6','Required parameter inlineObject6 was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/eth/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject6 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject6 !== undefined ? inlineObject6 : {}) : (inlineObject6 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress: async (walletId: string, inlineObject16: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress.');
            }
            // verify required parameter 'inlineObject16' is not null or undefined
            if (inlineObject16 === null || inlineObject16 === undefined) {
                throw new RequiredError('inlineObject16','Required parameter inlineObject16 was null or undefined when calling validateIsAllowedAddress.');
            }
            const localVarPath = `/api/v2/eth/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject16 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject16 !== undefined ? inlineObject16 : {}) : (inlineObject16 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWalletControllerApi - functional programming interface
 * @export
 */
export const EthWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses(walletId, inlineObject14, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress(walletId: string, inlineObject12: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress(walletId, inlineObject12, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet(inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createMasterWallet(inlineObject1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet(walletId: string, inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createUserWallet(walletId, inlineObject4, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy(walletId: string, inlineObject10: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy(walletId, inlineObject10, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject13: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject13, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllWalletWithdrawalPolicies(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress(identity, walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddressesByCoinId1(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getAllowedAddressesByCoinId1(identity, walletId, coinId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(walletId: string, identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWallet(walletId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance1(identity: Identity, walletId: string, flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance1(identity, walletId, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(identity: Identity, sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getMasterWallets(identity, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet(identity: Identity, walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWallet(identity, walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance1(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance1(identity, walletId, userWalletId, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).getUserWallets(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses(walletId: string, inlineObject15: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses(walletId, inlineObject15, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchAccountKey(walletId, inlineObject3, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, inlineObject2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName(walletId: string, userWalletId: string, inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchUserWalletName(walletId, userWalletId, inlineObject5, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy(walletId: string, policyId: string, inlineObject11: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy(walletId, policyId, inlineObject11, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet(walletId: string, inlineObject8: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet(walletId, inlineObject8, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet(walletId: string, userWalletId: string, inlineObject9: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet(walletId, userWalletId, inlineObject9, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction(inlineObject7: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction(inlineObject7, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(inlineObject6: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).sendTransaction(inlineObject6, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress(walletId: string, inlineObject16: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await EthWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress(walletId, inlineObject16, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthWalletControllerApi - factory interface
 * @export
 */
export const EthWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).activateAllowedAddresses(walletId, inlineObject14, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress(walletId: string, inlineObject12: InlineObject12, options?: any): AxiosPromise<AllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).createAllowedAddress(walletId, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet(inlineObject1: InlineObject1, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).createMasterWallet(inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet(walletId: string, inlineObject4: InlineObject4, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).createUserWallet(walletId, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy(walletId: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).createWalletWithdrawalPolicy(walletId, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject13: InlineObject13, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).getAllWalletWithdrawalPolicies(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).getAllowedAddress(identity, walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId1(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return EthWalletControllerApiFp(configuration).getAllowedAddressesByCoinId1(identity, walletId, coinId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(walletId: string, identity: Identity, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWallet(walletId, identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletAccountKey(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance1(identity: Identity, walletId: string, flag: boolean, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return EthWalletControllerApiFp(configuration).getMasterWalletBalance1(identity, walletId, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletInitialKey(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return EthWalletControllerApiFp(configuration).getMasterWalletNonce(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(identity: Identity, sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return EthWalletControllerApiFp(configuration).getMasterWallets(identity, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet(identity: Identity, walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).getUserWallet(identity, walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance1(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return EthWalletControllerApiFp(configuration).getUserWalletBalance1(identity, walletId, userWalletId, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return EthWalletControllerApiFp(configuration).getUserWalletNonce(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return EthWalletControllerApiFp(configuration).getUserWallets(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses(walletId: string, inlineObject15: InlineObject15, options?: any): AxiosPromise<void> {
            return EthWalletControllerApiFp(configuration).inactivateAllowedAddresses(walletId, inlineObject15, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any): AxiosPromise<KeyDTO> {
            return EthWalletControllerApiFp(configuration).patchAccountKey(walletId, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, inlineObject2: InlineObject2, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).patchMasterWalletName(walletId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName(walletId: string, userWalletId: string, inlineObject5: InlineObject5, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).patchUserWalletName(walletId, userWalletId, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy(walletId: string, policyId: string, inlineObject11: InlineObject11, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return EthWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy(walletId, policyId, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet(walletId: string, inlineObject8: InlineObject8, options?: any): AxiosPromise<MasterWalletDTO> {
            return EthWalletControllerApiFp(configuration).retryCreateMasterWallet(walletId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet(walletId: string, userWalletId: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<UserWalletDTO> {
            return EthWalletControllerApiFp(configuration).retryCreateUserWallet(walletId, userWalletId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction(inlineObject7: InlineObject7, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return EthWalletControllerApiFp(configuration).sendBatchTransaction(inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(inlineObject6: InlineObject6, options?: any): AxiosPromise<TransactionDTO> {
            return EthWalletControllerApiFp(configuration).sendTransaction(inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject16} inlineObject16 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress(walletId: string, inlineObject16: InlineObject16, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return EthWalletControllerApiFp(configuration).validateIsAllowedAddress(walletId, inlineObject16, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthWalletControllerApi - object-oriented interface
 * @export
 * @class EthWalletControllerApi
 * @extends {BaseAPI}
 */
export class EthWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject14} inlineObject14 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public activateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any) {
        return EthWalletControllerApiFp(this.configuration).activateAllowedAddresses(walletId, inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createAllowedAddress(walletId: string, inlineObject12: InlineObject12, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createAllowedAddress(walletId, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createMasterWallet(inlineObject1: InlineObject1, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createMasterWallet(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createUserWallet(walletId: string, inlineObject4: InlineObject4, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createUserWallet(walletId, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public createWalletWithdrawalPolicy(walletId: string, inlineObject10: InlineObject10, options?: any) {
        return EthWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy(walletId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {InlineObject13} inlineObject13 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject13: InlineObject13, options?: any) {
        return EthWalletControllerApiFp(this.configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPolicies(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddress(identity, walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {number} coinId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getAllowedAddressesByCoinId1(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getAllowedAddressesByCoinId1(identity, walletId, coinId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWallet(walletId: string, identity: Identity, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWallet(walletId, identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletAccountKey(identity: Identity, walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletAccountKey(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletBalance1(identity: Identity, walletId: string, flag: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletBalance1(identity, walletId, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletInitialKey(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWalletNonce(walletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWalletNonce(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getMasterWallets(identity: Identity, sort: Sort, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getMasterWallets(identity, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWallet(identity: Identity, walletId: string, userWalletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWallet(identity, walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletBalance1(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletBalance1(identity, walletId, userWalletId, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWalletNonce(walletId: string, userWalletId: string, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWalletNonce(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public getUserWallets(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return EthWalletControllerApiFp(this.configuration).getUserWallets(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject15} inlineObject15 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public inactivateAllowedAddresses(walletId: string, inlineObject15: InlineObject15, options?: any) {
        return EthWalletControllerApiFp(this.configuration).inactivateAllowedAddresses(walletId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchAccountKey(walletId, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchMasterWalletName(walletId: string, inlineObject2: InlineObject2, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchUserWalletName(walletId: string, userWalletId: string, inlineObject5: InlineObject5, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchUserWalletName(walletId, userWalletId, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} policyId 
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public patchWalletWithdrawalPolicy(walletId: string, policyId: string, inlineObject11: InlineObject11, options?: any) {
        return EthWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy(walletId, policyId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateMasterWallet(walletId: string, inlineObject8: InlineObject8, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateMasterWallet(walletId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public retryCreateUserWallet(walletId: string, userWalletId: string, inlineObject9: InlineObject9, options?: any) {
        return EthWalletControllerApiFp(this.configuration).retryCreateUserWallet(walletId, userWalletId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject7} inlineObject7 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendBatchTransaction(inlineObject7: InlineObject7, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendBatchTransaction(inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public sendTransaction(inlineObject6: InlineObject6, options?: any) {
        return EthWalletControllerApiFp(this.configuration).sendTransaction(inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject16} inlineObject16 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWalletControllerApi
     */
    public validateIsAllowedAddress(walletId: string, inlineObject16: InlineObject16, options?: any) {
        return EthWalletControllerApiFp(this.configuration).validateIsAllowedAddress(walletId, inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EthWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const EthWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval: async (withdrawalApprovalId: string, inlineObject17: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval.');
            }
            // verify required parameter 'inlineObject17' is not null or undefined
            if (inlineObject17 === null || inlineObject17 === undefined) {
                throw new RequiredError('inlineObject17','Required parameter inlineObject17 was null or undefined when calling approveWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval: async (withdrawalApprovalId: string, inlineObject18: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval.');
            }
            // verify required parameter 'inlineObject18' is not null or undefined
            if (inlineObject18 === null || inlineObject18 === undefined) {
                throw new RequiredError('inlineObject18','Required parameter inlineObject18 was null or undefined when calling rejectWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/eth/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject17: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await EthWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject17, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject18: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EthWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject18, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EthWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const EthWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject17: InlineObject17, options?: any): AxiosPromise<TransactionDTO> {
            return EthWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject18: InlineObject18, options?: any): AxiosPromise<void> {
            return EthWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject18, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class EthWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class EthWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject17} inlineObject17 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject17: InlineObject17, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject18} inlineObject18 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject18: InlineObject18, options?: any) {
        return EthWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * EventControllerApi - axios parameter creator
 * @export
 */
export const EventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents2: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents2.');
            }
            const localVarPath = `/api/v1/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents2: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents2.');
            }
            const localVarPath = `/api/v1/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventControllerApi - functional programming interface
 * @export
 */
export const EventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents2(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await EventControllerApiAxiosParamCreator(configuration).getCallEvents2(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents2(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await EventControllerApiAxiosParamCreator(configuration).getValueTransferEvents2(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventControllerApi - factory interface
 * @export
 */
export const EventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents2(pageable: Pageable, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return EventControllerApiFp(configuration).getCallEvents2(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents2(pageable: Pageable, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return EventControllerApiFp(configuration).getValueTransferEvents2(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventControllerApi - object-oriented interface
 * @export
 * @class EventControllerApi
 * @extends {BaseAPI}
 */
export class EventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getCallEvents2(pageable: Pageable, options?: any) {
        return EventControllerApiFp(this.configuration).getCallEvents2(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public getValueTransferEvents2(pageable: Pageable, options?: any) {
        return EventControllerApiFp(this.configuration).getValueTransferEvents2(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayCoinControllerApi - axios parameter creator
 * @export
 */
export const KlayCoinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin1: async (createCoinRequest: CreateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoinRequest' is not null or undefined
            if (createCoinRequest === null || createCoinRequest === undefined) {
                throw new RequiredError('createCoinRequest','Required parameter createCoinRequest was null or undefined when calling createCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCoinRequest !== undefined ? createCoinRequest : {}) : (createCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin1: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling deleteCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins2: async (flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getAllCoins2.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin1: async (updateCoinRequest: UpdateCoinRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCoinRequest' is not null or undefined
            if (updateCoinRequest === null || updateCoinRequest === undefined) {
                throw new RequiredError('updateCoinRequest','Required parameter updateCoinRequest was null or undefined when calling patchCoin1.');
            }
            const localVarPath = `/api/v2/klay/coins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateCoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateCoinRequest !== undefined ? updateCoinRequest : {}) : (updateCoinRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayCoinControllerApi - functional programming interface
 * @export
 */
export const KlayCoinControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoin1(createCoinRequest: CreateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).createCoin1(createCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoin1(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).deleteCoin1(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCoins2(flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoinDTO>>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).getAllCoins2(flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoin1(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinDTO>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).getCoin1(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayCoinControllerApiAxiosParamCreator(configuration).patchCoin1(updateCoinRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayCoinControllerApi - factory interface
 * @export
 */
export const KlayCoinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateCoinRequest} createCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoin1(createCoinRequest: CreateCoinRequest, options?: any): AxiosPromise<CoinDTO> {
            return KlayCoinControllerApiFp(configuration).createCoin1(createCoinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoin1(symbol: string, options?: any): AxiosPromise<void> {
            return KlayCoinControllerApiFp(configuration).deleteCoin1(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCoins2(flag: boolean, options?: any): AxiosPromise<Array<CoinDTO>> {
            return KlayCoinControllerApiFp(configuration).getAllCoins2(flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoin1(symbol: string, options?: any): AxiosPromise<CoinDTO> {
            return KlayCoinControllerApiFp(configuration).getCoin1(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateCoinRequest} updateCoinRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any): AxiosPromise<void> {
            return KlayCoinControllerApiFp(configuration).patchCoin1(updateCoinRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayCoinControllerApi - object-oriented interface
 * @export
 * @class KlayCoinControllerApi
 * @extends {BaseAPI}
 */
export class KlayCoinControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateCoinRequest} createCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public createCoin1(createCoinRequest: CreateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).createCoin1(createCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public deleteCoin1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).deleteCoin1(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getAllCoins2(flag: boolean, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getAllCoins2(flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public getCoin1(symbol: string, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).getCoin1(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateCoinRequest} updateCoinRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayCoinControllerApi
     */
    public patchCoin1(updateCoinRequest: UpdateCoinRequest, options?: any) {
        return KlayCoinControllerApiFp(this.configuration).patchCoin1(updateCoinRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayEventControllerApi - axios parameter creator
 * @export
 */
export const KlayEventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getCallEvents1.');
            }
            const localVarPath = `/api/v2/klay/call-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getValueTransferEvents1.');
            }
            const localVarPath = `/api/v2/klay/value-transfer-events`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayEventControllerApi - functional programming interface
 * @export
 */
export const KlayEventControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCallEvents1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationCallEventDTO>> {
            const localVarAxiosArgs = await KlayEventControllerApiAxiosParamCreator(configuration).getCallEvents1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValueTransferEvents1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationValueTransferEventDTO>> {
            const localVarAxiosArgs = await KlayEventControllerApiAxiosParamCreator(configuration).getValueTransferEvents1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayEventControllerApi - factory interface
 * @export
 */
export const KlayEventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallEvents1(pageable: Pageable, options?: any): AxiosPromise<PaginationCallEventDTO> {
            return KlayEventControllerApiFp(configuration).getCallEvents1(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueTransferEvents1(pageable: Pageable, options?: any): AxiosPromise<PaginationValueTransferEventDTO> {
            return KlayEventControllerApiFp(configuration).getValueTransferEvents1(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayEventControllerApi - object-oriented interface
 * @export
 * @class KlayEventControllerApi
 * @extends {BaseAPI}
 */
export class KlayEventControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getCallEvents1(pageable: Pageable, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getCallEvents1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayEventControllerApi
     */
    public getValueTransferEvents1(pageable: Pageable, options?: any) {
        return KlayEventControllerApiFp(this.configuration).getValueTransferEvents1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayHenesisKeyControllerApi - axios parameter creator
 * @export
 */
export const KlayHenesisKeyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey1: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject35} inlineObject35 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction1: async (inlineObject35: InlineObject35, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject35' is not null or undefined
            if (inlineObject35 === null || inlineObject35 === undefined) {
                throw new RequiredError('inlineObject35','Required parameter inlineObject35 was null or undefined when calling createTransaction1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject35 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject35 !== undefined ? inlineObject35 : {}) : (inlineObject35 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey1: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getHenesisKey1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance1: async (identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getHenesisKeyBalance1.');
            }
            const localVarPath = `/api/v2/klay/henesis-keys/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - functional programming interface
 * @export
 */
export const KlayHenesisKeyControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).createHenesisKey1(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject35} inlineObject35 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction1(inlineObject35: InlineObject35, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).createTransaction1(inlineObject35, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKey1(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKey1(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHenesisKeyBalance1(identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyBalanceDTO>> {
            const localVarAxiosArgs = await KlayHenesisKeyControllerApiAxiosParamCreator(configuration).getHenesisKeyBalance1(identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayHenesisKeyControllerApi - factory interface
 * @export
 */
export const KlayHenesisKeyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).createHenesisKey1(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject35} inlineObject35 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction1(inlineObject35: InlineObject35, options?: any): AxiosPromise<TransactionDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).createTransaction1(inlineObject35, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKey1(identity: Identity, options?: any): AxiosPromise<KeyDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKey1(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHenesisKeyBalance1(identity: Identity, options?: any): AxiosPromise<HenesisKeyBalanceDTO> {
            return KlayHenesisKeyControllerApiFp(configuration).getHenesisKeyBalance1(identity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayHenesisKeyControllerApi - object-oriented interface
 * @export
 * @class KlayHenesisKeyControllerApi
 * @extends {BaseAPI}
 */
export class KlayHenesisKeyControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createHenesisKey1(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createHenesisKey1(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject35} inlineObject35 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public createTransaction1(inlineObject35: InlineObject35, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).createTransaction1(inlineObject35, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKey1(identity: Identity, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKey1(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayHenesisKeyControllerApi
     */
    public getHenesisKeyBalance1(identity: Identity, options?: any) {
        return KlayHenesisKeyControllerApiFp(this.configuration).getHenesisKeyBalance1(identity, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayMethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const KlayMethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages1: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMethodGasUsages1.');
            }
            const localVarPath = `/api/v2/klay/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages1(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await KlayMethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages1(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayMethodGasUsageControllerApi - factory interface
 * @export
 */
export const KlayMethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages1(name: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return KlayMethodGasUsageControllerApiFp(configuration).getMethodGasUsages1(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayMethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class KlayMethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class KlayMethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayMethodGasUsageControllerApi
     */
    public getMethodGasUsages1(name: string, options?: any) {
        return KlayMethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages1(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayTransactionControllerApi - axios parameter creator
 * @export
 */
export const KlayTransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions1: async (identity: Identity, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllTransactions1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions1.');
            }
            const localVarPath = `/api/v2/klay/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById1: async (identity: Identity, transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getTransactionById1.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById1.');
            }
            const localVarPath = `/api/v2/klay/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - functional programming interface
 * @export
 */
export const KlayTransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions1(identity: Identity, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await KlayTransactionControllerApiAxiosParamCreator(configuration).getAllTransactions1(identity, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById1(identity: Identity, transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayTransactionControllerApiAxiosParamCreator(configuration).getTransactionById1(identity, transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayTransactionControllerApi - factory interface
 * @export
 */
export const KlayTransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions1(identity: Identity, pageable: Pageable, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return KlayTransactionControllerApiFp(configuration).getAllTransactions1(identity, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById1(identity: Identity, transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return KlayTransactionControllerApiFp(configuration).getTransactionById1(identity, transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayTransactionControllerApi - object-oriented interface
 * @export
 * @class KlayTransactionControllerApi
 * @extends {BaseAPI}
 */
export class KlayTransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getAllTransactions1(identity: Identity, pageable: Pageable, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getAllTransactions1(identity, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayTransactionControllerApi
     */
    public getTransactionById1(identity: Identity, transactionId: string, options?: any) {
        return KlayTransactionControllerApiFp(this.configuration).getTransactionById1(identity, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayWalletControllerApi - axios parameter creator
 * @export
 */
export const KlayWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject32} inlineObject32 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1: async (walletId: string, inlineObject32: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses1.');
            }
            // verify required parameter 'inlineObject32' is not null or undefined
            if (inlineObject32 === null || inlineObject32 === undefined) {
                throw new RequiredError('inlineObject32','Required parameter inlineObject32 was null or undefined when calling activateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject32 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject32 !== undefined ? inlineObject32 : {}) : (inlineObject32 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject30} inlineObject30 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1: async (walletId: string, inlineObject30: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress1.');
            }
            // verify required parameter 'inlineObject30' is not null or undefined
            if (inlineObject30 === null || inlineObject30 === undefined) {
                throw new RequiredError('inlineObject30','Required parameter inlineObject30 was null or undefined when calling createAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject30 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject30 !== undefined ? inlineObject30 : {}) : (inlineObject30 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1: async (inlineObject19: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject19' is not null or undefined
            if (inlineObject19 === null || inlineObject19 === undefined) {
                throw new RequiredError('inlineObject19','Required parameter inlineObject19 was null or undefined when calling createMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet1: async (walletId: string, inlineObject22: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet1.');
            }
            // verify required parameter 'inlineObject22' is not null or undefined
            if (inlineObject22 === null || inlineObject22 === undefined) {
                throw new RequiredError('inlineObject22','Required parameter inlineObject22 was null or undefined when calling createUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject28} inlineObject28 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1: async (walletId: string, inlineObject28: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'inlineObject28' is not null or undefined
            if (inlineObject28 === null || inlineObject28 === undefined) {
                throw new RequiredError('inlineObject28','Required parameter inlineObject28 was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject28 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject28 !== undefined ? inlineObject28 : {}) : (inlineObject28 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject31} inlineObject31 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1: async (walletId: string, allowedAddressId: string, inlineObject31: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'inlineObject31' is not null or undefined
            if (inlineObject31 === null || inlineObject31 === undefined) {
                throw new RequiredError('inlineObject31','Required parameter inlineObject31 was null or undefined when calling deleteAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject31 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject31 !== undefined ? inlineObject31 : {}) : (inlineObject31 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies1: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllWalletWithdrawalPolicies1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllWalletWithdrawalPolicies1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllWalletWithdrawalPolicies1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1: async (identity: Identity, walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddress1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId2: async (identity: Identity, walletId: string, coinId: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            // verify required parameter 'coinId' is not null or undefined
            if (coinId === null || coinId === undefined) {
                throw new RequiredError('coinId','Required parameter coinId was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddressesByCoinId2.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (coinId !== undefined) {
                localVarQueryParameter['coin_id'] = coinId;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1: async (walletId: string, identity: Identity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet1.');
            }
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey1: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletAccountKey1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance2: async (identity: Identity, walletId: string, flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletBalance2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance2.');
            }
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getMasterWalletBalance2.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletInitialKey1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1: async (identity: Identity, sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallets1.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets1.');
            }
            const localVarPath = `/api/v2/klay/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet1: async (identity: Identity, walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallet1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance2: async (identity: Identity, walletId: string, userWalletId: string, flag: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWalletBalance2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance2.');
            }
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling getUserWalletBalance2.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce1: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets1: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallets1.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject33} inlineObject33 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1: async (walletId: string, inlineObject33: InlineObject33, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses1.');
            }
            // verify required parameter 'inlineObject33' is not null or undefined
            if (inlineObject33 === null || inlineObject33 === undefined) {
                throw new RequiredError('inlineObject33','Required parameter inlineObject33 was null or undefined when calling inactivateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject33 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject33 !== undefined ? inlineObject33 : {}) : (inlineObject33 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey1: async (walletId: string, inlineObject21: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey1.');
            }
            // verify required parameter 'inlineObject21' is not null or undefined
            if (inlineObject21 === null || inlineObject21 === undefined) {
                throw new RequiredError('inlineObject21','Required parameter inlineObject21 was null or undefined when calling patchAccountKey1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1: async (walletId: string, inlineObject20: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName1.');
            }
            // verify required parameter 'inlineObject20' is not null or undefined
            if (inlineObject20 === null || inlineObject20 === undefined) {
                throw new RequiredError('inlineObject20','Required parameter inlineObject20 was null or undefined when calling patchMasterWalletName1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName1: async (walletId: string, userWalletId: string, inlineObject23: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName1.');
            }
            // verify required parameter 'inlineObject23' is not null or undefined
            if (inlineObject23 === null || inlineObject23 === undefined) {
                throw new RequiredError('inlineObject23','Required parameter inlineObject23 was null or undefined when calling patchUserWalletName1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject29} inlineObject29 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1: async (walletId: string, policyId: string, inlineObject29: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'inlineObject29' is not null or undefined
            if (inlineObject29 === null || inlineObject29 === undefined) {
                throw new RequiredError('inlineObject29','Required parameter inlineObject29 was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/withdrawal-policies/{policyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject29 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject29 !== undefined ? inlineObject29 : {}) : (inlineObject29 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject26} inlineObject26 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet1: async (walletId: string, inlineObject26: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet1.');
            }
            // verify required parameter 'inlineObject26' is not null or undefined
            if (inlineObject26 === null || inlineObject26 === undefined) {
                throw new RequiredError('inlineObject26','Required parameter inlineObject26 was null or undefined when calling retryCreateMasterWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject26 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject26 !== undefined ? inlineObject26 : {}) : (inlineObject26 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject27} inlineObject27 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet1: async (walletId: string, userWalletId: string, inlineObject27: InlineObject27, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet1.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet1.');
            }
            // verify required parameter 'inlineObject27' is not null or undefined
            if (inlineObject27 === null || inlineObject27 === undefined) {
                throw new RequiredError('inlineObject27','Required parameter inlineObject27 was null or undefined when calling retryCreateUserWallet1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject27 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject27 !== undefined ? inlineObject27 : {}) : (inlineObject27 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject25} inlineObject25 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction1: async (inlineObject25: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject25' is not null or undefined
            if (inlineObject25 === null || inlineObject25 === undefined) {
                throw new RequiredError('inlineObject25','Required parameter inlineObject25 was null or undefined when calling sendBatchTransaction1.');
            }
            const localVarPath = `/api/v2/klay/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject24} inlineObject24 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1: async (inlineObject24: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject24' is not null or undefined
            if (inlineObject24 === null || inlineObject24 === undefined) {
                throw new RequiredError('inlineObject24','Required parameter inlineObject24 was null or undefined when calling sendTransaction1.');
            }
            const localVarPath = `/api/v2/klay/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject34} inlineObject34 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1: async (walletId: string, inlineObject34: InlineObject34, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress1.');
            }
            // verify required parameter 'inlineObject34' is not null or undefined
            if (inlineObject34 === null || inlineObject34 === undefined) {
                throw new RequiredError('inlineObject34','Required parameter inlineObject34 was null or undefined when calling validateIsAllowedAddress1.');
            }
            const localVarPath = `/api/v2/klay/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject34 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject34 !== undefined ? inlineObject34 : {}) : (inlineObject34 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWalletControllerApi - functional programming interface
 * @export
 */
export const KlayWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject32} inlineObject32 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses1(walletId: string, inlineObject32: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses1(walletId, inlineObject32, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject30} inlineObject30 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress1(walletId: string, inlineObject30: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress1(walletId, inlineObject30, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet1(inlineObject19: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createMasterWallet1(inlineObject19, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet1(walletId: string, inlineObject22: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createUserWallet1(walletId, inlineObject22, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject28} inlineObject28 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy1(walletId: string, inlineObject28: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy1(walletId, inlineObject28, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject31} inlineObject31 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress1(walletId: string, allowedAddressId: string, inlineObject31: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress1(walletId, allowedAddressId, inlineObject31, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWalletWithdrawalPolicies1(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllWalletWithdrawalPolicies1(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress1(identity: Identity, walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress1(identity, walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddressesByCoinId2(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getAllowedAddressesByCoinId2(identity, walletId, coinId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet1(walletId: string, identity: Identity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWallet1(walletId, identity, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey1(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey1(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance2(identity: Identity, walletId: string, flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance2(identity, walletId, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey1(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey1(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets1(identity: Identity, sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getMasterWallets1(identity, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet1(identity: Identity, walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWallet1(identity, walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance2(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance2(identity, walletId, userWalletId, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce1(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce1(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets1(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).getUserWallets1(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject33} inlineObject33 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses1(walletId: string, inlineObject33: InlineObject33, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses1(walletId, inlineObject33, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey1(walletId: string, inlineObject21: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchAccountKey1(walletId, inlineObject21, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName1(walletId: string, inlineObject20: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName1(walletId, inlineObject20, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName1(walletId: string, userWalletId: string, inlineObject23: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchUserWalletName1(walletId, userWalletId, inlineObject23, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject29} inlineObject29 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy1(walletId: string, policyId: string, inlineObject29: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy1(walletId, policyId, inlineObject29, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject26} inlineObject26 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet1(walletId: string, inlineObject26: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet1(walletId, inlineObject26, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject27} inlineObject27 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet1(walletId: string, userWalletId: string, inlineObject27: InlineObject27, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet1(walletId, userWalletId, inlineObject27, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject25} inlineObject25 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction1(inlineObject25: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction1(inlineObject25, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject24} inlineObject24 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction1(inlineObject24: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).sendTransaction1(inlineObject24, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject34} inlineObject34 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress1(walletId: string, inlineObject34: InlineObject34, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await KlayWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress1(walletId, inlineObject34, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayWalletControllerApi - factory interface
 * @export
 */
export const KlayWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject32} inlineObject32 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1(walletId: string, inlineObject32: InlineObject32, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).activateAllowedAddresses1(walletId, inlineObject32, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject30} inlineObject30 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1(walletId: string, inlineObject30: InlineObject30, options?: any): AxiosPromise<AllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).createAllowedAddress1(walletId, inlineObject30, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject19} inlineObject19 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1(inlineObject19: InlineObject19, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).createMasterWallet1(inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet1(walletId: string, inlineObject22: InlineObject22, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).createUserWallet1(walletId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject28} inlineObject28 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1(walletId: string, inlineObject28: InlineObject28, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).createWalletWithdrawalPolicy1(walletId, inlineObject28, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject31} inlineObject31 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1(walletId: string, allowedAddressId: string, inlineObject31: InlineObject31, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).deleteAllowedAddress1(walletId, allowedAddressId, inlineObject31, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWalletWithdrawalPolicies1(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).getAllWalletWithdrawalPolicies1(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1(identity: Identity, walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).getAllowedAddress1(identity, walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {number} coinId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddressesByCoinId2(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return KlayWalletControllerApiFp(configuration).getAllowedAddressesByCoinId2(identity, walletId, coinId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Identity} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1(walletId: string, identity: Identity, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWallet1(walletId, identity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey1(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletAccountKey1(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance2(identity: Identity, walletId: string, flag: boolean, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletBalance2(identity, walletId, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletInitialKey1(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce1(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return KlayWalletControllerApiFp(configuration).getMasterWalletNonce1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1(identity: Identity, sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return KlayWalletControllerApiFp(configuration).getMasterWallets1(identity, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet1(identity: Identity, walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWallet1(identity, walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {boolean} flag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance2(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return KlayWalletControllerApiFp(configuration).getUserWalletBalance2(identity, walletId, userWalletId, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce1(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWalletNonce1(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets1(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).getUserWallets1(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject33} inlineObject33 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1(walletId: string, inlineObject33: InlineObject33, options?: any): AxiosPromise<void> {
            return KlayWalletControllerApiFp(configuration).inactivateAllowedAddresses1(walletId, inlineObject33, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject21} inlineObject21 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey1(walletId: string, inlineObject21: InlineObject21, options?: any): AxiosPromise<KeyDTO> {
            return KlayWalletControllerApiFp(configuration).patchAccountKey1(walletId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1(walletId: string, inlineObject20: InlineObject20, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).patchMasterWalletName1(walletId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName1(walletId: string, userWalletId: string, inlineObject23: InlineObject23, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).patchUserWalletName1(walletId, userWalletId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} policyId 
         * @param {InlineObject29} inlineObject29 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1(walletId: string, policyId: string, inlineObject29: InlineObject29, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return KlayWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy1(walletId, policyId, inlineObject29, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject26} inlineObject26 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet1(walletId: string, inlineObject26: InlineObject26, options?: any): AxiosPromise<MasterWalletDTO> {
            return KlayWalletControllerApiFp(configuration).retryCreateMasterWallet1(walletId, inlineObject26, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject27} inlineObject27 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet1(walletId: string, userWalletId: string, inlineObject27: InlineObject27, options?: any): AxiosPromise<UserWalletDTO> {
            return KlayWalletControllerApiFp(configuration).retryCreateUserWallet1(walletId, userWalletId, inlineObject27, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject25} inlineObject25 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction1(inlineObject25: InlineObject25, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return KlayWalletControllerApiFp(configuration).sendBatchTransaction1(inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject24} inlineObject24 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1(inlineObject24: InlineObject24, options?: any): AxiosPromise<TransactionDTO> {
            return KlayWalletControllerApiFp(configuration).sendTransaction1(inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject34} inlineObject34 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1(walletId: string, inlineObject34: InlineObject34, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return KlayWalletControllerApiFp(configuration).validateIsAllowedAddress1(walletId, inlineObject34, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayWalletControllerApi - object-oriented interface
 * @export
 * @class KlayWalletControllerApi
 * @extends {BaseAPI}
 */
export class KlayWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject32} inlineObject32 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public activateAllowedAddresses1(walletId: string, inlineObject32: InlineObject32, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).activateAllowedAddresses1(walletId, inlineObject32, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject30} inlineObject30 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createAllowedAddress1(walletId: string, inlineObject30: InlineObject30, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createAllowedAddress1(walletId, inlineObject30, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject19} inlineObject19 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createMasterWallet1(inlineObject19: InlineObject19, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createMasterWallet1(inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject22} inlineObject22 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createUserWallet1(walletId: string, inlineObject22: InlineObject22, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createUserWallet1(walletId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject28} inlineObject28 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public createWalletWithdrawalPolicy1(walletId: string, inlineObject28: InlineObject28, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy1(walletId, inlineObject28, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {InlineObject31} inlineObject31 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public deleteAllowedAddress1(walletId: string, allowedAddressId: string, inlineObject31: InlineObject31, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).deleteAllowedAddress1(walletId, allowedAddressId, inlineObject31, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllWalletWithdrawalPolicies1(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllWalletWithdrawalPolicies1(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddress1(identity: Identity, walletId: string, allowedAddressId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddress1(identity, walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {number} coinId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getAllowedAddressesByCoinId2(identity: Identity, walletId: string, coinId: number, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getAllowedAddressesByCoinId2(identity, walletId, coinId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Identity} identity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWallet1(walletId: string, identity: Identity, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWallet1(walletId, identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletAccountKey1(identity: Identity, walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletAccountKey1(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletBalance2(identity: Identity, walletId: string, flag: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletBalance2(identity, walletId, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletInitialKey1(identity: Identity, walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletInitialKey1(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWalletNonce1(walletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWalletNonce1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getMasterWallets1(identity: Identity, sort: Sort, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getMasterWallets1(identity, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWallet1(identity: Identity, walletId: string, userWalletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWallet1(identity, walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {boolean} flag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletBalance2(identity: Identity, walletId: string, userWalletId: string, flag: boolean, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletBalance2(identity, walletId, userWalletId, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWalletNonce1(walletId: string, userWalletId: string, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWalletNonce1(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public getUserWallets1(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).getUserWallets1(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject33} inlineObject33 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public inactivateAllowedAddresses1(walletId: string, inlineObject33: InlineObject33, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).inactivateAllowedAddresses1(walletId, inlineObject33, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject21} inlineObject21 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchAccountKey1(walletId: string, inlineObject21: InlineObject21, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchAccountKey1(walletId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject20} inlineObject20 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchMasterWalletName1(walletId: string, inlineObject20: InlineObject20, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchMasterWalletName1(walletId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject23} inlineObject23 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchUserWalletName1(walletId: string, userWalletId: string, inlineObject23: InlineObject23, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchUserWalletName1(walletId, userWalletId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} policyId 
     * @param {InlineObject29} inlineObject29 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public patchWalletWithdrawalPolicy1(walletId: string, policyId: string, inlineObject29: InlineObject29, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy1(walletId, policyId, inlineObject29, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject26} inlineObject26 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateMasterWallet1(walletId: string, inlineObject26: InlineObject26, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateMasterWallet1(walletId, inlineObject26, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject27} inlineObject27 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public retryCreateUserWallet1(walletId: string, userWalletId: string, inlineObject27: InlineObject27, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).retryCreateUserWallet1(walletId, userWalletId, inlineObject27, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject25} inlineObject25 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendBatchTransaction1(inlineObject25: InlineObject25, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendBatchTransaction1(inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject24} inlineObject24 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public sendTransaction1(inlineObject24: InlineObject24, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).sendTransaction1(inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject34} inlineObject34 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWalletControllerApi
     */
    public validateIsAllowedAddress1(walletId: string, inlineObject34: InlineObject34, options?: any) {
        return KlayWalletControllerApiFp(this.configuration).validateIsAllowedAddress1(walletId, inlineObject34, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * KlayWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const KlayWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject36} inlineObject36 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1: async (withdrawalApprovalId: string, inlineObject36: InlineObject36, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval1.');
            }
            // verify required parameter 'inlineObject36' is not null or undefined
            if (inlineObject36 === null || inlineObject36 === undefined) {
                throw new RequiredError('inlineObject36','Required parameter inlineObject36 was null or undefined when calling approveWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject36 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject36 !== undefined ? inlineObject36 : {}) : (inlineObject36 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject37} inlineObject37 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1: async (withdrawalApprovalId: string, inlineObject37: InlineObject37, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval1.');
            }
            // verify required parameter 'inlineObject37' is not null or undefined
            if (inlineObject37 === null || inlineObject37 === undefined) {
                throw new RequiredError('inlineObject37','Required parameter inlineObject37 was null or undefined when calling rejectWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/klay/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject37 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject37 !== undefined ? inlineObject37 : {}) : (inlineObject37 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject36} inlineObject36 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval1(withdrawalApprovalId: string, inlineObject36: InlineObject36, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await KlayWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval1(withdrawalApprovalId, inlineObject36, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject37} inlineObject37 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval1(withdrawalApprovalId: string, inlineObject37: InlineObject37, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KlayWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, inlineObject37, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KlayWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const KlayWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject36} inlineObject36 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1(withdrawalApprovalId: string, inlineObject36: InlineObject36, options?: any): AxiosPromise<TransactionDTO> {
            return KlayWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval1(withdrawalApprovalId, inlineObject36, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject37} inlineObject37 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1(withdrawalApprovalId: string, inlineObject37: InlineObject37, options?: any): AxiosPromise<void> {
            return KlayWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, inlineObject37, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KlayWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class KlayWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class KlayWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject36} inlineObject36 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval1(withdrawalApprovalId: string, inlineObject36: InlineObject36, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval1(withdrawalApprovalId, inlineObject36, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject37} inlineObject37 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KlayWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval1(withdrawalApprovalId: string, inlineObject37: InlineObject37, options?: any) {
        return KlayWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval1(withdrawalApprovalId, inlineObject37, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MethodGasUsageControllerApi - axios parameter creator
 * @export
 */
export const MethodGasUsageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages2: async (blockchain?: string, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/method-gas-usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MethodGasUsageControllerApi - functional programming interface
 * @export
 */
export const MethodGasUsageControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodGasUsages2(blockchain?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodGasUsageDTO>> {
            const localVarAxiosArgs = await MethodGasUsageControllerApiAxiosParamCreator(configuration).getMethodGasUsages2(blockchain, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MethodGasUsageControllerApi - factory interface
 * @export
 */
export const MethodGasUsageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [blockchain] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodGasUsages2(blockchain?: string, name?: string, options?: any): AxiosPromise<MethodGasUsageDTO> {
            return MethodGasUsageControllerApiFp(configuration).getMethodGasUsages2(blockchain, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MethodGasUsageControllerApi - object-oriented interface
 * @export
 * @class MethodGasUsageControllerApi
 * @extends {BaseAPI}
 */
export class MethodGasUsageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [blockchain] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodGasUsageControllerApi
     */
    public getMethodGasUsages2(blockchain?: string, name?: string, options?: any) {
        return MethodGasUsageControllerApiFp(this.configuration).getMethodGasUsages2(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransactionControllerApi - axios parameter creator
 * @export
 */
export const TransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions2: async (identity: Identity, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllTransactions2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllTransactions2.');
            }
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById2: async (identity: Identity, blockchain: string, transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getTransactionById2.');
            }
            // verify required parameter 'blockchain' is not null or undefined
            if (blockchain === null || blockchain === undefined) {
                throw new RequiredError('blockchain','Required parameter blockchain was null or undefined when calling getTransactionById2.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionById2.');
            }
            const localVarPath = `/api/v1/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionControllerApi - functional programming interface
 * @export
 */
export const TransactionControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions2(identity: Identity, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransactionDTO>> {
            const localVarAxiosArgs = await TransactionControllerApiAxiosParamCreator(configuration).getAllTransactions2(identity, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById2(identity: Identity, blockchain: string, transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await TransactionControllerApiAxiosParamCreator(configuration).getTransactionById2(identity, blockchain, transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransactionControllerApi - factory interface
 * @export
 */
export const TransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions2(identity: Identity, pageable: Pageable, options?: any): AxiosPromise<PaginationTransactionDTO> {
            return TransactionControllerApiFp(configuration).getAllTransactions2(identity, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} blockchain 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById2(identity: Identity, blockchain: string, transactionId: string, options?: any): AxiosPromise<TransactionDTO> {
            return TransactionControllerApiFp(configuration).getTransactionById2(identity, blockchain, transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionControllerApi - object-oriented interface
 * @export
 * @class TransactionControllerApi
 * @extends {BaseAPI}
 */
export class TransactionControllerApi extends BaseAPI {
    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionControllerApi
     */
    public getAllTransactions2(identity: Identity, pageable: Pageable, options?: any) {
        return TransactionControllerApiFp(this.configuration).getAllTransactions2(identity, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} blockchain 
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionControllerApi
     */
    public getTransactionById2(identity: Identity, blockchain: string, transactionId: string, options?: any) {
        return TransactionControllerApiFp(this.configuration).getTransactionById2(identity, blockchain, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject38} inlineObject38 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2: async (inlineObject38: InlineObject38, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject38' is not null or undefined
            if (inlineObject38 === null || inlineObject38 === undefined) {
                throw new RequiredError('inlineObject38','Required parameter inlineObject38 was null or undefined when calling createMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject38 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject38 !== undefined ? inlineObject38 : {}) : (inlineObject38 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject41} inlineObject41 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet2: async (walletId: string, inlineObject41: InlineObject41, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createUserWallet2.');
            }
            // verify required parameter 'inlineObject41' is not null or undefined
            if (inlineObject41 === null || inlineObject41 === undefined) {
                throw new RequiredError('inlineObject41','Required parameter inlineObject41 was null or undefined when calling createUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject41 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject41 !== undefined ? inlineObject41 : {}) : (inlineObject41 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallet2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey2: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletAccountKey2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletAccountKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletBalance.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletBalance.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletInitialKey2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletNonce2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2: async (identity: Identity, sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallets2.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets2.');
            }
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet2: async (identity: Identity, walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallet2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallet2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance: async (identity: Identity, walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWalletBalance.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletBalance.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletBalance.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce2: async (walletId: string, userWalletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWalletNonce2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling getUserWalletNonce2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/nonce`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets2: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getUserWallets2.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getUserWallets2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getUserWallets2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject40} inlineObject40 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey2: async (walletId: string, inlineObject40: InlineObject40, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchAccountKey2.');
            }
            // verify required parameter 'inlineObject40' is not null or undefined
            if (inlineObject40 === null || inlineObject40 === undefined) {
                throw new RequiredError('inlineObject40','Required parameter inlineObject40 was null or undefined when calling patchAccountKey2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject40 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject40 !== undefined ? inlineObject40 : {}) : (inlineObject40 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject39} inlineObject39 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2: async (walletId: string, inlineObject39: InlineObject39, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName2.');
            }
            // verify required parameter 'inlineObject39' is not null or undefined
            if (inlineObject39 === null || inlineObject39 === undefined) {
                throw new RequiredError('inlineObject39','Required parameter inlineObject39 was null or undefined when calling patchMasterWalletName2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject39 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject39 !== undefined ? inlineObject39 : {}) : (inlineObject39 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject42} inlineObject42 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName2: async (walletId: string, userWalletId: string, inlineObject42: InlineObject42, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchUserWalletName2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling patchUserWalletName2.');
            }
            // verify required parameter 'inlineObject42' is not null or undefined
            if (inlineObject42 === null || inlineObject42 === undefined) {
                throw new RequiredError('inlineObject42','Required parameter inlineObject42 was null or undefined when calling patchUserWalletName2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject42 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject42 !== undefined ? inlineObject42 : {}) : (inlineObject42 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject45} inlineObject45 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet2: async (walletId: string, inlineObject45: InlineObject45, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateMasterWallet2.');
            }
            // verify required parameter 'inlineObject45' is not null or undefined
            if (inlineObject45 === null || inlineObject45 === undefined) {
                throw new RequiredError('inlineObject45','Required parameter inlineObject45 was null or undefined when calling retryCreateMasterWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject45 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject45 !== undefined ? inlineObject45 : {}) : (inlineObject45 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject46} inlineObject46 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet2: async (walletId: string, userWalletId: string, inlineObject46: InlineObject46, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling retryCreateUserWallet2.');
            }
            // verify required parameter 'userWalletId' is not null or undefined
            if (userWalletId === null || userWalletId === undefined) {
                throw new RequiredError('userWalletId','Required parameter userWalletId was null or undefined when calling retryCreateUserWallet2.');
            }
            // verify required parameter 'inlineObject46' is not null or undefined
            if (inlineObject46 === null || inlineObject46 === undefined) {
                throw new RequiredError('inlineObject46','Required parameter inlineObject46 was null or undefined when calling retryCreateUserWallet2.');
            }
            const localVarPath = `/api/v1/wallets/{walletId}/user-wallets/{userWalletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"userWalletId"}}`, encodeURIComponent(String(userWalletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject46 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject46 !== undefined ? inlineObject46 : {}) : (inlineObject46 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject44} inlineObject44 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction2: async (inlineObject44: InlineObject44, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject44' is not null or undefined
            if (inlineObject44 === null || inlineObject44 === undefined) {
                throw new RequiredError('inlineObject44','Required parameter inlineObject44 was null or undefined when calling sendBatchTransaction2.');
            }
            const localVarPath = `/api/v1/wallets/batch-transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject44 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject44 !== undefined ? inlineObject44 : {}) : (inlineObject44 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject43} inlineObject43 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2: async (inlineObject43: InlineObject43, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject43' is not null or undefined
            if (inlineObject43 === null || inlineObject43 === undefined) {
                throw new RequiredError('inlineObject43','Required parameter inlineObject43 was null or undefined when calling sendTransaction2.');
            }
            const localVarPath = `/api/v1/wallets/transactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject43 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject43 !== undefined ? inlineObject43 : {}) : (inlineObject43 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject38} inlineObject38 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet2(inlineObject38: InlineObject38, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet2(inlineObject38, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject41} inlineObject41 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserWallet2(walletId: string, inlineObject41: InlineObject41, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createUserWallet2(walletId, inlineObject41, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet2(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet2(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletAccountKey2(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletAccountKey2(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletBalance(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletBalance(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey2(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey2(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletNonce2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletNonce2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets2(identity: Identity, sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets2(identity, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallet2(identity: Identity, walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWallet2(identity, walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalance(identity: Identity, walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWalletBalance(identity, walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletNonce2(walletId: string, userWalletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWalletNonce2(walletId, userWalletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets2(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationUserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getUserWallets2(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject40} inlineObject40 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountKey2(walletId: string, inlineObject40: InlineObject40, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchAccountKey2(walletId, inlineObject40, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject39} inlineObject39 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName2(walletId: string, inlineObject39: InlineObject39, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName2(walletId, inlineObject39, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject42} inlineObject42 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserWalletName2(walletId: string, userWalletId: string, inlineObject42: InlineObject42, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchUserWalletName2(walletId, userWalletId, inlineObject42, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject45} inlineObject45 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateMasterWallet2(walletId: string, inlineObject45: InlineObject45, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).retryCreateMasterWallet2(walletId, inlineObject45, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject46} inlineObject46 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryCreateUserWallet2(walletId: string, userWalletId: string, inlineObject46: InlineObject46, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).retryCreateUserWallet2(walletId, userWalletId, inlineObject46, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject44} inlineObject44 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendBatchTransaction2(inlineObject44: InlineObject44, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchTransactionDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendBatchTransaction2(inlineObject44, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject43} inlineObject43 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction2(inlineObject43: InlineObject43, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction2(inlineObject43, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {InlineObject38} inlineObject38 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2(inlineObject38: InlineObject38, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet2(inlineObject38, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject41} inlineObject41 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserWallet2(walletId: string, inlineObject41: InlineObject41, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).createUserWallet2(walletId, inlineObject41, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2(identity: Identity, walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet2(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletAccountKey2(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletAccountKey2(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletBalance(identity: Identity, walletId: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return WalletControllerApiFp(configuration).getMasterWalletBalance(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey2(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletNonce2(walletId: string, options?: any): AxiosPromise<NonceDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletNonce2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2(identity: Identity, sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets2(identity, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallet2(identity: Identity, walletId: string, userWalletId: string, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).getUserWallet2(identity, walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalance(identity: Identity, walletId: string, userWalletId: string, options?: any): AxiosPromise<Array<BalanceDTO>> {
            return WalletControllerApiFp(configuration).getUserWalletBalance(identity, walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletNonce2(walletId: string, userWalletId: string, options?: any): AxiosPromise<NonceDTO> {
            return WalletControllerApiFp(configuration).getUserWalletNonce2(walletId, userWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets2(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationUserWalletDTO> {
            return WalletControllerApiFp(configuration).getUserWallets2(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject40} inlineObject40 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountKey2(walletId: string, inlineObject40: InlineObject40, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchAccountKey2(walletId, inlineObject40, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject39} inlineObject39 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2(walletId: string, inlineObject39: InlineObject39, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName2(walletId, inlineObject39, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject42} inlineObject42 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserWalletName2(walletId: string, userWalletId: string, inlineObject42: InlineObject42, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).patchUserWalletName2(walletId, userWalletId, inlineObject42, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject45} inlineObject45 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateMasterWallet2(walletId: string, inlineObject45: InlineObject45, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).retryCreateMasterWallet2(walletId, inlineObject45, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} userWalletId 
         * @param {InlineObject46} inlineObject46 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryCreateUserWallet2(walletId: string, userWalletId: string, inlineObject46: InlineObject46, options?: any): AxiosPromise<UserWalletDTO> {
            return WalletControllerApiFp(configuration).retryCreateUserWallet2(walletId, userWalletId, inlineObject46, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject44} inlineObject44 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendBatchTransaction2(inlineObject44: InlineObject44, options?: any): AxiosPromise<Array<BatchTransactionDTO>> {
            return WalletControllerApiFp(configuration).sendBatchTransaction2(inlineObject44, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject43} inlineObject43 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2(inlineObject43: InlineObject43, options?: any): AxiosPromise<TransactionDTO> {
            return WalletControllerApiFp(configuration).sendTransaction2(inlineObject43, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {InlineObject38} inlineObject38 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet2(inlineObject38: InlineObject38, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet2(inlineObject38, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject41} inlineObject41 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createUserWallet2(walletId: string, inlineObject41: InlineObject41, options?: any) {
        return WalletControllerApiFp(this.configuration).createUserWallet2(walletId, inlineObject41, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet2(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet2(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletAccountKey2(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletAccountKey2(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletBalance(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletBalance(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey2(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey2(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletNonce2(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletNonce2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets2(identity: Identity, sort: Sort, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets2(identity, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWallet2(identity: Identity, walletId: string, userWalletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWallet2(identity, walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletBalance(identity: Identity, walletId: string, userWalletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWalletBalance(identity, walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWalletNonce2(walletId: string, userWalletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWalletNonce2(walletId, userWalletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getUserWallets2(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getUserWallets2(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject40} inlineObject40 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchAccountKey2(walletId: string, inlineObject40: InlineObject40, options?: any) {
        return WalletControllerApiFp(this.configuration).patchAccountKey2(walletId, inlineObject40, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject39} inlineObject39 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName2(walletId: string, inlineObject39: InlineObject39, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName2(walletId, inlineObject39, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject42} inlineObject42 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchUserWalletName2(walletId: string, userWalletId: string, inlineObject42: InlineObject42, options?: any) {
        return WalletControllerApiFp(this.configuration).patchUserWalletName2(walletId, userWalletId, inlineObject42, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject45} inlineObject45 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public retryCreateMasterWallet2(walletId: string, inlineObject45: InlineObject45, options?: any) {
        return WalletControllerApiFp(this.configuration).retryCreateMasterWallet2(walletId, inlineObject45, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} userWalletId 
     * @param {InlineObject46} inlineObject46 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public retryCreateUserWallet2(walletId: string, userWalletId: string, inlineObject46: InlineObject46, options?: any) {
        return WalletControllerApiFp(this.configuration).retryCreateUserWallet2(walletId, userWalletId, inlineObject46, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject44} inlineObject44 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendBatchTransaction2(inlineObject44: InlineObject44, options?: any) {
        return WalletControllerApiFp(this.configuration).sendBatchTransaction2(inlineObject44, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject43} inlineObject43 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction2(inlineObject43: InlineObject43, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction2(inlineObject43, options).then((request) => request(this.axios, this.basePath));
    }

}


