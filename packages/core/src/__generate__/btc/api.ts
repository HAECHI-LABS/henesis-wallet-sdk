// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateAllowedAddressesRequest
 */
export interface ActivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ActivateMasterWalletRequest
 */
export interface ActivateMasterWalletRequest {
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    backupKey: KeyDTO;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistedWalletId?: string;
    /**
     * 
     * @type {number}
     * @memberof AllowedAddressDTO
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof AllowedAddressDTO
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof AllowedAddressDTO
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AllowedCoinType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    to?: string;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    FILECOIN = 'FILECOIN',
    BINANCESMARTCHAIN = 'BINANCE_SMART_CHAIN',
    LITECOIN = 'LITECOIN',
    BITCOINCASH = 'BITCOIN_CASH'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CoinSymbol {
    ETH = 'ETH',
    KLAY = 'KLAY',
    BTC = 'BTC',
    FIL = 'FIL',
    BNB = 'BNB',
    LTC = 'LTC',
    BCH = 'BCH'
}

/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label?: string;
    /**
     * 
     * @type {WhitelistType}
     * @memberof CreateAllowedAddressRequest
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletRequest
 */
export interface CreateInactiveMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    encryptionKey: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletResponse
 */
export interface CreateInactiveMasterWalletResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateInactiveMasterWalletResponse
     */
    henesisKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    encryptionKey: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof CreateInactiveMasterWalletResponse
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface CreateRawTransactionRequest
 */
export interface CreateRawTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    feeRate?: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionInputDTO
 */
export interface CreateTransactionInputDTO {
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof CreateTransactionInputDTO
     */
    transactionOutput: TransactionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionInputDTO
     */
    accountSignature: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionOutputDTO
 */
export interface CreateTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof CreateTransactionRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof CreateTransactionRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    to?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DeleteAllowedAddressRequest
 */
export interface DeleteAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface EstimatedFeeDTO
 */
export interface EstimatedFeeDTO {
    /**
     * 
     * @type {string}
     * @memberof EstimatedFeeDTO
     */
    estimatedFee: string;
}
/**
 * 
 * @export
 * @interface InactivateAllowedAddressesRequest
 */
export interface InactivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof MasterWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {boolean}
     * @memberof MasterWalletDTO
     */
    whitelistActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationSimplifiedTransferDTO
 */
export interface PaginationSimplifiedTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationSimplifiedTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<SimplifiedTransferDTO>}
     * @memberof PaginationSimplifiedTransferDTO
     */
    results: Array<SimplifiedTransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferInternalDTO
 */
export interface PaginationTransferInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof PaginationTransferInternalDTO
     */
    results: Array<TransferInternalDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletDTO
 */
export interface PaginationWalletDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletDTO>}
     * @memberof PaginationWalletDTO
     */
    results: Array<WalletDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {Array<RawTransactionInputDTO>}
     * @memberof RawTransactionDTO
     */
    inputs: Array<RawTransactionInputDTO>;
    /**
     * 
     * @type {Array<RawTransactionOutputDTO>}
     * @memberof RawTransactionDTO
     */
    outputs: Array<RawTransactionOutputDTO>;
}
/**
 * 
 * @export
 * @interface RawTransactionInputDTO
 */
export interface RawTransactionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionInputDTO
     */
    redeemScript?: string;
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof RawTransactionInputDTO
     */
    transactionOutput?: TransactionOutputDTO;
}
/**
 * 
 * @export
 * @interface RawTransactionOutputDTO
 */
export interface RawTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof RawTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface SimplifiedTransferDTO
 */
export interface SimplifiedTransferDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    type?: SimplifiedTransferDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    status?: SimplifiedTransferDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    walletId?: string;
    /**
     * 
     * @type {Address}
     * @memberof SimplifiedTransferDTO
     */
    receivedAt?: Address;
    /**
     * 
     * @type {Address}
     * @memberof SimplifiedTransferDTO
     */
    sendTo?: Address;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    updatedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SimplifiedTransferDTOTypeEnum {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplifiedTransferDTOStatusEnum {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED',
    REQUESTED = 'REQUESTED'
}

/**
 * 
 * @export
 * @interface SimplifiedWalletInternalDTO
 */
export interface SimplifiedWalletInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface SummarizedDailyExternalWithdrawalsDTO
 */
export interface SummarizedDailyExternalWithdrawalsDTO {
    /**
     * 
     * @type {string}
     * @memberof SummarizedDailyExternalWithdrawalsDTO
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedDailyExternalWithdrawalsDTO
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedDailyExternalWithdrawalsDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedDailyExternalWithdrawalsDTO
     */
    transactionCount: string;
    /**
     * 
     * @type {string}
     * @memberof SummarizedDailyExternalWithdrawalsDTO
     */
    withdrawalAmount: string;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {Array<TransactionOutputDTO>}
     * @memberof TransactionDTO
     */
    outputs: Array<TransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    blockNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    transactionHash: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransactionOutputDTO
 */
export interface TransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    transactionId: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOutputDTO
     */
    outputIndex: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    scriptPubKey: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {number}
     * @memberof TransferDTO
     */
    outputIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    receivedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    sendTo?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    withdrawalApprovalId?: string;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferInternalDTO
 */
export interface TransferInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    amount: string;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferInternalDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {number}
     * @memberof TransferInternalDTO
     */
    outputIndex?: number;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    receivedAt?: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    sendTo?: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    withdrawalApprovalId?: string;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferInternalDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferSearchCondition
 */
export interface TransferSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    createdAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    transferType?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED',
    REQUESTED = 'REQUESTED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressRequest
 */
export interface ValidateIsAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateIsAllowedAddressRequest
     */
    address: string;
}
/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressResponse
 */
export interface ValidateIsAllowedAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateIsAllowedAddressResponse
     */
    isValid: boolean;
}
/**
 * 
 * @export
 * @interface WalletDTO
 */
export interface WalletDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    blockchain?: WalletDTOBlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    type?: WalletDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    status?: WalletDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    walletName?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    updatedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WalletDTOBlockchainEnum {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    FILECOIN = 'FILECOIN',
    BINANCESMARTCHAIN = 'BINANCE_SMART_CHAIN',
    LITECOIN = 'LITECOIN',
    BITCOINCASH = 'BITCOIN_CASH'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletDTOTypeEnum {
    MASTERWALLET = 'MASTER_WALLET',
    DEPOSITADDRESS = 'DEPOSIT_ADDRESS'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletDTOStatusEnum {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface WalletSearchCondition
 */
export interface WalletSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    blockchain?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    updatedAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    createdAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {CoinSymbol}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: CoinSymbol;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
    /**
     * 
     * @type {number}
     * @memberof WalletWithdrawalPolicyDTO
     */
    decimals: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WhitelistType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalPolicyType {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}


/**
 * AdminControllerApi - axios parameter creator
 * @export
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses3: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses3.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses3.');
            }
            const localVarPath = `/api/v2/btc/admin/deposit-addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets3: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getMasterWallets3.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getMasterWallets3.');
            }
            const localVarPath = `/api/v2/btc/admin/master-wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals1: async (searchCondition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchCondition' is not null or undefined
            if (searchCondition === null || searchCondition === undefined) {
                throw new RequiredError('searchCondition','Required parameter searchCondition was null or undefined when calling getSummarizedDailyExternalWithdrawals1.');
            }
            const localVarPath = `/api/v2/btc/admin/billings/summarized-external-withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCondition !== undefined) {
                localVarQueryParameter['searchCondition'] = searchCondition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers5: async (pageable: Pageable, condition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers5.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getTransfers5.');
            }
            const localVarPath = `/api/v2/btc/admin/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses3(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getDepositAddresses3(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets3(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getMasterWallets3(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummarizedDailyExternalWithdrawals1(searchCondition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getSummarizedDailyExternalWithdrawals1(searchCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers5(pageable: Pageable, condition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationSimplifiedTransferDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getTransfers5(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses3(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return AdminControllerApiFp(configuration).getDepositAddresses3(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets3(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return AdminControllerApiFp(configuration).getMasterWallets3(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals1(searchCondition: TransferSearchCondition, options?: any): AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>> {
            return AdminControllerApiFp(configuration).getSummarizedDailyExternalWithdrawals1(searchCondition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers5(pageable: Pageable, condition: TransferSearchCondition, options?: any): AxiosPromise<PaginationSimplifiedTransferDTO> {
            return AdminControllerApiFp(configuration).getTransfers5(pageable, condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getDepositAddresses3(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getDepositAddresses3(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getMasterWallets3(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getMasterWallets3(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransferSearchCondition} searchCondition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getSummarizedDailyExternalWithdrawals1(searchCondition: TransferSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getSummarizedDailyExternalWithdrawals1(searchCondition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getTransfers5(pageable: Pageable, condition: TransferSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getTransfers5(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BchAdminControllerApi - axios parameter creator
 * @export
 */
export const BchAdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses5: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses5.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses5.');
            }
            const localVarPath = `/api/v2/bch/admin/deposit-addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets5: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getMasterWallets5.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getMasterWallets5.');
            }
            const localVarPath = `/api/v2/bch/admin/master-wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals2: async (searchCondition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchCondition' is not null or undefined
            if (searchCondition === null || searchCondition === undefined) {
                throw new RequiredError('searchCondition','Required parameter searchCondition was null or undefined when calling getSummarizedDailyExternalWithdrawals2.');
            }
            const localVarPath = `/api/v2/bch/admin/billings/summarized-external-withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCondition !== undefined) {
                localVarQueryParameter['searchCondition'] = searchCondition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers8: async (pageable: Pageable, condition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers8.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getTransfers8.');
            }
            const localVarPath = `/api/v2/bch/admin/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BchAdminControllerApi - functional programming interface
 * @export
 */
export const BchAdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses5(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await BchAdminControllerApiAxiosParamCreator(configuration).getDepositAddresses5(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets5(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await BchAdminControllerApiAxiosParamCreator(configuration).getMasterWallets5(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummarizedDailyExternalWithdrawals2(searchCondition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>>> {
            const localVarAxiosArgs = await BchAdminControllerApiAxiosParamCreator(configuration).getSummarizedDailyExternalWithdrawals2(searchCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers8(pageable: Pageable, condition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationSimplifiedTransferDTO>> {
            const localVarAxiosArgs = await BchAdminControllerApiAxiosParamCreator(configuration).getTransfers8(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BchAdminControllerApi - factory interface
 * @export
 */
export const BchAdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses5(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return BchAdminControllerApiFp(configuration).getDepositAddresses5(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets5(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return BchAdminControllerApiFp(configuration).getMasterWallets5(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals2(searchCondition: TransferSearchCondition, options?: any): AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>> {
            return BchAdminControllerApiFp(configuration).getSummarizedDailyExternalWithdrawals2(searchCondition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers8(pageable: Pageable, condition: TransferSearchCondition, options?: any): AxiosPromise<PaginationSimplifiedTransferDTO> {
            return BchAdminControllerApiFp(configuration).getTransfers8(pageable, condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BchAdminControllerApi - object-oriented interface
 * @export
 * @class BchAdminControllerApi
 * @extends {BaseAPI}
 */
export class BchAdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchAdminControllerApi
     */
    public getDepositAddresses5(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return BchAdminControllerApiFp(this.configuration).getDepositAddresses5(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchAdminControllerApi
     */
    public getMasterWallets5(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return BchAdminControllerApiFp(this.configuration).getMasterWallets5(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransferSearchCondition} searchCondition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchAdminControllerApi
     */
    public getSummarizedDailyExternalWithdrawals2(searchCondition: TransferSearchCondition, options?: any) {
        return BchAdminControllerApiFp(this.configuration).getSummarizedDailyExternalWithdrawals2(searchCondition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchAdminControllerApi
     */
    public getTransfers8(pageable: Pageable, condition: TransferSearchCondition, options?: any) {
        return BchAdminControllerApiFp(this.configuration).getTransfers8(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BchInternalControllerApi - axios parameter creator
 * @export
 */
export const BchInternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer5: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer5.');
            }
            const localVarPath = `/api/v2/bch/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers7: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers7.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers7.');
            }
            const localVarPath = `/api/v2/bch/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BchInternalControllerApi - functional programming interface
 * @export
 */
export const BchInternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer5(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await BchInternalControllerApiAxiosParamCreator(configuration).getTransfer5(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers7(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await BchInternalControllerApiAxiosParamCreator(configuration).getTransfers7(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BchInternalControllerApi - factory interface
 * @export
 */
export const BchInternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer5(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return BchInternalControllerApiFp(configuration).getTransfer5(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers7(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return BchInternalControllerApiFp(configuration).getTransfers7(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BchInternalControllerApi - object-oriented interface
 * @export
 * @class BchInternalControllerApi
 * @extends {BaseAPI}
 */
export class BchInternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchInternalControllerApi
     */
    public getTransfer5(transferId: string, options?: any) {
        return BchInternalControllerApiFp(this.configuration).getTransfer5(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchInternalControllerApi
     */
    public getTransfers7(pageable: Pageable, specs: object, options?: any) {
        return BchInternalControllerApiFp(this.configuration).getTransfers7(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BchTransferControllerApi - axios parameter creator
 * @export
 */
export const BchTransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer4: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer4.');
            }
            const localVarPath = `/api/v2/bch/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers6: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers6.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers6.');
            }
            const localVarPath = `/api/v2/bch/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BchTransferControllerApi - functional programming interface
 * @export
 */
export const BchTransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer4(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await BchTransferControllerApiAxiosParamCreator(configuration).getTransfer4(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers6(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await BchTransferControllerApiAxiosParamCreator(configuration).getTransfers6(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BchTransferControllerApi - factory interface
 * @export
 */
export const BchTransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer4(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return BchTransferControllerApiFp(configuration).getTransfer4(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers6(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferDTO> {
            return BchTransferControllerApiFp(configuration).getTransfers6(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BchTransferControllerApi - object-oriented interface
 * @export
 * @class BchTransferControllerApi
 * @extends {BaseAPI}
 */
export class BchTransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchTransferControllerApi
     */
    public getTransfer4(transferId: string, options?: any) {
        return BchTransferControllerApiFp(this.configuration).getTransfer4(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchTransferControllerApi
     */
    public getTransfers6(pageable: Pageable, specs: object, options?: any) {
        return BchTransferControllerApiFp(this.configuration).getTransfers6(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BchWalletControllerApi - axios parameter creator
 * @export
 */
export const BchWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses2: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses2.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet2: async (walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWallet2.');
            }
            // verify required parameter 'activateMasterWalletRequest' is not null or undefined
            if (activateMasterWalletRequest === null || activateMasterWalletRequest === undefined) {
                throw new RequiredError('activateMasterWalletRequest','Required parameter activateMasterWalletRequest was null or undefined when calling activateMasterWallet2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateMasterWalletRequest !== undefined ? activateMasterWalletRequest : {}) : (activateMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFee2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress2: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress2.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress2: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress2.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet3: async (createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInactiveMasterWalletRequest' is not null or undefined
            if (createInactiveMasterWalletRequest === null || createInactiveMasterWalletRequest === undefined) {
                throw new RequiredError('createInactiveMasterWalletRequest','Required parameter createInactiveMasterWalletRequest was null or undefined when calling createMasterWallet3.');
            }
            const localVarPath = `/api/v2/bch/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createInactiveMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createInactiveMasterWalletRequest !== undefined ? createInactiveMasterWalletRequest : {}) : (createInactiveMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction2: async (walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransaction2.');
            }
            // verify required parameter 'createRawTransactionRequest' is not null or undefined
            if (createRawTransactionRequest === null || createRawTransactionRequest === undefined) {
                throw new RequiredError('createRawTransactionRequest','Required parameter createRawTransactionRequest was null or undefined when calling createRawTransaction2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createRawTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createRawTransactionRequest !== undefined ? createRawTransactionRequest : {}) : (createRawTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy2: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy2.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress2: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress2.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress2.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress2: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress2.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses2: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddresses2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddresses2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress2: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress2.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses4: async (walletId: string, pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses4.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses4.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses4.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets4: async (specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getMasterWallets4.');
            }
            const localVarPath = `/api/v2/bch/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies2: async (walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicies2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWalletWithdrawalPolicies2.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getWalletWithdrawalPolicies2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy2: async (walletId: string, withdrawalPolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicy2.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling getWalletWithdrawalPolicy2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses2: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses2.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey2: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey2.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchMasterWalletAccountKey2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName2.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchMasterWalletName2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy2: async (walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy2.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling patchWalletWithdrawalPolicy2.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction2.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress2: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress2.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress2.');
            }
            const localVarPath = `/api/v2/bch/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BchWalletControllerApi - functional programming interface
 * @export
 */
export const BchWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses2(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses2(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateMasterWallet2(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).activateMasterWallet2(walletId, activateMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateEstimatedFee2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedFeeDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).calculateEstimatedFee2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress2(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress2(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress2(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).createDepositAddress2(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet3(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).createMasterWallet3(createInactiveMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction2(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).createRawTransaction2(walletId, createRawTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy2(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy2(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress2(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress2(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress2(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress2(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddresses2(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getAllowedAddresses2(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getBalance2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress2(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getDepositAddress2(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses4(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getDepositAddresses4(walletId, pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getMasterWallet2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey2(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey2(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets4(specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getMasterWallets4(specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicies2(walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicies2(walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses2(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses2(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey2(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey2(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName2(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName2(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction2(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).sendTransaction2(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress2(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await BchWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress2(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BchWalletControllerApi - factory interface
 * @export
 */
export const BchWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses2(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return BchWalletControllerApiFp(configuration).activateAllowedAddresses2(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet2(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return BchWalletControllerApiFp(configuration).activateMasterWallet2(walletId, activateMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee2(walletId: string, options?: any): AxiosPromise<EstimatedFeeDTO> {
            return BchWalletControllerApiFp(configuration).calculateEstimatedFee2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress2(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return BchWalletControllerApiFp(configuration).createAllowedAddress2(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress2(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return BchWalletControllerApiFp(configuration).createDepositAddress2(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet3(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO> {
            return BchWalletControllerApiFp(configuration).createMasterWallet3(createInactiveMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction2(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): AxiosPromise<RawTransactionDTO> {
            return BchWalletControllerApiFp(configuration).createRawTransaction2(walletId, createRawTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy2(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return BchWalletControllerApiFp(configuration).createWalletWithdrawalPolicy2(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress2(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return BchWalletControllerApiFp(configuration).deleteAllowedAddress2(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress2(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return BchWalletControllerApiFp(configuration).getAllowedAddress2(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses2(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return BchWalletControllerApiFp(configuration).getAllowedAddresses2(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance2(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return BchWalletControllerApiFp(configuration).getBalance2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress2(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return BchWalletControllerApiFp(configuration).getDepositAddress2(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses4(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return BchWalletControllerApiFp(configuration).getDepositAddresses4(walletId, pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet2(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return BchWalletControllerApiFp(configuration).getMasterWallet2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey2(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return BchWalletControllerApiFp(configuration).getMasterWalletInitialKey2(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets4(specs: object, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return BchWalletControllerApiFp(configuration).getMasterWallets4(specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies2(walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return BchWalletControllerApiFp(configuration).getWalletWithdrawalPolicies2(walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return BchWalletControllerApiFp(configuration).getWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses2(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return BchWalletControllerApiFp(configuration).inactivateAllowedAddresses2(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey2(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return BchWalletControllerApiFp(configuration).patchMasterWalletAccountKey2(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName2(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return BchWalletControllerApiFp(configuration).patchMasterWalletName2(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return BchWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction2(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return BchWalletControllerApiFp(configuration).sendTransaction2(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress2(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return BchWalletControllerApiFp(configuration).validateIsAllowedAddress2(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BchWalletControllerApi - object-oriented interface
 * @export
 * @class BchWalletControllerApi
 * @extends {BaseAPI}
 */
export class BchWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public activateAllowedAddresses2(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).activateAllowedAddresses2(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public activateMasterWallet2(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).activateMasterWallet2(walletId, activateMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public calculateEstimatedFee2(walletId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).calculateEstimatedFee2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public createAllowedAddress2(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).createAllowedAddress2(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public createDepositAddress2(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).createDepositAddress2(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public createMasterWallet3(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).createMasterWallet3(createInactiveMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateRawTransactionRequest} createRawTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public createRawTransaction2(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).createRawTransaction2(walletId, createRawTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public createWalletWithdrawalPolicy2(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy2(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public deleteAllowedAddress2(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).deleteAllowedAddress2(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getAllowedAddress2(walletId: string, allowedAddressId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getAllowedAddress2(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getAllowedAddresses2(walletId: string, pageable: Pageable, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getAllowedAddresses2(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getBalance2(walletId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getBalance2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getDepositAddress2(walletId: string, depositAddressId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getDepositAddress2(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getDepositAddresses4(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getDepositAddresses4(walletId, pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getMasterWallet2(walletId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getMasterWallet2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getMasterWalletInitialKey2(walletId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getMasterWalletInitialKey2(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getMasterWallets4(specs: object, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getMasterWallets4(specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getWalletWithdrawalPolicies2(walletId: string, pageable: Pageable, specs: object, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getWalletWithdrawalPolicies2(walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public getWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, options?: any) {
        return BchWalletControllerApiFp(this.configuration).getWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public inactivateAllowedAddresses2(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).inactivateAllowedAddresses2(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public patchMasterWalletAccountKey2(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).patchMasterWalletAccountKey2(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public patchMasterWalletName2(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).patchMasterWalletName2(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public patchWalletWithdrawalPolicy2(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy2(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public sendTransaction2(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).sendTransaction2(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWalletControllerApi
     */
    public validateIsAllowedAddress2(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return BchWalletControllerApiFp(this.configuration).validateIsAllowedAddress2(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BchWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const BchWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval2: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval2.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval2.');
            }
            const localVarPath = `/api/v2/bch/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval2: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval2.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval2.');
            }
            const localVarPath = `/api/v2/bch/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BchWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const BchWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval2(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await BchWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval2(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval2(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BchWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval2(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BchWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const BchWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval2(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransferDTO> {
            return BchWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval2(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval2(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return BchWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval2(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BchWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class BchWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class BchWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval2(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return BchWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval2(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BchWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval2(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return BchWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval2(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalControllerApi - axios parameter creator
 * @export
 */
export const InternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer3: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer3.');
            }
            const localVarPath = `/api/v2/btc/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers4: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers4.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers4.');
            }
            const localVarPath = `/api/v2/btc/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalControllerApi - functional programming interface
 * @export
 */
export const InternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer3(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfer3(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers4(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfers4(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalControllerApi - factory interface
 * @export
 */
export const InternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer3(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfer3(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers4(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfers4(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalControllerApi - object-oriented interface
 * @export
 * @class InternalControllerApi
 * @extends {BaseAPI}
 */
export class InternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfer3(transferId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfer3(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfers4(pageable: Pageable, specs: object, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfers4(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LtcAdminControllerApi - axios parameter creator
 * @export
 */
export const LtcAdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses1: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses1.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses1.');
            }
            const localVarPath = `/api/v2/ltc/admin/deposit-addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getMasterWallets1.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getMasterWallets1.');
            }
            const localVarPath = `/api/v2/ltc/admin/master-wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals: async (searchCondition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchCondition' is not null or undefined
            if (searchCondition === null || searchCondition === undefined) {
                throw new RequiredError('searchCondition','Required parameter searchCondition was null or undefined when calling getSummarizedDailyExternalWithdrawals.');
            }
            const localVarPath = `/api/v2/ltc/admin/billings/summarized-external-withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchCondition !== undefined) {
                localVarQueryParameter['searchCondition'] = searchCondition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers2: async (pageable: Pageable, condition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers2.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getTransfers2.');
            }
            const localVarPath = `/api/v2/ltc/admin/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LtcAdminControllerApi - functional programming interface
 * @export
 */
export const LtcAdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await LtcAdminControllerApiAxiosParamCreator(configuration).getDepositAddresses1(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await LtcAdminControllerApiAxiosParamCreator(configuration).getMasterWallets1(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummarizedDailyExternalWithdrawals(searchCondition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>>> {
            const localVarAxiosArgs = await LtcAdminControllerApiAxiosParamCreator(configuration).getSummarizedDailyExternalWithdrawals(searchCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationSimplifiedTransferDTO>> {
            const localVarAxiosArgs = await LtcAdminControllerApiAxiosParamCreator(configuration).getTransfers2(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LtcAdminControllerApi - factory interface
 * @export
 */
export const LtcAdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return LtcAdminControllerApiFp(configuration).getDepositAddresses1(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return LtcAdminControllerApiFp(configuration).getMasterWallets1(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TransferSearchCondition} searchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummarizedDailyExternalWithdrawals(searchCondition: TransferSearchCondition, options?: any): AxiosPromise<Array<SummarizedDailyExternalWithdrawalsDTO>> {
            return LtcAdminControllerApiFp(configuration).getSummarizedDailyExternalWithdrawals(searchCondition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any): AxiosPromise<PaginationSimplifiedTransferDTO> {
            return LtcAdminControllerApiFp(configuration).getTransfers2(pageable, condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LtcAdminControllerApi - object-oriented interface
 * @export
 * @class LtcAdminControllerApi
 * @extends {BaseAPI}
 */
export class LtcAdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcAdminControllerApi
     */
    public getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return LtcAdminControllerApiFp(this.configuration).getDepositAddresses1(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcAdminControllerApi
     */
    public getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return LtcAdminControllerApiFp(this.configuration).getMasterWallets1(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TransferSearchCondition} searchCondition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcAdminControllerApi
     */
    public getSummarizedDailyExternalWithdrawals(searchCondition: TransferSearchCondition, options?: any) {
        return LtcAdminControllerApiFp(this.configuration).getSummarizedDailyExternalWithdrawals(searchCondition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcAdminControllerApi
     */
    public getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any) {
        return LtcAdminControllerApiFp(this.configuration).getTransfers2(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LtcInternalControllerApi - axios parameter creator
 * @export
 */
export const LtcInternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer1.');
            }
            const localVarPath = `/api/v2/ltc/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers1.');
            }
            const localVarPath = `/api/v2/ltc/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LtcInternalControllerApi - functional programming interface
 * @export
 */
export const LtcInternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer1(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await LtcInternalControllerApiAxiosParamCreator(configuration).getTransfer1(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers1(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await LtcInternalControllerApiAxiosParamCreator(configuration).getTransfers1(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LtcInternalControllerApi - factory interface
 * @export
 */
export const LtcInternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return LtcInternalControllerApiFp(configuration).getTransfer1(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return LtcInternalControllerApiFp(configuration).getTransfers1(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LtcInternalControllerApi - object-oriented interface
 * @export
 * @class LtcInternalControllerApi
 * @extends {BaseAPI}
 */
export class LtcInternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcInternalControllerApi
     */
    public getTransfer1(transferId: string, options?: any) {
        return LtcInternalControllerApiFp(this.configuration).getTransfer1(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcInternalControllerApi
     */
    public getTransfers1(pageable: Pageable, specs: object, options?: any) {
        return LtcInternalControllerApiFp(this.configuration).getTransfers1(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LtcTransferControllerApi - axios parameter creator
 * @export
 */
export const LtcTransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/ltc/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/ltc/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LtcTransferControllerApi - functional programming interface
 * @export
 */
export const LtcTransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await LtcTransferControllerApiAxiosParamCreator(configuration).getTransfer(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await LtcTransferControllerApiAxiosParamCreator(configuration).getTransfers(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LtcTransferControllerApi - factory interface
 * @export
 */
export const LtcTransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return LtcTransferControllerApiFp(configuration).getTransfer(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferDTO> {
            return LtcTransferControllerApiFp(configuration).getTransfers(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LtcTransferControllerApi - object-oriented interface
 * @export
 * @class LtcTransferControllerApi
 * @extends {BaseAPI}
 */
export class LtcTransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcTransferControllerApi
     */
    public getTransfer(transferId: string, options?: any) {
        return LtcTransferControllerApiFp(this.configuration).getTransfer(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcTransferControllerApi
     */
    public getTransfers(pageable: Pageable, specs: object, options?: any) {
        return LtcTransferControllerApiFp(this.configuration).getTransfers(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LtcWalletControllerApi - axios parameter creator
 * @export
 */
export const LtcWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet: async (walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWallet.');
            }
            // verify required parameter 'activateMasterWalletRequest' is not null or undefined
            if (activateMasterWalletRequest === null || activateMasterWalletRequest === undefined) {
                throw new RequiredError('activateMasterWalletRequest','Required parameter activateMasterWalletRequest was null or undefined when calling activateMasterWallet.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateMasterWalletRequest !== undefined ? activateMasterWalletRequest : {}) : (activateMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFee.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1: async (createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInactiveMasterWalletRequest' is not null or undefined
            if (createInactiveMasterWalletRequest === null || createInactiveMasterWalletRequest === undefined) {
                throw new RequiredError('createInactiveMasterWalletRequest','Required parameter createInactiveMasterWalletRequest was null or undefined when calling createMasterWallet1.');
            }
            const localVarPath = `/api/v2/ltc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createInactiveMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createInactiveMasterWalletRequest !== undefined ? createInactiveMasterWalletRequest : {}) : (createInactiveMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction: async (walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransaction.');
            }
            // verify required parameter 'createRawTransactionRequest' is not null or undefined
            if (createRawTransactionRequest === null || createRawTransactionRequest === undefined) {
                throw new RequiredError('createRawTransactionRequest','Required parameter createRawTransactionRequest was null or undefined when calling createRawTransaction.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createRawTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createRawTransactionRequest !== undefined ? createRawTransactionRequest : {}) : (createRawTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddresses.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (walletId: string, pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/ltc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies: async (walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy: async (walletId: string, withdrawalPolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy: async (walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress.');
            }
            const localVarPath = `/api/v2/ltc/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LtcWalletControllerApi - functional programming interface
 * @export
 */
export const LtcWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateEstimatedFee(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedFeeDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).calculateEstimatedFee(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).createMasterWallet1(createInactiveMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).createRawTransaction(walletId, createRawTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getAllowedAddress(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddresses(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getAllowedAddresses(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getBalance(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getDepositAddress(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(walletId, pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getMasterWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getMasterWallets(specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await LtcWalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LtcWalletControllerApi - factory interface
 * @export
 */
export const LtcWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return LtcWalletControllerApiFp(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return LtcWalletControllerApiFp(configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee(walletId: string, options?: any): AxiosPromise<EstimatedFeeDTO> {
            return LtcWalletControllerApiFp(configuration).calculateEstimatedFee(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return LtcWalletControllerApiFp(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return LtcWalletControllerApiFp(configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO> {
            return LtcWalletControllerApiFp(configuration).createMasterWallet1(createInactiveMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): AxiosPromise<RawTransactionDTO> {
            return LtcWalletControllerApiFp(configuration).createRawTransaction(walletId, createRawTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return LtcWalletControllerApiFp(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return LtcWalletControllerApiFp(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return LtcWalletControllerApiFp(configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return LtcWalletControllerApiFp(configuration).getAllowedAddresses(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return LtcWalletControllerApiFp(configuration).getBalance(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return LtcWalletControllerApiFp(configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return LtcWalletControllerApiFp(configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return LtcWalletControllerApiFp(configuration).getMasterWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return LtcWalletControllerApiFp(configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(specs: object, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return LtcWalletControllerApiFp(configuration).getMasterWallets(specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return LtcWalletControllerApiFp(configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return LtcWalletControllerApiFp(configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return LtcWalletControllerApiFp(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return LtcWalletControllerApiFp(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return LtcWalletControllerApiFp(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return LtcWalletControllerApiFp(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return LtcWalletControllerApiFp(configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return LtcWalletControllerApiFp(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LtcWalletControllerApi - object-oriented interface
 * @export
 * @class LtcWalletControllerApi
 * @extends {BaseAPI}
 */
export class LtcWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public calculateEstimatedFee(walletId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).calculateEstimatedFee(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).createMasterWallet1(createInactiveMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateRawTransactionRequest} createRawTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).createRawTransaction(walletId, createRawTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getAllowedAddress(walletId: string, allowedAddressId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getAllowedAddresses(walletId: string, pageable: Pageable, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getAllowedAddresses(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getBalance(walletId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getBalance(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getDepositAddress(walletId: string, depositAddressId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getMasterWallet(walletId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getMasterWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getMasterWalletInitialKey(walletId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getMasterWallets(specs: object, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getMasterWallets(specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWalletControllerApi
     */
    public validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return LtcWalletControllerApiFp(this.configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LtcWithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const LtcWithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/ltc/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/ltc/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LtcWithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const LtcWithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await LtcWithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LtcWithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LtcWithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const LtcWithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransferDTO> {
            return LtcWithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return LtcWithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LtcWithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class LtcWithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class LtcWithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return LtcWithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LtcWithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return LtcWithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer2: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer2.');
            }
            const localVarPath = `/api/v2/btc/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers3: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers3.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers3.');
            }
            const localVarPath = `/api/v2/btc/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer2(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer2(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers3(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers3(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer2(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer2(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers3(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers3(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer2(transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer2(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers3(pageable: Pageable, specs: object, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers3(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses1.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet1: async (walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWallet1.');
            }
            // verify required parameter 'activateMasterWalletRequest' is not null or undefined
            if (activateMasterWalletRequest === null || activateMasterWalletRequest === undefined) {
                throw new RequiredError('activateMasterWalletRequest','Required parameter activateMasterWalletRequest was null or undefined when calling activateMasterWallet1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateMasterWalletRequest !== undefined ? activateMasterWalletRequest : {}) : (activateMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFee1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress1.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress1: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress1.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2: async (createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInactiveMasterWalletRequest' is not null or undefined
            if (createInactiveMasterWalletRequest === null || createInactiveMasterWalletRequest === undefined) {
                throw new RequiredError('createInactiveMasterWalletRequest','Required parameter createInactiveMasterWalletRequest was null or undefined when calling createMasterWallet2.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createInactiveMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createInactiveMasterWalletRequest !== undefined ? createInactiveMasterWalletRequest : {}) : (createInactiveMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction1: async (walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransaction1.');
            }
            // verify required parameter 'createRawTransactionRequest' is not null or undefined
            if (createRawTransactionRequest === null || createRawTransactionRequest === undefined) {
                throw new RequiredError('createRawTransactionRequest','Required parameter createRawTransactionRequest was null or undefined when calling createRawTransaction1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createRawTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createRawTransactionRequest !== undefined ? createRawTransactionRequest : {}) : (createRawTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress1.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress1.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses1: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddresses1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress1: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress1.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses2: async (walletId: string, pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses2.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses2.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses2.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2: async (specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getMasterWallets2.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies1: async (walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicies1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWalletWithdrawalPolicies1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getWalletWithdrawalPolicies1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy1: async (walletId: string, withdrawalPolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling getWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses1.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey1: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey1.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchMasterWalletAccountKey1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName1.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchMasterWalletName1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1: async (walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction1.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress1.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress1.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateMasterWallet1(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateMasterWallet1(walletId, activateMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateEstimatedFee1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedFeeDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).calculateEstimatedFee1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress1(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress1(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet2(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet2(createInactiveMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction1(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createRawTransaction1(walletId, createRawTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddress1(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddresses1(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddresses1(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress1(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress1(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses2(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses2(walletId, pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey1(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey1(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets2(specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets2(specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicies1(walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey1(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey1(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName1(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName1(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction1(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction1(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet1(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).activateMasterWallet1(walletId, activateMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee1(walletId: string, options?: any): AxiosPromise<EstimatedFeeDTO> {
            return WalletControllerApiFp(configuration).calculateEstimatedFee1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress1(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress1(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet2(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet2(createInactiveMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction1(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): AxiosPromise<RawTransactionDTO> {
            return WalletControllerApiFp(configuration).createRawTransaction1(walletId, createRawTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddress1(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses1(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddresses1(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance1(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress1(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress1(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses2(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses2(walletId, pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet1(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey1(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey1(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets2(specs: object, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets2(specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicies1(walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey1(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletAccountKey1(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName1(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName1(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).patchWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction1(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction1(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return WalletControllerApiFp(configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateAllowedAddresses1(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).activateAllowedAddresses1(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateMasterWallet1(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).activateMasterWallet1(walletId, activateMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public calculateEstimatedFee1(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).calculateEstimatedFee1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createAllowedAddress1(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createAllowedAddress1(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress1(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress1(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet2(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet2(createInactiveMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateRawTransactionRequest} createRawTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createRawTransaction1(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createRawTransaction1(walletId, createRawTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWalletWithdrawalPolicy1(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy1(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public deleteAllowedAddress1(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).deleteAllowedAddress1(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddress1(walletId: string, allowedAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddress1(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddresses1(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddresses1(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance1(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress1(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress1(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses2(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses2(walletId, pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet1(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey1(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey1(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets2(specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets2(specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicies1(walletId: string, pageable: Pageable, specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicies1(walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public inactivateAllowedAddresses1(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).inactivateAllowedAddresses1(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletAccountKey1(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletAccountKey1(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName1(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName1(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletWithdrawalPolicy1(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy1(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction1(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction1(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public validateIsAllowedAddress1(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).validateIsAllowedAddress1(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval1.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval1.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval1.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransferDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return WithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval1(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval1(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval1(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval1(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


