/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://dev.wallet.henesis.io/docs/v2/btc".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ActivateMasterWalletRequestDTO
 */
export interface ActivateMasterWalletRequestDTO {
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequestDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequestDTO
     */
    backupKey: KeyDTO;
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode: string;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
}

/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}

/**
 * 
 * @export
 * @interface CreateDepositAddressDTO
 */
export interface CreateDepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressDTO
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletRequestDTO
 */
export interface CreateInactiveMasterWalletRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequestDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequestDTO
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateMasterWalletRequestDTO
 */
export interface CreateMasterWalletRequestDTO {
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequestDTO
     */
    backupKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequestDTO
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateMasterWalletResponseDTO
 */
export interface CreateMasterWalletResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletResponseDTO
     */
    henesisKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletResponseDTO
     */
    status: CreateMasterWalletResponseDTO.StatusEnum;
}

/**
 * @export
 * @namespace CreateMasterWalletResponseDTO
 */
export namespace CreateMasterWalletResponseDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE',
        CREATING = <any> 'CREATING'
    }
}

/**
 * 
 * @export
 * @interface CreateRawTransactionDTO
 */
export interface CreateRawTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionDTO
     */
    to: string;
}

/**
 * 
 * @export
 * @interface CreateTransactionDTO
 */
export interface CreateTransactionDTO {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof CreateTransactionDTO
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionDTO
     */
    otpCode: string;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof CreateTransactionDTO
     */
    outputs: Array<CreateTransactionOutputDTO>;
}

/**
 * 
 * @export
 * @interface CreateTransactionInputDTO
 */
export interface CreateTransactionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionInputDTO
     */
    accountSignature: string;
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof CreateTransactionInputDTO
     */
    transactionOutput: TransactionOutputDTO;
}

/**
 * 
 * @export
 * @interface CreateTransactionOutputDTO
 */
export interface CreateTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransactionOutputDTO
     */
    isChange: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    to: string;
}

/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    policyType: string;
}

/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
}

/**
 * 
 * @export
 * @interface EstimatedFeeDTO
 */
export interface EstimatedFeeDTO {
    /**
     * 
     * @type {string}
     * @memberof EstimatedFeeDTO
     */
    estimatedFee: string;
}

/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    templated?: boolean;
}

/**
 * 
 * @export
 * @interface MapstringLink
 */
export interface MapstringLink {
    [key: string]: Link;

}

/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    status: MasterWalletDTO.StatusEnum;
}

/**
 * @export
 * @namespace MasterWalletDTO
 */
export namespace MasterWalletDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE',
        CREATING = <any> 'CREATING'
    }
}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}

/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}

/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}

/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}

/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}

/**
 * 
 * @export
 * @interface PatchAccountKeyRequestDTO
 */
export interface PatchAccountKeyRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequestDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequestDTO
     */
    otpCode: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequestDTO
     */
    pub: string;
}

/**
 * 
 * @export
 * @interface PatchWalletNameRequestDTO
 */
export interface PatchWalletNameRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequestDTO
     */
    name: string;
}

/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
}

/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {Array<RawTransactionInputDTO>}
     * @memberof RawTransactionDTO
     */
    inputs: Array<RawTransactionInputDTO>;
    /**
     * 
     * @type {Array<RawTransactionOutputDTO>}
     * @memberof RawTransactionDTO
     */
    outputs: Array<RawTransactionOutputDTO>;
}

/**
 * 
 * @export
 * @interface RawTransactionInputDTO
 */
export interface RawTransactionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionInputDTO
     */
    redeemScript?: string;
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof RawTransactionInputDTO
     */
    transactionOutput?: TransactionOutputDTO;
}

/**
 * 
 * @export
 * @interface RawTransactionOutputDTO
 */
export interface RawTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof RawTransactionOutputDTO
     */
    isChange: boolean;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    to: string;
}

/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    blockNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransactionOutputDTO>}
     * @memberof TransactionDTO
     */
    outputs: Array<TransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    transactionHash: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}

/**
 * 
 * @export
 * @interface TransactionOutputDTO
 */
export interface TransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOutputDTO
     */
    isChange: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionOutputDTO
     */
    outputIndex: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    scriptPubKey: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    transactionId: string;
}

/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof TransferDTO
     */
    outputIndex: number;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    receivedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    sendTo?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    status: TransferDTO.StatusEnum;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    type: TransferDTO.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
}

/**
 * @export
 * @namespace TransferDTO
 */
export namespace TransferDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        MINED = <any> 'MINED',
        CONFIRMED = <any> 'CONFIRMED',
        REQUESTED = <any> 'REQUESTED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        WITHDRAWAL = <any> 'WITHDRAWAL',
        DEPOSIT = <any> 'DEPOSIT'
    }
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    policyType: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
}


/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * OperationHandlerApi - fetch parameter creator
 * @export
 */
export const OperationHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health/{component}/{instance}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health/{component}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: any, options: any = {}): FetchArgs {
            const localVarPath = `/actuator/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationHandlerApi - functional programming interface
 * @export
 */
export const OperationHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET1(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET2(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OperationHandlerApiFetchParamCreator(configuration).handleUsingGET3(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperationHandlerApi - factory interface
 * @export
 */
export const OperationHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET1(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET2(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET2(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary handle
         * @param {any} [body] body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUsingGET3(body?: any, options?: any) {
            return OperationHandlerApiFp(configuration).handleUsingGET3(body, options)(fetch, basePath);
        },
    };
};

/**
 * OperationHandlerApi - object-oriented interface
 * @export
 * @class OperationHandlerApi
 * @extends {BaseAPI}
 */
export class OperationHandlerApi extends BaseAPI {
    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET1(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET2(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET2(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary handle
     * @param {any} [body] body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationHandlerApi
     */
    public handleUsingGET3(body?: any, options?: any) {
        return OperationHandlerApiFp(this.configuration).handleUsingGET3(body, options)(this.fetch, this.basePath);
    }

}

/**
 * TransferControllerApi - fetch parameter creator
 * @export
 */
export const TransferControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getTransfer
         * @param {string} transferId transferId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransferUsingGET(transferId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransferUsingGET.');
            }
            const localVarPath = `/api/v2/btc/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTransfers
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfersUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/btc/transfers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getTransfer
         * @param {string} transferId transferId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransferUsingGET(transferId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferDTO> {
            const localVarFetchArgs = TransferControllerApiFetchParamCreator(configuration).getTransferUsingGET(transferId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTransfers
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfersUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationTransferDTO> {
            const localVarFetchArgs = TransferControllerApiFetchParamCreator(configuration).getTransfersUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getTransfer
         * @param {string} transferId transferId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransferUsingGET(transferId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return TransferControllerApiFp(configuration).getTransferUsingGET(transferId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTransfers
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfersUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return TransferControllerApiFp(configuration).getTransfersUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @summary getTransfer
     * @param {string} transferId transferId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransferUsingGET(transferId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransferUsingGET(transferId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTransfers
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfersUsingGET(accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfersUsingGET(accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

}

/**
 * WalletControllerApi - fetch parameter creator
 * @export
 */
export const WalletControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateMasterWallet
         * @param {ActivateMasterWalletRequestDTO} activateMasterWalletRequestDTO activateMasterWalletRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWalletUsingPOST(activateMasterWalletRequestDTO: ActivateMasterWalletRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'activateMasterWalletRequestDTO' is not null or undefined
            if (activateMasterWalletRequestDTO === null || activateMasterWalletRequestDTO === undefined) {
                throw new RequiredError('activateMasterWalletRequestDTO','Required parameter activateMasterWalletRequestDTO was null or undefined when calling activateMasterWalletUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ActivateMasterWalletRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(activateMasterWalletRequestDTO || {}) : (activateMasterWalletRequestDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary calculateEstimatedFee
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFeeUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFeeUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createDepositAddress
         * @param {CreateDepositAddressDTO} createDepositAddressDTO createDepositAddressDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddressUsingPOST(createDepositAddressDTO: CreateDepositAddressDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'createDepositAddressDTO' is not null or undefined
            if (createDepositAddressDTO === null || createDepositAddressDTO === undefined) {
                throw new RequiredError('createDepositAddressDTO','Required parameter createDepositAddressDTO was null or undefined when calling createDepositAddressUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddressUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDepositAddressDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createDepositAddressDTO || {}) : (createDepositAddressDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createInactiveMasterWallet
         * @param {CreateInactiveMasterWalletRequestDTO} createInactiveMasterWalletRequestDTO createInactiveMasterWalletRequestDTO
         * @param {'inactive'} type 
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO: CreateInactiveMasterWalletRequestDTO, type: 'inactive', accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'createInactiveMasterWalletRequestDTO' is not null or undefined
            if (createInactiveMasterWalletRequestDTO === null || createInactiveMasterWalletRequestDTO === undefined) {
                throw new RequiredError('createInactiveMasterWalletRequestDTO','Required parameter createInactiveMasterWalletRequestDTO was null or undefined when calling createInactiveMasterWalletUsingPOST.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createInactiveMasterWalletUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateInactiveMasterWalletRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createInactiveMasterWalletRequestDTO || {}) : (createInactiveMasterWalletRequestDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createRawTransaction
         * @param {CreateRawTransactionDTO} createRawTransactionDTO createRawTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransactionUsingPOST(createRawTransactionDTO: CreateRawTransactionDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'createRawTransactionDTO' is not null or undefined
            if (createRawTransactionDTO === null || createRawTransactionDTO === undefined) {
                throw new RequiredError('createRawTransactionDTO','Required parameter createRawTransactionDTO was null or undefined when calling createRawTransactionUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransactionUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRawTransactionDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createRawTransactionDTO || {}) : (createRawTransactionDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicyUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicyUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWithdrawalPolicyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest || {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBalance
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalanceUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDepositAddress
         * @param {string} depositAddressId depositAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressUsingGET(depositAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddressUsingGET.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddressUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDepositAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddressesUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (paged !== undefined) {
                localVarQueryParameter['paged'] = paged;
            }

            if (sortSorted !== undefined) {
                localVarQueryParameter['sort.sorted'] = sortSorted;
            }

            if (sortUnsorted !== undefined) {
                localVarQueryParameter['sort.unsorted'] = sortUnsorted;
            }

            if (unpaged !== undefined) {
                localVarQueryParameter['unpaged'] = unpaged;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKeyUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getWalletWithdrawalPolicy
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicyUsingGET.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchMasterWalletAccountKey
         * @param {PatchAccountKeyRequestDTO} patchAccountKeyRequestDTO patchAccountKeyRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO: PatchAccountKeyRequestDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'patchAccountKeyRequestDTO' is not null or undefined
            if (patchAccountKeyRequestDTO === null || patchAccountKeyRequestDTO === undefined) {
                throw new RequiredError('patchAccountKeyRequestDTO','Required parameter patchAccountKeyRequestDTO was null or undefined when calling patchMasterWalletAccountKeyUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKeyUsingPATCH.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchAccountKeyRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchAccountKeyRequestDTO || {}) : (patchAccountKeyRequestDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {PatchWalletNameRequestDTO} patchWalletNameRequestDTO patchWalletNameRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO: PatchWalletNameRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'patchWalletNameRequestDTO' is not null or undefined
            if (patchWalletNameRequestDTO === null || patchWalletNameRequestDTO === undefined) {
                throw new RequiredError('patchWalletNameRequestDTO','Required parameter patchWalletNameRequestDTO was null or undefined when calling patchMasterWalletNameUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletNameUsingPATCH.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchWalletNameRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchWalletNameRequestDTO || {}) : (patchWalletNameRequestDTO || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicyUsingPATCH.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchWithdrawalPolicyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest || {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateTransactionDTO} createTransactionDTO createTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(createTransactionDTO: CreateTransactionDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'createTransactionDTO' is not null or undefined
            if (createTransactionDTO === null || createTransactionDTO === undefined) {
                throw new RequiredError('createTransactionDTO','Required parameter createTransactionDTO was null or undefined when calling sendTransactionUsingPOST.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransactionUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(needOTP || {}) : (needOTP || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary activateMasterWallet
         * @param {ActivateMasterWalletRequestDTO} activateMasterWalletRequestDTO activateMasterWalletRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWalletUsingPOST(activateMasterWalletRequestDTO: ActivateMasterWalletRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).activateMasterWalletUsingPOST(activateMasterWalletRequestDTO, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary calculateEstimatedFee
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFeeUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstimatedFeeDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).calculateEstimatedFeeUsingGET(walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createDepositAddress
         * @param {CreateDepositAddressDTO} createDepositAddressDTO createDepositAddressDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddressUsingPOST(createDepositAddressDTO: CreateDepositAddressDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositAddressDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).createDepositAddressUsingPOST(createDepositAddressDTO, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createInactiveMasterWallet
         * @param {CreateInactiveMasterWalletRequestDTO} createInactiveMasterWalletRequestDTO createInactiveMasterWalletRequestDTO
         * @param {'inactive'} type 
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO: CreateInactiveMasterWalletRequestDTO, type: 'inactive', accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateMasterWalletResponseDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO, type, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createRawTransaction
         * @param {CreateRawTransactionDTO} createRawTransactionDTO createRawTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransactionUsingPOST(createRawTransactionDTO: CreateRawTransactionDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RawTransactionDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).createRawTransactionUsingPOST(createRawTransactionDTO, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getBalance
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BalanceDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getBalanceUsingGET(walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDepositAddress
         * @param {string} depositAddressId depositAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressUsingGET(depositAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositAddressDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getDepositAddressUsingGET(depositAddressId, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDepositAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationDepositAddressDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getDepositAddressesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MasterWalletDTO>> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getWalletWithdrawalPolicy
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginationWalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).getWalletWithdrawalPolicyUsingGET(walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchMasterWalletAccountKey
         * @param {PatchAccountKeyRequestDTO} patchAccountKeyRequestDTO patchAccountKeyRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO: PatchAccountKeyRequestDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO, walletId, accountId, needOTP, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {PatchWalletNameRequestDTO} patchWalletNameRequestDTO patchWalletNameRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO: PatchWalletNameRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MasterWalletDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletWithdrawalPolicyDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateTransactionDTO} createTransactionDTO createTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(createTransactionDTO: CreateTransactionDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransferDTO> {
            const localVarFetchArgs = WalletControllerApiFetchParamCreator(configuration).sendTransactionUsingPOST(createTransactionDTO, walletId, accountId, needOTP, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary activateMasterWallet
         * @param {ActivateMasterWalletRequestDTO} activateMasterWalletRequestDTO activateMasterWalletRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWalletUsingPOST(activateMasterWalletRequestDTO: ActivateMasterWalletRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).activateMasterWalletUsingPOST(activateMasterWalletRequestDTO, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary calculateEstimatedFee
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFeeUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).calculateEstimatedFeeUsingGET(walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createDepositAddress
         * @param {CreateDepositAddressDTO} createDepositAddressDTO createDepositAddressDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddressUsingPOST(createDepositAddressDTO: CreateDepositAddressDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).createDepositAddressUsingPOST(createDepositAddressDTO, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createInactiveMasterWallet
         * @param {CreateInactiveMasterWalletRequestDTO} createInactiveMasterWalletRequestDTO createInactiveMasterWalletRequestDTO
         * @param {'inactive'} type 
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO: CreateInactiveMasterWalletRequestDTO, type: 'inactive', accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO, type, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createRawTransaction
         * @param {CreateRawTransactionDTO} createRawTransactionDTO createRawTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransactionUsingPOST(createRawTransactionDTO: CreateRawTransactionDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).createRawTransactionUsingPOST(createRawTransactionDTO, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary createWalletWithdrawalPolicy
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getBalance
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getBalanceUsingGET(walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDepositAddress
         * @param {string} depositAddressId depositAddressId
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressUsingGET(depositAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getDepositAddressUsingGET(depositAddressId, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDepositAddresses
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {number} [offset] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {boolean} [paged] 
         * @param {boolean} [sortSorted] 
         * @param {boolean} [sortUnsorted] 
         * @param {boolean} [unpaged] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
            return WalletControllerApiFp(configuration).getDepositAddressesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWalletInitialKey
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallet
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getMasterWallets
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getWalletWithdrawalPolicy
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicyUsingGET(walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchMasterWalletAccountKey
         * @param {PatchAccountKeyRequestDTO} patchAccountKeyRequestDTO patchAccountKeyRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO: PatchAccountKeyRequestDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO, walletId, accountId, needOTP, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchMasterWalletName
         * @param {PatchWalletNameRequestDTO} patchWalletNameRequestDTO patchWalletNameRequestDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO: PatchWalletNameRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary patchWalletWithdrawalPolicy
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary sendTransaction
         * @param {CreateTransactionDTO} createTransactionDTO createTransactionDTO
         * @param {string} walletId walletId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransactionUsingPOST(createTransactionDTO: CreateTransactionDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
            return WalletControllerApiFp(configuration).sendTransactionUsingPOST(createTransactionDTO, walletId, accountId, needOTP, organizationId, otpKey, options)(fetch, basePath);
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @summary activateMasterWallet
     * @param {ActivateMasterWalletRequestDTO} activateMasterWalletRequestDTO activateMasterWalletRequestDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateMasterWalletUsingPOST(activateMasterWalletRequestDTO: ActivateMasterWalletRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).activateMasterWalletUsingPOST(activateMasterWalletRequestDTO, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary calculateEstimatedFee
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public calculateEstimatedFeeUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).calculateEstimatedFeeUsingGET(walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createDepositAddress
     * @param {CreateDepositAddressDTO} createDepositAddressDTO createDepositAddressDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddressUsingPOST(createDepositAddressDTO: CreateDepositAddressDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddressUsingPOST(createDepositAddressDTO, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createInactiveMasterWallet
     * @param {CreateInactiveMasterWalletRequestDTO} createInactiveMasterWalletRequestDTO createInactiveMasterWalletRequestDTO
     * @param {'inactive'} type 
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO: CreateInactiveMasterWalletRequestDTO, type: 'inactive', accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).createInactiveMasterWalletUsingPOST(createInactiveMasterWalletRequestDTO, type, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createRawTransaction
     * @param {CreateRawTransactionDTO} createRawTransactionDTO createRawTransactionDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createRawTransactionUsingPOST(createRawTransactionDTO: CreateRawTransactionDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).createRawTransactionUsingPOST(createRawTransactionDTO, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary createWalletWithdrawalPolicy
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest createWithdrawalPolicyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).createWalletWithdrawalPolicyUsingPOST(createWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getBalance
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalanceUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalanceUsingGET(walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDepositAddress
     * @param {string} depositAddressId depositAddressId
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddressUsingGET(depositAddressId: string, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddressUsingGET(depositAddressId, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDepositAddresses
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {number} [offset] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {boolean} [paged] 
     * @param {boolean} [sortSorted] 
     * @param {boolean} [sortUnsorted] 
     * @param {boolean} [unpaged] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddressesUsingGET(walletId: string, accountId?: string, offset?: number, organizationId?: string, otpKey?: string, pageNumber?: number, pageSize?: number, paged?: boolean, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddressesUsingGET(walletId, accountId, offset, organizationId, otpKey, pageNumber, pageSize, paged, sortSorted, sortUnsorted, unpaged, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWalletInitialKey
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKeyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKeyUsingGET(walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallet
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletUsingGET(walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getMasterWallets
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletsUsingGET(accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletsUsingGET(accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getWalletWithdrawalPolicy
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicyUsingGET(walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicyUsingGET(walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchMasterWalletAccountKey
     * @param {PatchAccountKeyRequestDTO} patchAccountKeyRequestDTO patchAccountKeyRequestDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO: PatchAccountKeyRequestDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletAccountKeyUsingPATCH(patchAccountKeyRequestDTO, walletId, accountId, needOTP, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchMasterWalletName
     * @param {PatchWalletNameRequestDTO} patchWalletNameRequestDTO patchWalletNameRequestDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO: PatchWalletNameRequestDTO, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletNameUsingPATCH(patchWalletNameRequestDTO, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary patchWalletWithdrawalPolicy
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest patchWithdrawalPolicyRequest
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, walletId: string, accountId?: string, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicyUsingPATCH(patchWithdrawalPolicyRequest, walletId, accountId, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary sendTransaction
     * @param {CreateTransactionDTO} createTransactionDTO createTransactionDTO
     * @param {string} walletId walletId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransactionUsingPOST(createTransactionDTO: CreateTransactionDTO, walletId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransactionUsingPOST(createTransactionDTO, walletId, accountId, needOTP, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

}

/**
 * WebMvcLinksHandlerApi - fetch parameter creator
 * @export
 */
export const WebMvcLinksHandlerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/actuator`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - functional programming interface
 * @export
 */
export const WebMvcLinksHandlerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: { [key: string]: Link; }; }> {
            const localVarFetchArgs = WebMvcLinksHandlerApiFetchParamCreator(configuration).linksUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebMvcLinksHandlerApi - factory interface
 * @export
 */
export const WebMvcLinksHandlerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary links
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linksUsingGET(options?: any) {
            return WebMvcLinksHandlerApiFp(configuration).linksUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * WebMvcLinksHandlerApi - object-oriented interface
 * @export
 * @class WebMvcLinksHandlerApi
 * @extends {BaseAPI}
 */
export class WebMvcLinksHandlerApi extends BaseAPI {
    /**
     * 
     * @summary links
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMvcLinksHandlerApi
     */
    public linksUsingGET(options?: any) {
        return WebMvcLinksHandlerApiFp(this.configuration).linksUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * WithdrawalApprovalControllerApi - fetch parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApprovalUsingPOST.');
            }
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(needOTP || {}) : (needOTP || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApprovalUsingPOST.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (otpKey !== undefined) {
                localVarQueryParameter['otpKey'] = otpKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(needOTP || {}) : (needOTP || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WithdrawalApprovalControllerApiFetchParamCreator(configuration).rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary approveWithdrawalApproval
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary rejectWithdrawalApproval
         * @param {string} withdrawalApprovalId withdrawalApprovalId
         * @param {string} [accountId] 
         * @param {boolean} [needOTP] needOTP
         * @param {string} [organizationId] 
         * @param {string} [otpKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
            return WithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options)(fetch, basePath);
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @summary approveWithdrawalApproval
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest approveWithdrawalApprovalRequest
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApprovalUsingPOST(approveWithdrawalApprovalRequest, withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary rejectWithdrawalApproval
     * @param {string} withdrawalApprovalId withdrawalApprovalId
     * @param {string} [accountId] 
     * @param {boolean} [needOTP] needOTP
     * @param {string} [organizationId] 
     * @param {string} [otpKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId: string, accountId?: string, needOTP?: boolean, organizationId?: string, otpKey?: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApprovalUsingPOST(withdrawalApprovalId, accountId, needOTP, organizationId, otpKey, options)(this.fetch, this.basePath);
    }

}

