// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountKeyDTO
 */
export interface AccountKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    chainCode: string;
}
/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface BackupKeyDTO
 */
export interface BackupKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof BackupKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof BackupKeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    pub: string;
    /**
     * 
     * @type {number}
     * @memberof CreateDepositAddressRequest
     */
    childNumber: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    amount: string;
    /**
     * 
     * @type {Amount}
     * @memberof CreateTransactionRequest
     */
    proposalGasPremium?: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof CreateTransactionRequest
     */
    proposalGasLimit?: Amount;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {RawSignedTransactionDTO}
     * @memberof CreateTransactionRequest
     */
    proposalTransaction: RawSignedTransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasPremium?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {AccountKeyDTO}
     * @memberof CreateWalletRequest
     */
    accountKey: AccountKeyDTO;
    /**
     * 
     * @type {BackupKeyDTO}
     * @memberof CreateWalletRequest
     */
    backupKey: BackupKeyDTO;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    orgId: string;
    /**
     * 
     * @type {number}
     * @memberof DepositAddressDTO
     */
    childNumber: number;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface FeeHistoryDTO
 */
export interface FeeHistoryDTO {
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    id: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof FeeHistoryDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FeeWalletBalanceDTO
 */
export interface FeeWalletBalanceDTO {
    /**
     * 
     * @type {BalanceDTO}
     * @memberof FeeWalletBalanceDTO
     */
    defaultFeeWallet: BalanceDTO;
    /**
     * 
     * @type {Array<ProposalFeeWalletBalanceDTO>}
     * @memberof FeeWalletBalanceDTO
     */
    proposalFeeWallets: Array<ProposalFeeWalletBalanceDTO>;
}
/**
 * 
 * @export
 * @interface FeeWalletDTO
 */
export interface FeeWalletDTO {
    /**
     * 
     * @type {HenesisKeyDTO}
     * @memberof FeeWalletDTO
     */
    defaultFeeWallet: HenesisKeyDTO;
    /**
     * 
     * @type {Array<AccountKeyDTO>}
     * @memberof FeeWalletDTO
     */
    proposalFeeWallets: Array<AccountKeyDTO>;
}
/**
 * 
 * @export
 * @interface FlushDTO
 */
export interface FlushDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof FlushDTO
     */
    transfers: Array<TransferDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushInternalDTO
 */
export interface FlushInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof FlushInternalDTO
     */
    transfers: Array<TransferInternalDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushRequest
 */
export interface FlushRequest {
    /**
     * 
     * @type {Array<FlushTarget>}
     * @memberof FlushRequest
     */
    targets: Array<FlushTarget>;
}
/**
 * 
 * @export
 * @interface FlushTarget
 */
export interface FlushTarget {
    /**
     * 
     * @type {string}
     * @memberof FlushTarget
     */
    depositAddressId: string;
    /**
     * 
     * @type {RawSignedTransactionDTO}
     * @memberof FlushTarget
     */
    flushTransaction: RawSignedTransactionDTO;
}
/**
 * 
 * @export
 * @interface GasPremiumDTO
 */
export interface GasPremiumDTO {
    /**
     * 
     * @type {string}
     * @memberof GasPremiumDTO
     */
    gasPremium: string;
}
/**
 * 
 * @export
 * @interface GetGasPremiumRequest
 */
export interface GetGasPremiumRequest {
    /**
     * 
     * @type {number}
     * @memberof GetGasPremiumRequest
     */
    nBlocksInclude: number;
    /**
     * 
     * @type {string}
     * @memberof GetGasPremiumRequest
     */
    senderAddress: string;
    /**
     * 
     * @type {string}
     * @memberof GetGasPremiumRequest
     */
    gasLimit: string;
}
/**
 * 
 * @export
 * @interface HenesisKeyDTO
 */
export interface HenesisKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    keyId: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFeeHistoryDTO
 */
export interface PaginationFeeHistoryDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFeeHistoryDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FeeHistoryDTO>}
     * @memberof PaginationFeeHistoryDTO
     */
    results: Array<FeeHistoryDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushDTO
 */
export interface PaginationFlushDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushDTO>}
     * @memberof PaginationFlushDTO
     */
    results: Array<FlushDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushInternalDTO
 */
export interface PaginationFlushInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushInternalDTO>}
     * @memberof PaginationFlushInternalDTO
     */
    results: Array<FlushInternalDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferInternalDTO
 */
export interface PaginationTransferInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof PaginationTransferInternalDTO
     */
    results: Array<TransferInternalDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    chainCode: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProposalFeeWalletBalanceDTO
 */
export interface ProposalFeeWalletBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletBalanceDTO
     */
    id: string;
    /**
     * 
     * @type {BalanceDTO}
     * @memberof ProposalFeeWalletBalanceDTO
     */
    balance: BalanceDTO;
}
/**
 * 
 * @export
 * @interface RawSignedTransactionDTO
 */
export interface RawSignedTransactionDTO {
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    version: number;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    value: string;
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    signature: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasLimit: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasFeeCap: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasPremium: string;
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    signatureType: number;
}
/**
 * 
 * @export
 * @interface SimplifiedWalletInternalDTO
 */
export interface SimplifiedWalletInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferDTO
     */
    type: TransferType;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    toAddress: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferInternalDTO
 */
export interface TransferInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferInternalDTO
     */
    type: TransferType;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferInternalDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    walletId: string;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    fromAddress: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    toAddress: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferStatus {
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    MINED = 'MINED',
    REVERTED = 'REVERTED',
    CONFIRMED = 'CONFIRMED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @interface WalletDTO
 */
export interface WalletDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    address: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof WalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {AccountKeyDTO}
     * @memberof WalletDTO
     */
    accountKey: AccountKeyDTO;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    INACTIVE = 'INACTIVE',
    ACTIVE = 'ACTIVE',
    CREATING = 'CREATING',
    FAILED = 'FAILED'
}


/**
 * FeeWalletControllerApi - axios parameter creator
 * @export
 */
export const FeeWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFeeHistories.');
            }
            const localVarPath = `/api/v2/fil/fee-wallets/histories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeWalletControllerApi - functional programming interface
 * @export
 */
export const FeeWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeHistories(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFeeHistoryDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeHistories(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWallet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWallet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWalletBalance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletBalanceDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWalletBalance(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FeeWalletControllerApi - factory interface
 * @export
 */
export const FeeWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories(pageable: Pageable, options?: any): AxiosPromise<PaginationFeeHistoryDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeHistories(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet(options?: any): AxiosPromise<FeeWalletDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance(options?: any): AxiosPromise<FeeWalletBalanceDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWalletBalance(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeWalletControllerApi - object-oriented interface
 * @export
 * @class FeeWalletControllerApi
 * @extends {BaseAPI}
 */
export class FeeWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeHistories(pageable: Pageable, options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeHistories(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWallet(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWalletBalance(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWalletBalance(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalControllerApi - axios parameter creator
 * @export
 */
export const InternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush: async (flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes/{flushId}`
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes1.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer1.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalControllerApi - functional programming interface
 * @export
 */
export const InternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush(flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlush(flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlushes1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer1(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfer1(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfers(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalControllerApi - factory interface
 * @export
 */
export const InternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush(flushId: string, options?: any): AxiosPromise<FlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlush(flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1(pageable: Pageable, options?: any): AxiosPromise<PaginationFlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlushes1(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfer1(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(pageable: Pageable, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfers(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalControllerApi - object-oriented interface
 * @export
 * @class InternalControllerApi
 * @extends {BaseAPI}
 */
export class InternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlush(flushId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlush(flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlushes1(pageable: Pageable, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlushes1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfer1(transferId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfer1(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfers(pageable: Pageable, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfers(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkControllerApi - axios parameter creator
 * @export
 */
export const NetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPremium: async (getGasPremiumRequest: GetGasPremiumRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getGasPremiumRequest' is not null or undefined
            if (getGasPremiumRequest === null || getGasPremiumRequest === undefined) {
                throw new RequiredError('getGasPremiumRequest','Required parameter getGasPremiumRequest was null or undefined when calling getGasPremium.');
            }
            const localVarPath = `/api/v2/fil/network/gas-premium`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getGasPremiumRequest !== undefined) {
                localVarQueryParameter['getGasPremiumRequest'] = getGasPremiumRequest;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkControllerApi - functional programming interface
 * @export
 */
export const NetworkControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasPremiumDTO>> {
            const localVarAxiosArgs = await NetworkControllerApiAxiosParamCreator(configuration).getGasPremium(getGasPremiumRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkControllerApi - factory interface
 * @export
 */
export const NetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any): AxiosPromise<GasPremiumDTO> {
            return NetworkControllerApiFp(configuration).getGasPremium(getGasPremiumRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkControllerApi - object-oriented interface
 * @export
 * @class NetworkControllerApi
 * @extends {BaseAPI}
 */
export class NetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetGasPremiumRequest} getGasPremiumRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkControllerApi
     */
    public getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any) {
        return NetworkControllerApiFp(this.configuration).getGasPremium(getGasPremiumRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OperationControllerApi - axios parameter creator
 * @export
 */
export const OperationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey.');
            }
            const localVarPath = `/api/v2/fil/operation/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationControllerApi - functional programming interface
 * @export
 */
export const OperationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).createHenesisKey(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperationControllerApi - factory interface
 * @export
 */
export const OperationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<HenesisKeyDTO> {
            return OperationControllerApiFp(configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationControllerApi - object-oriented interface
 * @export
 * @class OperationControllerApi
 * @extends {BaseAPI}
 */
export class OperationControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/fil/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers1.');
            }
            const localVarPath = `/api/v2/fil/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1(pageable: Pageable, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers1(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer(transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers1(pageable: Pageable, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (createWalletRequest: CreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWalletRequest' is not null or undefined
            if (createWalletRequest === null || createWalletRequest === undefined) {
                throw new RequiredError('createWalletRequest','Required parameter createWalletRequest was null or undefined when calling createWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWalletRequest !== undefined ? createWalletRequest : {}) : (createWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush: async (walletId: string, flushRequest: FlushRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling flush.');
            }
            // verify required parameter 'flushRequest' is not null or undefined
            if (flushRequest === null || flushRequest === undefined) {
                throw new RequiredError('flushRequest','Required parameter flushRequest was null or undefined when calling flush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof flushRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(flushRequest !== undefined ? flushRequest : {}) : (flushRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1: async (walletId: string, flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlush1.');
            }
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush1.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes/{flushId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlushes.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletInitialKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletInitialKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets: async (sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getWallets.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName: async (walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchDepositAddressName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletAccountKey: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletAccountKey.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchWalletAccountKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletName: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchWalletName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling recreateWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(createWalletRequest: CreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createWallet(createWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flush(walletId: string, flushRequest: FlushRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).flush(walletId, flushRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush1(walletId: string, flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlush1(walletId, flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlushes(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletInitialKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletInitialKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallets(sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWallets(sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletName(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recreateWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).recreateWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(createWalletRequest: CreateWalletRequest, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).createWallet(createWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush(walletId: string, flushRequest: FlushRequest, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).flush(walletId, flushRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1(walletId: string, flushId: string, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).getFlush1(walletId, flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationFlushDTO> {
            return WalletControllerApiFp(configuration).getFlushes(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId: string, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletInitialKey(walletId: string, options?: any): AxiosPromise<AccountKeyDTO> {
            return WalletControllerApiFp(configuration).getWalletInitialKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets(sort: Sort, options?: any): AxiosPromise<Array<WalletDTO>> {
            return WalletControllerApiFp(configuration).getWallets(sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<AccountKeyDTO> {
            return WalletControllerApiFp(configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).patchWalletName(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateWallet(walletId: string, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).recreateWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWalletRequest} createWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWallet(createWalletRequest: CreateWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {FlushRequest} flushRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public flush(walletId: string, flushRequest: FlushRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).flush(walletId, flushRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlush1(walletId: string, flushId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlush1(walletId, flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlushes(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlushes(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletInitialKey(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletInitialKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWallets(sort: Sort, options?: any) {
        return WalletControllerApiFp(this.configuration).getWallets(sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletName(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public recreateWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).recreateWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


