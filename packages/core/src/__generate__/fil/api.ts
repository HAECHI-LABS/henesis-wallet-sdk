// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountKeyDTO
 */
export interface AccountKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    keyFile?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountKeyDTO
     */
    chainCode: string;
}
/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface BackupKeyDTO
 */
export interface BackupKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof BackupKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof BackupKeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    confirmedBalance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @interface BalanceWithIdDTO
 */
export interface BalanceWithIdDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceWithIdDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceWithIdDTO
     */
    confirmedBalance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceWithIdDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @interface BuildFlushRequest
 */
export interface BuildFlushRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BuildFlushRequest
     */
    depositAddressIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BuildFlushRequest
     */
    gasPremium?: string;
}
/**
 * 
 * @export
 * @interface BuildTransactionRequest
 */
export interface BuildTransactionRequest {
    /**
     * 
     * @type {number}
     * @memberof BuildTransactionRequest
     */
    version: number;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    value: string;
    /**
     * 
     * @type {number}
     * @memberof BuildTransactionRequest
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    gasLimit: string;
    /**
     * 
     * @type {string}
     * @memberof BuildTransactionRequest
     */
    gasPremium?: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    pub: string;
    /**
     * 
     * @type {number}
     * @memberof CreateDepositAddressRequest
     */
    childNumber: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateFlushRequest
 */
export interface CreateFlushRequest {
    /**
     * 
     * @type {Array<FlushTarget>}
     * @memberof CreateFlushRequest
     */
    targets: Array<FlushTarget>;
}
/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    amount: string;
    /**
     * 
     * @type {Amount}
     * @memberof CreateTransactionRequest
     */
    proposalGasPremium?: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof CreateTransactionRequest
     */
    proposalGasLimit?: Amount;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    proposalNonce?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {RawSignedTransactionDTO}
     * @memberof CreateTransactionRequest
     */
    proposalTransaction: RawSignedTransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    gasPremium?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {AccountKeyDTO}
     * @memberof CreateWalletRequest
     */
    accountKey: AccountKeyDTO;
    /**
     * 
     * @type {BackupKeyDTO}
     * @memberof CreateWalletRequest
     */
    backupKey: BackupKeyDTO;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    orgId: string;
    /**
     * 
     * @type {number}
     * @memberof DepositAddressDTO
     */
    childNumber: number;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface DepositAddressSearchCondition
 */
export interface DepositAddressSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressSearchCondition
     */
    id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DepositAddressSearchCondition
     */
    ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressSearchCondition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressSearchCondition
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressSearchCondition
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressSearchCondition
     */
    orgId?: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface FeeHistoryDTO
 */
export interface FeeHistoryDTO {
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    id: string;
    /**
     * 
     * @type {SimplifiedWalletDTO}
     * @memberof FeeHistoryDTO
     */
    wallet: SimplifiedWalletDTO;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof FeeHistoryDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {FeeHistoryPaymentType}
     * @memberof FeeHistoryDTO
     */
    paymentType: FeeHistoryPaymentType;
    /**
     * 
     * @type {FeeHistoryType}
     * @memberof FeeHistoryDTO
     */
    type: FeeHistoryType;
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FeeHistoryPaymentType {
    DEFAULTFEEWALLET = 'DEFAULT_FEE_WALLET',
    PROPOSALFEEWALLET = 'PROPOSAL_FEE_WALLET',
    DEPOSITADDRESS = 'DEPOSIT_ADDRESS'
}

/**
 * 
 * @export
 * @interface FeeHistorySearchCondition
 */
export interface FeeHistorySearchCondition {
    /**
     * 
     * @type {string}
     * @memberof FeeHistorySearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeHistorySearchCondition
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeHistorySearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeHistorySearchCondition
     */
    createdAtLt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FeeHistoryType {
    WITHDRAWAL = 'WITHDRAWAL',
    FLUSH = 'FLUSH',
    WALLETDEPLOYMENT = 'WALLET_DEPLOYMENT'
}

/**
 * 
 * @export
 * @interface FeeWalletBalanceDTO
 */
export interface FeeWalletBalanceDTO {
    /**
     * 
     * @type {BalanceDTO}
     * @memberof FeeWalletBalanceDTO
     */
    defaultFeeWallet: BalanceDTO;
    /**
     * 
     * @type {Array<BalanceWithIdDTO>}
     * @memberof FeeWalletBalanceDTO
     */
    proposalFeeWallets: Array<BalanceWithIdDTO>;
}
/**
 * 
 * @export
 * @interface FeeWalletDTO
 */
export interface FeeWalletDTO {
    /**
     * 
     * @type {HenesisKeyDTO}
     * @memberof FeeWalletDTO
     */
    defaultFeeWallet: HenesisKeyDTO;
    /**
     * 
     * @type {Array<ProposalFeeWalletDTO>}
     * @memberof FeeWalletDTO
     */
    proposalFeeWallets: Array<ProposalFeeWalletDTO>;
}
/**
 * 
 * @export
 * @interface FlushDTO
 */
export interface FlushDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof FlushDTO
     */
    transfers: Array<TransferDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushInternalDTO
 */
export interface FlushInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof FlushInternalDTO
     */
    transfers: Array<TransferInternalDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushTarget
 */
export interface FlushTarget {
    /**
     * 
     * @type {string}
     * @memberof FlushTarget
     */
    depositAddressId: string;
    /**
     * 
     * @type {RawSignedTransactionDTO}
     * @memberof FlushTarget
     */
    flushTransaction: RawSignedTransactionDTO;
}
/**
 * 
 * @export
 * @interface GasPremiumDTO
 */
export interface GasPremiumDTO {
    /**
     * 
     * @type {string}
     * @memberof GasPremiumDTO
     */
    gasPremium: string;
}
/**
 * 
 * @export
 * @interface GetGasPremiumRequest
 */
export interface GetGasPremiumRequest {
    /**
     * 
     * @type {number}
     * @memberof GetGasPremiumRequest
     */
    nBlocksInclude: number;
    /**
     * 
     * @type {string}
     * @memberof GetGasPremiumRequest
     */
    senderAddress: string;
    /**
     * 
     * @type {string}
     * @memberof GetGasPremiumRequest
     */
    gasLimit: string;
}
/**
 * 
 * @export
 * @interface HenesisKeyDTO
 */
export interface HenesisKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    pub: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFeeHistoryDTO
 */
export interface PaginationFeeHistoryDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFeeHistoryDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FeeHistoryDTO>}
     * @memberof PaginationFeeHistoryDTO
     */
    results: Array<FeeHistoryDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushDTO
 */
export interface PaginationFlushDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushDTO>}
     * @memberof PaginationFlushDTO
     */
    results: Array<FlushDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushInternalDTO
 */
export interface PaginationFlushInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushInternalDTO>}
     * @memberof PaginationFlushInternalDTO
     */
    results: Array<FlushInternalDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferInternalDTO
 */
export interface PaginationTransferInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof PaginationTransferInternalDTO
     */
    results: Array<TransferInternalDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProposalFeeWalletDTO
 */
export interface ProposalFeeWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletDTO
     */
    keyFile?: string;
    /**
     * 
     * @type {string}
     * @memberof ProposalFeeWalletDTO
     */
    chainCode: string;
}
/**
 * 
 * @export
 * @interface RawFlushDTO
 */
export interface RawFlushDTO {
    /**
     * 
     * @type {Array<RawFlushTransactionDTO>}
     * @memberof RawFlushDTO
     */
    targets: Array<RawFlushTransactionDTO>;
}
/**
 * 
 * @export
 * @interface RawFlushTransactionDTO
 */
export interface RawFlushTransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof RawFlushTransactionDTO
     */
    depositAddressId: string;
    /**
     * 
     * @type {number}
     * @memberof RawFlushTransactionDTO
     */
    childNumber: number;
    /**
     * 
     * @type {RawTransactionDTO}
     * @memberof RawFlushTransactionDTO
     */
    rawTransaction: RawTransactionDTO;
}
/**
 * 
 * @export
 * @interface RawSignedTransactionDTO
 */
export interface RawSignedTransactionDTO {
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    version: number;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    value: string;
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    cid: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    signature: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasLimit: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasFeeCap: string;
    /**
     * 
     * @type {string}
     * @memberof RawSignedTransactionDTO
     */
    gasPremium: string;
    /**
     * 
     * @type {number}
     * @memberof RawSignedTransactionDTO
     */
    signatureType: number;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {number}
     * @memberof RawTransactionDTO
     */
    version: number;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    value: string;
    /**
     * 
     * @type {number}
     * @memberof RawTransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasLimit: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasFeeCap: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionDTO
     */
    gasPremium: string;
}
/**
 * 
 * @export
 * @interface SimplifiedWalletDTO
 */
export interface SimplifiedWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletDTO
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferInternalDTO
 */
export interface TransferInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferInternalDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferInternalDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    confirmation: string;
    /**
     * 
     * @type {SimplifiedWalletDTO}
     * @memberof TransferInternalDTO
     */
    fromAddress: SimplifiedWalletDTO;
    /**
     * 
     * @type {SimplifiedWalletDTO}
     * @memberof TransferInternalDTO
     */
    toAddress: SimplifiedWalletDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferSearchCondition
 */
export interface TransferSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    fromAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    toAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    transactionHash?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    transferType?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtLt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferStatus {
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    MINED = 'MINED',
    REVERTED = 'REVERTED',
    CONFIRMED = 'CONFIRMED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @interface WalletBalanceDTO
 */
export interface WalletBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceDTO
     */
    confirmedBalance: string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceDTO
     */
    spendableBalance: string;
    /**
     * 
     * @type {string}
     * @memberof WalletBalanceDTO
     */
    aggregatedBalance: string;
}
/**
 * 
 * @export
 * @interface WalletDTO
 */
export interface WalletDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    address: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof WalletDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {WalletStatus}
     * @memberof WalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    confirmation?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {number}
     * @memberof WalletDTO
     */
    nextChildNumber: number;
    /**
     * 
     * @type {AccountKeyDTO}
     * @memberof WalletDTO
     */
    accountKey: AccountKeyDTO;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface WalletSearchCondition
 */
export interface WalletSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    orgId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    INACTIVE = 'INACTIVE',
    ACTIVE = 'ACTIVE',
    CREATING = 'CREATING',
    FAILED = 'FAILED'
}


/**
 * FeeWalletControllerApi - axios parameter creator
 * @export
 */
export const FeeWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {FeeHistorySearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories: async (pageable: Pageable, condition: FeeHistorySearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFeeHistories.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getFeeHistories.');
            }
            const localVarPath = `/api/v2/fil/fee-wallets/histories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} historyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistory: async (historyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'historyId' is not null or undefined
            if (historyId === null || historyId === undefined) {
                throw new RequiredError('historyId','Required parameter historyId was null or undefined when calling getFeeHistory.');
            }
            const localVarPath = `/api/v2/fil/fee-wallets/histories/{historyId}`
                .replace(`{${"historyId"}}`, encodeURIComponent(String(historyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeWalletControllerApi - functional programming interface
 * @export
 */
export const FeeWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {FeeHistorySearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeHistories(pageable: Pageable, condition: FeeHistorySearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFeeHistoryDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeHistories(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} historyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeHistory(historyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeHistoryDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeHistory(historyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWallet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWallet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWalletBalance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletBalanceDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWalletBalance(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FeeWalletControllerApi - factory interface
 * @export
 */
export const FeeWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {FeeHistorySearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories(pageable: Pageable, condition: FeeHistorySearchCondition, options?: any): AxiosPromise<PaginationFeeHistoryDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeHistories(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} historyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistory(historyId: string, options?: any): AxiosPromise<FeeHistoryDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeHistory(historyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet(options?: any): AxiosPromise<FeeWalletDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance(options?: any): AxiosPromise<FeeWalletBalanceDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWalletBalance(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeWalletControllerApi - object-oriented interface
 * @export
 * @class FeeWalletControllerApi
 * @extends {BaseAPI}
 */
export class FeeWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {FeeHistorySearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeHistories(pageable: Pageable, condition: FeeHistorySearchCondition, options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeHistories(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} historyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeHistory(historyId: string, options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeHistory(historyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWallet(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWalletBalance(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWalletBalance(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalControllerApi - axios parameter creator
 * @export
 */
export const InternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1: async (flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush1.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes/{flushId}`
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (pageable: Pageable, transferSearchCondition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            // verify required parameter 'transferSearchCondition' is not null or undefined
            if (transferSearchCondition === null || transferSearchCondition === undefined) {
                throw new RequiredError('transferSearchCondition','Required parameter transferSearchCondition was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (transferSearchCondition !== undefined) {
                localVarQueryParameter['transferSearchCondition'] = transferSearchCondition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalControllerApi - functional programming interface
 * @export
 */
export const InternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush1(flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlush1(flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlushes(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfer(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfers(pageable, transferSearchCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalControllerApi - factory interface
 * @export
 */
export const InternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1(flushId: string, options?: any): AxiosPromise<FlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlush1(flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes(pageable: Pageable, options?: any): AxiosPromise<PaginationFlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlushes(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfer(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfers(pageable, transferSearchCondition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalControllerApi - object-oriented interface
 * @export
 * @class InternalControllerApi
 * @extends {BaseAPI}
 */
export class InternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlush1(flushId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlush1(flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlushes(pageable: Pageable, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlushes(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfer(transferId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfer(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} transferSearchCondition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfers(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfers(pageable, transferSearchCondition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkControllerApi - axios parameter creator
 * @export
 */
export const NetworkControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPremium: async (getGasPremiumRequest: GetGasPremiumRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getGasPremiumRequest' is not null or undefined
            if (getGasPremiumRequest === null || getGasPremiumRequest === undefined) {
                throw new RequiredError('getGasPremiumRequest','Required parameter getGasPremiumRequest was null or undefined when calling getGasPremium.');
            }
            const localVarPath = `/api/v2/fil/network/gas-premium`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getGasPremiumRequest !== undefined) {
                localVarQueryParameter['getGasPremiumRequest'] = getGasPremiumRequest;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkControllerApi - functional programming interface
 * @export
 */
export const NetworkControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasPremiumDTO>> {
            const localVarAxiosArgs = await NetworkControllerApiAxiosParamCreator(configuration).getGasPremium(getGasPremiumRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkControllerApi - factory interface
 * @export
 */
export const NetworkControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {GetGasPremiumRequest} getGasPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any): AxiosPromise<GasPremiumDTO> {
            return NetworkControllerApiFp(configuration).getGasPremium(getGasPremiumRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkControllerApi - object-oriented interface
 * @export
 * @class NetworkControllerApi
 * @extends {BaseAPI}
 */
export class NetworkControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetGasPremiumRequest} getGasPremiumRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkControllerApi
     */
    public getGasPremium(getGasPremiumRequest: GetGasPremiumRequest, options?: any) {
        return NetworkControllerApiFp(this.configuration).getGasPremium(getGasPremiumRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OperationControllerApi - axios parameter creator
 * @export
 */
export const OperationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey.');
            }
            const localVarPath = `/api/v2/fil/operation/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationControllerApi - functional programming interface
 * @export
 */
export const OperationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).createHenesisKey(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperationControllerApi - factory interface
 * @export
 */
export const OperationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<HenesisKeyDTO> {
            return OperationControllerApiFp(configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationControllerApi - object-oriented interface
 * @export
 * @class OperationControllerApi
 * @extends {BaseAPI}
 */
export class OperationControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer1.');
            }
            const localVarPath = `/api/v2/fil/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1: async (pageable: Pageable, transferSearchCondition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers1.');
            }
            // verify required parameter 'transferSearchCondition' is not null or undefined
            if (transferSearchCondition === null || transferSearchCondition === undefined) {
                throw new RequiredError('transferSearchCondition','Required parameter transferSearchCondition was null or undefined when calling getTransfers1.');
            }
            const localVarPath = `/api/v2/fil/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (transferSearchCondition !== undefined) {
                localVarQueryParameter['transferSearchCondition'] = transferSearchCondition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer1(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer1(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers1(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers1(pageable, transferSearchCondition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer1(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} transferSearchCondition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers1(pageable, transferSearchCondition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer1(transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer1(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} transferSearchCondition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers1(pageable: Pageable, transferSearchCondition: TransferSearchCondition, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers1(pageable, transferSearchCondition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {BuildFlushRequest} buildFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFlush: async (walletId: string, buildFlushRequest: BuildFlushRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling buildFlush.');
            }
            // verify required parameter 'buildFlushRequest' is not null or undefined
            if (buildFlushRequest === null || buildFlushRequest === undefined) {
                throw new RequiredError('buildFlushRequest','Required parameter buildFlushRequest was null or undefined when calling buildFlush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes/build`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof buildFlushRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(buildFlushRequest !== undefined ? buildFlushRequest : {}) : (buildFlushRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {BuildTransactionRequest} buildTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransaction: async (walletId: string, buildTransactionRequest: BuildTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling buildTransaction.');
            }
            // verify required parameter 'buildTransactionRequest' is not null or undefined
            if (buildTransactionRequest === null || buildTransactionRequest === undefined) {
                throw new RequiredError('buildTransactionRequest','Required parameter buildTransactionRequest was null or undefined when calling buildTransaction.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/transactions/build`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof buildTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(buildTransactionRequest !== undefined ? buildTransactionRequest : {}) : (buildTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (createWalletRequest: CreateWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWalletRequest' is not null or undefined
            if (createWalletRequest === null || createWalletRequest === undefined) {
                throw new RequiredError('createWalletRequest','Required parameter createWalletRequest was null or undefined when calling createWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWalletRequest !== undefined ? createWalletRequest : {}) : (createWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateFlushRequest} createFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush: async (walletId: string, createFlushRequest: CreateFlushRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling flush.');
            }
            // verify required parameter 'createFlushRequest' is not null or undefined
            if (createFlushRequest === null || createFlushRequest === undefined) {
                throw new RequiredError('createFlushRequest','Required parameter createFlushRequest was null or undefined when calling flush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createFlushRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createFlushRequest !== undefined ? createFlushRequest : {}) : (createFlushRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWallets: async (sort: Sort, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getAllWallets.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getAllWallets.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressBalance: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddressBalance.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddressBalance.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {DepositAddressSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (walletId: string, pageable: Pageable, condition: DepositAddressSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressesBalance: async (walletId: string, ids: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddressesBalance.');
            }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling getDepositAddressesBalance.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush: async (walletId: string, flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlush.');
            }
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes/{flushId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlushes1.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes1.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletInitialAccountKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletInitialAccountKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName: async (walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchDepositAddressName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletAccountKey: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletAccountKey.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchWalletAccountKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletName: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchWalletName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling recreateWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {BuildFlushRequest} buildFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildFlush(walletId: string, buildFlushRequest: BuildFlushRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawFlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).buildFlush(walletId, buildFlushRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {BuildTransactionRequest} buildTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransaction(walletId: string, buildTransactionRequest: BuildTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).buildTransaction(walletId, buildTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(createWalletRequest: CreateWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createWallet(createWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateFlushRequest} createFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flush(walletId: string, createFlushRequest: CreateFlushRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).flush(walletId, createFlushRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWallets(sort: Sort, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllWallets(sort, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletBalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddressBalance(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddressBalance(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {DepositAddressSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(walletId: string, pageable: Pageable, condition: DepositAddressSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(walletId, pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddressesBalance(walletId: string, ids: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceWithIdDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddressesBalance(walletId, ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush(walletId: string, flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlush(walletId, flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes1(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlushes1(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletInitialAccountKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletInitialAccountKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountKeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletName(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recreateWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).recreateWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {BuildFlushRequest} buildFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFlush(walletId: string, buildFlushRequest: BuildFlushRequest, options?: any): AxiosPromise<RawFlushDTO> {
            return WalletControllerApiFp(configuration).buildFlush(walletId, buildFlushRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {BuildTransactionRequest} buildTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransaction(walletId: string, buildTransactionRequest: BuildTransactionRequest, options?: any): AxiosPromise<RawTransactionDTO> {
            return WalletControllerApiFp(configuration).buildTransaction(walletId, buildTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWalletRequest} createWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(createWalletRequest: CreateWalletRequest, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).createWallet(createWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateFlushRequest} createFlushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush(walletId: string, createFlushRequest: CreateFlushRequest, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).flush(walletId, createFlushRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWallets(sort: Sort, condition: WalletSearchCondition, options?: any): AxiosPromise<Array<WalletDTO>> {
            return WalletControllerApiFp(configuration).getAllWallets(sort, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(walletId: string, options?: any): AxiosPromise<WalletBalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressBalance(walletId: string, depositAddressId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getDepositAddressBalance(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {DepositAddressSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(walletId: string, pageable: Pageable, condition: DepositAddressSearchCondition, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddressesBalance(walletId: string, ids: Array<string>, options?: any): AxiosPromise<Array<BalanceWithIdDTO>> {
            return WalletControllerApiFp(configuration).getDepositAddressesBalance(walletId, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush(walletId: string, flushId: string, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).getFlush(walletId, flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationFlushDTO> {
            return WalletControllerApiFp(configuration).getFlushes1(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId: string, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletInitialAccountKey(walletId: string, options?: any): AxiosPromise<AccountKeyDTO> {
            return WalletControllerApiFp(configuration).getWalletInitialAccountKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<AccountKeyDTO> {
            return WalletControllerApiFp(configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).patchWalletName(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateWallet(walletId: string, options?: any): AxiosPromise<WalletDTO> {
            return WalletControllerApiFp(configuration).recreateWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {BuildFlushRequest} buildFlushRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public buildFlush(walletId: string, buildFlushRequest: BuildFlushRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).buildFlush(walletId, buildFlushRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {BuildTransactionRequest} buildTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public buildTransaction(walletId: string, buildTransactionRequest: BuildTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).buildTransaction(walletId, buildTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWalletRequest} createWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWallet(createWalletRequest: CreateWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateFlushRequest} createFlushRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public flush(walletId: string, createFlushRequest: CreateFlushRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).flush(walletId, createFlushRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllWallets(sort: Sort, condition: WalletSearchCondition, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllWallets(sort, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddressBalance(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddressBalance(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {DepositAddressSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses(walletId: string, pageable: Pageable, condition: DepositAddressSearchCondition, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddressesBalance(walletId: string, ids: Array<string>, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddressesBalance(walletId, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlush(walletId: string, flushId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlush(walletId, flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlushes1(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlushes1(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletInitialAccountKey(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletInitialAccountKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletName(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public recreateWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).recreateWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


