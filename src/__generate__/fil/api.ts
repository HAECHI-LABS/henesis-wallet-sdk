// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateHenesisKeyRequest
 */
export interface CreateHenesisKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHenesisKeyRequest
     */
    orgId: string;
}
/**
 * 
 * @export
 * @interface CreateMasterWalletRequest
 */
export interface CreateMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMasterWalletRequest
     */
    encryptionKey: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateMasterWalletRequest
     */
    backupKey: KeyDTO;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    proposalTransactionHex: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    orgId: string;
    /**
     * 
     * @type {number}
     * @memberof DepositAddressDTO
     */
    childNumber: number;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface FeeHistoryDTO
 */
export interface FeeHistoryDTO {
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    id: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof FeeHistoryDTO
     */
    transaction: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof FeeHistoryDTO
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FeeWalletBalanceDTO
 */
export interface FeeWalletBalanceDTO {
    /**
     * 
     * @type {BalanceDTO}
     * @memberof FeeWalletBalanceDTO
     */
    defaultWallet: BalanceDTO;
    /**
     * 
     * @type {Array<ProposalWalletBalanceDTO>}
     * @memberof FeeWalletBalanceDTO
     */
    proposalWallets: Array<ProposalWalletBalanceDTO>;
}
/**
 * 
 * @export
 * @interface FeeWalletDTO
 */
export interface FeeWalletDTO {
    /**
     * 
     * @type {HenesisKeyDTO}
     * @memberof FeeWalletDTO
     */
    defaultWallet: HenesisKeyDTO;
    /**
     * 
     * @type {Array<KeyDTO>}
     * @memberof FeeWalletDTO
     */
    proposalWallets: Array<KeyDTO>;
}
/**
 * 
 * @export
 * @interface FlushDTO
 */
export interface FlushDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof FlushDTO
     */
    transfers: Array<TransferDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushInternalDTO
 */
export interface FlushInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    id: string;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof FlushInternalDTO
     */
    transfers: Array<TransferInternalDTO>;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof FlushInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface FlushRequest
 */
export interface FlushRequest {
    /**
     * 
     * @type {Array<FlushTarget>}
     * @memberof FlushRequest
     */
    targets: Array<FlushTarget>;
}
/**
 * 
 * @export
 * @interface FlushTarget
 */
export interface FlushTarget {
    /**
     * 
     * @type {string}
     * @memberof FlushTarget
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof FlushTarget
     */
    depositAddressId: string;
    /**
     * 
     * @type {string}
     * @memberof FlushTarget
     */
    flushTransactionHex: string;
}
/**
 * 
 * @export
 * @interface HenesisKeyDTO
 */
export interface HenesisKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof HenesisKeyDTO
     */
    keyId: string;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof MasterWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFeeHistoryDTO
 */
export interface PaginationFeeHistoryDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFeeHistoryDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FeeHistoryDTO>}
     * @memberof PaginationFeeHistoryDTO
     */
    results: Array<FeeHistoryDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushDTO
 */
export interface PaginationFlushDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushDTO>}
     * @memberof PaginationFlushDTO
     */
    results: Array<FlushDTO>;
}
/**
 * 
 * @export
 * @interface PaginationFlushInternalDTO
 */
export interface PaginationFlushInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationFlushInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<FlushInternalDTO>}
     * @memberof PaginationFlushInternalDTO
     */
    results: Array<FlushInternalDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferInternalDTO
 */
export interface PaginationTransferInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof PaginationTransferInternalDTO
     */
    results: Array<TransferInternalDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProposalWalletBalanceDTO
 */
export interface ProposalWalletBalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof ProposalWalletBalanceDTO
     */
    id: string;
    /**
     * 
     * @type {BalanceDTO}
     * @memberof ProposalWalletBalanceDTO
     */
    balance: BalanceDTO;
}
/**
 * 
 * @export
 * @interface SimplifiedWalletInternalDTO
 */
export interface SimplifiedWalletInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    nonce: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDTO
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    params: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferDTO
     */
    type: TransferType;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    toAddress: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferInternalDTO
 */
export interface TransferInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    amount: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferInternalDTO
     */
    type: TransferType;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferInternalDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    walletId: string;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    fromAddress: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    toAddress: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    proposalTransaction?: TransactionDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferStatus {
    REQUESTED = 'REQUESTED',
    PENDING = 'PENDING',
    FAILED = 'FAILED',
    MINED = 'MINED',
    REVERTED = 'REVERTED',
    CONFIRMED = 'CONFIRMED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    INACTIVE = 'INACTIVE',
    ACTIVE = 'ACTIVE',
    CREATING = 'CREATING',
    FAILED = 'FAILED'
}


/**
 * FeeWalletControllerApi - axios parameter creator
 * @export
 */
export const FeeWalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFeeHistories.');
            }
            const localVarPath = `/api/v2/fil/fee-wallets/histories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/fil/fee-wallets/balance`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeWalletControllerApi - functional programming interface
 * @export
 */
export const FeeWalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeHistories(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFeeHistoryDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeHistories(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWallet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWallet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeWalletBalance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeWalletBalanceDTO>> {
            const localVarAxiosArgs = await FeeWalletControllerApiAxiosParamCreator(configuration).getFeeWalletBalance(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FeeWalletControllerApi - factory interface
 * @export
 */
export const FeeWalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeHistories(pageable: Pageable, options?: any): AxiosPromise<PaginationFeeHistoryDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeHistories(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWallet(options?: any): AxiosPromise<FeeWalletDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeWalletBalance(options?: any): AxiosPromise<FeeWalletBalanceDTO> {
            return FeeWalletControllerApiFp(configuration).getFeeWalletBalance(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeWalletControllerApi - object-oriented interface
 * @export
 * @class FeeWalletControllerApi
 * @extends {BaseAPI}
 */
export class FeeWalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeHistories(pageable: Pageable, options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeHistories(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWallet(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeWalletControllerApi
     */
    public getFeeWalletBalance(options?: any) {
        return FeeWalletControllerApiFp(this.configuration).getFeeWalletBalance(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalControllerApi - axios parameter creator
 * @export
 */
export const InternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1: async (flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush1.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes/{flushId}`
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes1.');
            }
            const localVarPath = `/api/v2/fil/internal/flushes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer1.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers1.');
            }
            const localVarPath = `/api/v2/fil/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalControllerApi - functional programming interface
 * @export
 */
export const InternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush1(flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlush1(flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getFlushes1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer1(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfer1(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers1(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfers1(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalControllerApi - factory interface
 * @export
 */
export const InternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush1(flushId: string, options?: any): AxiosPromise<FlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlush1(flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes1(pageable: Pageable, options?: any): AxiosPromise<PaginationFlushInternalDTO> {
            return InternalControllerApiFp(configuration).getFlushes1(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfer1(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1(pageable: Pageable, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfers1(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalControllerApi - object-oriented interface
 * @export
 * @class InternalControllerApi
 * @extends {BaseAPI}
 */
export class InternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlush1(flushId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlush1(flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getFlushes1(pageable: Pageable, options?: any) {
        return InternalControllerApiFp(this.configuration).getFlushes1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfer1(transferId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfer1(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfers1(pageable: Pageable, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfers1(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OperationControllerApi - axios parameter creator
 * @export
 */
export const OperationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey: async (createHenesisKeyRequest: CreateHenesisKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHenesisKeyRequest' is not null or undefined
            if (createHenesisKeyRequest === null || createHenesisKeyRequest === undefined) {
                throw new RequiredError('createHenesisKeyRequest','Required parameter createHenesisKeyRequest was null or undefined when calling createHenesisKey.');
            }
            const localVarPath = `/api/v2/fil/operation/henesis-keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHenesisKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHenesisKeyRequest !== undefined ? createHenesisKeyRequest : {}) : (createHenesisKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationControllerApi - functional programming interface
 * @export
 */
export const OperationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HenesisKeyDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).createHenesisKey(createHenesisKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperationControllerApi - factory interface
 * @export
 */
export const OperationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any): AxiosPromise<HenesisKeyDTO> {
            return OperationControllerApiFp(configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationControllerApi - object-oriented interface
 * @export
 * @class OperationControllerApi
 * @extends {BaseAPI}
 */
export class OperationControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateHenesisKeyRequest} createHenesisKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public createHenesisKey(createHenesisKeyRequest: CreateHenesisKeyRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).createHenesisKey(createHenesisKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/fil/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/fil/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(pageable: Pageable, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers(pageable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer(transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers(pageable: Pageable, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers(pageable, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet: async (createMasterWalletRequest: CreateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMasterWalletRequest' is not null or undefined
            if (createMasterWalletRequest === null || createMasterWalletRequest === undefined) {
                throw new RequiredError('createMasterWalletRequest','Required parameter createMasterWalletRequest was null or undefined when calling createMasterWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createMasterWalletRequest !== undefined ? createMasterWalletRequest : {}) : (createMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush: async (walletId: string, flushRequest: FlushRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling flush.');
            }
            // verify required parameter 'flushRequest' is not null or undefined
            if (flushRequest === null || flushRequest === undefined) {
                throw new RequiredError('flushRequest','Required parameter flushRequest was null or undefined when calling flush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof flushRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(flushRequest !== undefined ? flushRequest : {}) : (flushRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush: async (walletId: string, flushId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlush.');
            }
            // verify required parameter 'flushId' is not null or undefined
            if (flushId === null || flushId === undefined) {
                throw new RequiredError('flushId','Required parameter flushId was null or undefined when calling getFlush.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes/{flushId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"flushId"}}`, encodeURIComponent(String(flushId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getFlushes.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getFlushes.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/flushes`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (sort: Sort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/fil/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName: async (walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling patchDepositAddressName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchDepositAddressName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/deposit-addresses/{depositAddressId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateMasterWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling recreateMasterWallet.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/recreate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/fil/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet(createMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flush(walletId: string, flushRequest: FlushRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).flush(walletId, flushRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlush(walletId: string, flushId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlush(walletId, flushId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlushes(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationFlushDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getFlushes(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(sort: Sort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets(sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recreateMasterWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).recreateMasterWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMasterWalletRequest} createMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet(createMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {FlushRequest} flushRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flush(walletId: string, flushRequest: FlushRequest, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).flush(walletId, flushRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} flushId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlush(walletId: string, flushId: string, options?: any): AxiosPromise<FlushDTO> {
            return WalletControllerApiFp(configuration).getFlush(walletId, flushId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlushes(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationFlushDTO> {
            return WalletControllerApiFp(configuration).getFlushes(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sort} sort 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(sort: Sort, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets(sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateMasterWallet(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).recreateMasterWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMasterWalletRequest} createMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet(createMasterWalletRequest: CreateMasterWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet(createMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {FlushRequest} flushRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public flush(walletId: string, flushRequest: FlushRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).flush(walletId, flushRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} flushId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlush(walletId: string, flushId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlush(walletId, flushId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getFlushes(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getFlushes(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sort} sort 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets(sort: Sort, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets(sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchDepositAddressName(walletId: string, depositAddressId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchDepositAddressName(walletId, depositAddressId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public recreateMasterWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).recreateMasterWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


