// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateAllowedAddressesRequest
 */
export interface ActivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ActivateMasterWalletRequest
 */
export interface ActivateMasterWalletRequest {
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    backupKey: KeyDTO;
}
/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistedWalletId?: string;
    /**
     * 
     * @type {number}
     * @memberof AllowedAddressDTO
     */
    coinId?: number;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistType: AllowedAddressDTOWhitelistTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    allowedCoinType: AllowedAddressDTOAllowedCoinTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AllowedAddressDTOWhitelistTypeEnum {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}
/**
    * @export
    * @enum {string}
    */
export enum AllowedAddressDTOAllowedCoinTypeEnum {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    whitelistType: CreateAllowedAddressRequestWhitelistTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateAllowedAddressRequestWhitelistTypeEnum {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletRequest
 */
export interface CreateInactiveMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    encryptionKey: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletResponse
 */
export interface CreateInactiveMasterWalletResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateInactiveMasterWalletResponse
     */
    henesisKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    status: CreateInactiveMasterWalletResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    createdAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateInactiveMasterWalletResponseStatusEnum {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface CreateRawTransactionRequest
 */
export interface CreateRawTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    amount: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionInputDTO
 */
export interface CreateTransactionInputDTO {
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof CreateTransactionInputDTO
     */
    transactionOutput: TransactionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionInputDTO
     */
    accountSignature: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionOutputDTO
 */
export interface CreateTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof CreateTransactionRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof CreateTransactionRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: CreateWithdrawalPolicyRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateWithdrawalPolicyRequestTypeEnum {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}

/**
 * 
 * @export
 * @interface DeleteAllowedAddressRequest
 */
export interface DeleteAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface EstimatedFeeDTO
 */
export interface EstimatedFeeDTO {
    /**
     * 
     * @type {string}
     * @memberof EstimatedFeeDTO
     */
    estimatedFee: string;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    otpKey?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Identity
     */
    roles?: Array<IdentityRolesEnum>;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    username?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IdentityRolesEnum {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface InactivateAllowedAddressesRequest
 */
export interface InactivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject
     */
    identity?: Identity;
    /**
     * 
     * @type {ApproveWithdrawalApprovalRequest}
     * @memberof InlineObject
     */
    approveWithdrawalApprovalRequest?: ApproveWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject1
     */
    identity?: Identity;
    /**
     * 
     * @type {RejectWithdrawalApprovalRequest}
     * @memberof InlineObject1
     */
    rejectWithdrawalApprovalRequest?: RejectWithdrawalApprovalRequest;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject10
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchWithdrawalPolicyRequest}
     * @memberof InlineObject10
     */
    patchWithdrawalPolicyRequest?: PatchWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject11
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateAllowedAddressRequest}
     * @memberof InlineObject11
     */
    request?: CreateAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject12
     */
    identity?: Identity;
    /**
     * 
     * @type {DeleteAllowedAddressRequest}
     * @memberof InlineObject12
     */
    request?: DeleteAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject13
     */
    identity?: Identity;
    /**
     * 
     * @type {ActivateAllowedAddressesRequest}
     * @memberof InlineObject13
     */
    request?: ActivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject14
     */
    identity?: Identity;
    /**
     * 
     * @type {InactivateAllowedAddressesRequest}
     * @memberof InlineObject14
     */
    request?: InactivateAllowedAddressesRequest;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject15
     */
    identity?: Identity;
    /**
     * 
     * @type {ValidateIsAllowedAddressRequest}
     * @memberof InlineObject15
     */
    request?: ValidateIsAllowedAddressRequest;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject2
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateInactiveMasterWalletRequest}
     * @memberof InlineObject2
     */
    createInactiveMasterWalletRequest?: CreateInactiveMasterWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject3
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchAccountKeyRequest}
     * @memberof InlineObject3
     */
    patchAccountKeyRequest?: PatchAccountKeyRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject3
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject4
     */
    identity?: Identity;
    /**
     * 
     * @type {PatchWalletNameRequest}
     * @memberof InlineObject4
     */
    patchWalletNameRequest?: PatchWalletNameRequest;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject5
     */
    identity?: Identity;
    /**
     * 
     * @type {ActivateMasterWalletRequest}
     * @memberof InlineObject5
     */
    activateMasterWalletRequest?: ActivateMasterWalletRequest;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject6
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateRawTransactionRequest}
     * @memberof InlineObject6
     */
    createRawTransactionRequest?: CreateRawTransactionRequest;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject7
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateTransactionRequest}
     * @memberof InlineObject7
     */
    createTransactionRequest?: CreateTransactionRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject7
     */
    needOTP?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject8
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateDepositAddressRequest}
     * @memberof InlineObject8
     */
    createDepositAddressRequest?: CreateDepositAddressRequest;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject8
     */
    needOtp?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {Identity}
     * @memberof InlineObject9
     */
    identity?: Identity;
    /**
     * 
     * @type {CreateWithdrawalPolicyRequest}
     * @memberof InlineObject9
     */
    createWithdrawalPolicyRequest?: CreateWithdrawalPolicyRequest;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    status: MasterWalletDTOStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof MasterWalletDTO
     */
    whitelistActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MasterWalletDTOStatusEnum {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {Array<RawTransactionInputDTO>}
     * @memberof RawTransactionDTO
     */
    inputs: Array<RawTransactionInputDTO>;
    /**
     * 
     * @type {Array<RawTransactionOutputDTO>}
     * @memberof RawTransactionDTO
     */
    outputs: Array<RawTransactionOutputDTO>;
}
/**
 * 
 * @export
 * @interface RawTransactionInputDTO
 */
export interface RawTransactionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionInputDTO
     */
    redeemScript?: string;
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof RawTransactionInputDTO
     */
    transactionOutput?: TransactionOutputDTO;
}
/**
 * 
 * @export
 * @interface RawTransactionOutputDTO
 */
export interface RawTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof RawTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {Array<TransactionOutputDTO>}
     * @memberof TransactionDTO
     */
    outputs: Array<TransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    blockNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    transactionHash: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransactionOutputDTO
 */
export interface TransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    transactionId: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOutputDTO
     */
    outputIndex: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    scriptPubKey: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    status: TransferDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {number}
     * @memberof TransferDTO
     */
    outputIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    receivedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    sendTo?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    withdrawalApprovalId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    type: TransferDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TransferDTOStatusEnum {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED',
    REQUESTED = 'REQUESTED'
}
/**
    * @export
    * @enum {string}
    */
export enum TransferDTOTypeEnum {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressRequest
 */
export interface ValidateIsAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateIsAllowedAddressRequest
     */
    address: string;
}
/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressResponse
 */
export interface ValidateIsAllowedAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateIsAllowedAddressResponse
     */
    isValid: boolean;
}
/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: WalletWithdrawalPolicyDTOBlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WalletWithdrawalPolicyDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: WalletWithdrawalPolicyDTOCoinSymbolEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WalletWithdrawalPolicyDTOBlockchainEnum {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletWithdrawalPolicyDTOTypeEnum {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletWithdrawalPolicyDTOCoinSymbolEnum {
    ETH = 'ETH',
    KLAY = 'KLAY',
    BTC = 'BTC'
}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (identity: Identity, transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getTransfer.');
            }
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/btc/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (identity: Identity, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getTransfers.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/btc/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(identity: Identity, transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer(identity, transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(identity: Identity, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers(identity, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Identity} identity 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(identity: Identity, transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer(identity, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(identity: Identity, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers(identity, pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {Identity} identity 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer(identity: Identity, transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer(identity, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers(identity: Identity, pageable: Pageable, specs: object, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers(identity, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses: async (walletId: string, inlineObject13: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses.');
            }
            // verify required parameter 'inlineObject13' is not null or undefined
            if (inlineObject13 === null || inlineObject13 === undefined) {
                throw new RequiredError('inlineObject13','Required parameter inlineObject13 was null or undefined when calling activateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject13 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject13 !== undefined ? inlineObject13 : {}) : (inlineObject13 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet: async (walletId: string, inlineObject5: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWallet.');
            }
            // verify required parameter 'inlineObject5' is not null or undefined
            if (inlineObject5 === null || inlineObject5 === undefined) {
                throw new RequiredError('inlineObject5','Required parameter inlineObject5 was null or undefined when calling activateMasterWallet.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject5 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject5 !== undefined ? inlineObject5 : {}) : (inlineObject5 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling calculateEstimatedFee.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFee.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress: async (walletId: string, inlineObject11: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress.');
            }
            // verify required parameter 'inlineObject11' is not null or undefined
            if (inlineObject11 === null || inlineObject11 === undefined) {
                throw new RequiredError('inlineObject11','Required parameter inlineObject11 was null or undefined when calling createAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject11 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject11 !== undefined ? inlineObject11 : {}) : (inlineObject11 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, inlineObject8: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'inlineObject8' is not null or undefined
            if (inlineObject8 === null || inlineObject8 === undefined) {
                throw new RequiredError('inlineObject8','Required parameter inlineObject8 was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject8 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject8 !== undefined ? inlineObject8 : {}) : (inlineObject8 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1: async (inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject2' is not null or undefined
            if (inlineObject2 === null || inlineObject2 === undefined) {
                throw new RequiredError('inlineObject2','Required parameter inlineObject2 was null or undefined when calling createMasterWallet1.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction: async (walletId: string, inlineObject6: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransaction.');
            }
            // verify required parameter 'inlineObject6' is not null or undefined
            if (inlineObject6 === null || inlineObject6 === undefined) {
                throw new RequiredError('inlineObject6','Required parameter inlineObject6 was null or undefined when calling createRawTransaction.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject6 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject6 !== undefined ? inlineObject6 : {}) : (inlineObject6 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy: async (walletId: string, inlineObject9: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            // verify required parameter 'inlineObject9' is not null or undefined
            if (inlineObject9 === null || inlineObject9 === undefined) {
                throw new RequiredError('inlineObject9','Required parameter inlineObject9 was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject9 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject9 !== undefined ? inlineObject9 : {}) : (inlineObject9 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress: async (walletId: string, allowedAddressId: string, inlineObject12: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'inlineObject12' is not null or undefined
            if (inlineObject12 === null || inlineObject12 === undefined) {
                throw new RequiredError('inlineObject12','Required parameter inlineObject12 was null or undefined when calling deleteAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject12 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject12 !== undefined ? inlineObject12 : {}) : (inlineObject12 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress: async (identity: Identity, walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses: async (identity: Identity, walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getAllowedAddresses.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getBalance.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (identity: Identity, walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (identity: Identity, walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallet.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (identity: Identity, walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWalletInitialKey.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (identity: Identity, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getMasterWallets.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies: async (identity: Identity, walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy: async (identity: Identity, walletId: string, withdrawalPolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            if (identity === null || identity === undefined) {
                throw new RequiredError('identity','Required parameter identity was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses: async (walletId: string, inlineObject14: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses.');
            }
            // verify required parameter 'inlineObject14' is not null or undefined
            if (inlineObject14 === null || inlineObject14 === undefined) {
                throw new RequiredError('inlineObject14','Required parameter inlineObject14 was null or undefined when calling inactivateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject14 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject14 !== undefined ? inlineObject14 : {}) : (inlineObject14 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey: async (walletId: string, inlineObject3: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey.');
            }
            // verify required parameter 'inlineObject3' is not null or undefined
            if (inlineObject3 === null || inlineObject3 === undefined) {
                throw new RequiredError('inlineObject3','Required parameter inlineObject3 was null or undefined when calling patchMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, inlineObject4: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'inlineObject4' is not null or undefined
            if (inlineObject4 === null || inlineObject4 === undefined) {
                throw new RequiredError('inlineObject4','Required parameter inlineObject4 was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject4 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {}) : (inlineObject4 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy: async (walletId: string, withdrawalPolicyId: string, inlineObject10: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'inlineObject10' is not null or undefined
            if (inlineObject10 === null || inlineObject10 === undefined) {
                throw new RequiredError('inlineObject10','Required parameter inlineObject10 was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject10 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject10 !== undefined ? inlineObject10 : {}) : (inlineObject10 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, inlineObject7: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'inlineObject7' is not null or undefined
            if (inlineObject7 === null || inlineObject7 === undefined) {
                throw new RequiredError('inlineObject7','Required parameter inlineObject7 was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject7 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject7 !== undefined ? inlineObject7 : {}) : (inlineObject7 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress: async (walletId: string, inlineObject15: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress.');
            }
            // verify required parameter 'inlineObject15' is not null or undefined
            if (inlineObject15 === null || inlineObject15 === undefined) {
                throw new RequiredError('inlineObject15','Required parameter inlineObject15 was null or undefined when calling validateIsAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject15 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject15 !== undefined ? inlineObject15 : {}) : (inlineObject15 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses(walletId: string, inlineObject13: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses(walletId, inlineObject13, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateMasterWallet(walletId: string, inlineObject5: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateMasterWallet(walletId, inlineObject5, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateEstimatedFee(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedFeeDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).calculateEstimatedFee(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress(walletId: string, inlineObject11: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createAllowedAddress(walletId, inlineObject11, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, inlineObject8: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, inlineObject8, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet1(inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet1(inlineObject2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(walletId: string, inlineObject6: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createRawTransaction(walletId, inlineObject6, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy(walletId: string, inlineObject9: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy(walletId, inlineObject9, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject12: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject12, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddress(identity, walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddresses(identity: Identity, walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddresses(identity, walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(identity: Identity, walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress(identity, walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(identity, walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(identity, walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(identity: Identity, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets(identity, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicies(identity, walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicy(identity: Identity, walletId: string, withdrawalPolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicy(identity, walletId, withdrawalPolicyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses(walletId, inlineObject14, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey(walletId, inlineObject3, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, inlineObject4: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, inlineObject4, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, inlineObject10: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, inlineObject10, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, inlineObject7: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, inlineObject7, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress(walletId: string, inlineObject15: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress(walletId, inlineObject15, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject13} inlineObject13 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses(walletId: string, inlineObject13: InlineObject13, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).activateAllowedAddresses(walletId, inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet(walletId: string, inlineObject5: InlineObject5, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).activateMasterWallet(walletId, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee(identity: Identity, walletId: string, options?: any): AxiosPromise<EstimatedFeeDTO> {
            return WalletControllerApiFp(configuration).calculateEstimatedFee(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress(walletId: string, inlineObject11: InlineObject11, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).createAllowedAddress(walletId, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, inlineObject8: InlineObject8, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress(walletId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1(inlineObject2: InlineObject2, options?: any): AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet1(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction(walletId: string, inlineObject6: InlineObject6, options?: any): AxiosPromise<RawTransactionDTO> {
            return WalletControllerApiFp(configuration).createRawTransaction(walletId, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy(walletId: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).createWalletWithdrawalPolicy(walletId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject12: InlineObject12, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddress(identity, walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses(identity: Identity, walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddresses(identity, walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(identity: Identity, walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(identity: Identity, walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress(identity, walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses(identity, walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(identity: Identity, walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey(identity, walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(identity: Identity, specs: object, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets(identity, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicies(identity, walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Identity} identity 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy(identity: Identity, walletId: string, withdrawalPolicyId: string, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicy(identity, walletId, withdrawalPolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject14} inlineObject14 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).inactivateAllowedAddresses(walletId, inlineObject14, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletAccountKey(walletId, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, inlineObject4: InlineObject4, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName(walletId, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, inlineObject7: InlineObject7, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction(walletId, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InlineObject15} inlineObject15 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress(walletId: string, inlineObject15: InlineObject15, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return WalletControllerApiFp(configuration).validateIsAllowedAddress(walletId, inlineObject15, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject13} inlineObject13 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateAllowedAddresses(walletId: string, inlineObject13: InlineObject13, options?: any) {
        return WalletControllerApiFp(this.configuration).activateAllowedAddresses(walletId, inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateMasterWallet(walletId: string, inlineObject5: InlineObject5, options?: any) {
        return WalletControllerApiFp(this.configuration).activateMasterWallet(walletId, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public calculateEstimatedFee(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).calculateEstimatedFee(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createAllowedAddress(walletId: string, inlineObject11: InlineObject11, options?: any) {
        return WalletControllerApiFp(this.configuration).createAllowedAddress(walletId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress(walletId: string, inlineObject8: InlineObject8, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress(walletId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet1(inlineObject2: InlineObject2, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet1(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createRawTransaction(walletId: string, inlineObject6: InlineObject6, options?: any) {
        return WalletControllerApiFp(this.configuration).createRawTransaction(walletId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWalletWithdrawalPolicy(walletId: string, inlineObject9: InlineObject9, options?: any) {
        return WalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy(walletId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public deleteAllowedAddress(walletId: string, allowedAddressId: string, inlineObject12: InlineObject12, options?: any) {
        return WalletControllerApiFp(this.configuration).deleteAllowedAddress(walletId, allowedAddressId, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddress(identity: Identity, walletId: string, allowedAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddress(identity, walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddresses(identity: Identity, walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddresses(identity, walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress(identity: Identity, walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress(identity, walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses(identity, walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey(identity: Identity, walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey(identity, walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets(identity: Identity, specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets(identity, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicies(identity: Identity, walletId: string, pageable: Pageable, specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicies(identity, walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Identity} identity 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicy(identity: Identity, walletId: string, withdrawalPolicyId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicy(identity, walletId, withdrawalPolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject14} inlineObject14 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public inactivateAllowedAddresses(walletId: string, inlineObject14: InlineObject14, options?: any) {
        return WalletControllerApiFp(this.configuration).inactivateAllowedAddresses(walletId, inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletAccountKey(walletId: string, inlineObject3: InlineObject3, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletAccountKey(walletId, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName(walletId: string, inlineObject4: InlineObject4, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, inlineObject10: InlineObject10, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject7} inlineObject7 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction(walletId: string, inlineObject7: InlineObject7, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction(walletId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InlineObject15} inlineObject15 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public validateIsAllowedAddress(walletId: string, inlineObject15: InlineObject15, options?: any) {
        return WalletControllerApiFp(this.configuration).validateIsAllowedAddress(walletId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval: async (withdrawalApprovalId: string, inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval.');
            }
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling approveWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval: async (withdrawalApprovalId: string, inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval.');
            }
            // verify required parameter 'inlineObject1' is not null or undefined
            if (inlineObject1 === null || inlineObject1 === undefined) {
                throw new RequiredError('inlineObject1','Required parameter inlineObject1 was null or undefined when calling rejectWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject: InlineObject, options?: any): AxiosPromise<TransferDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject1: InlineObject1, options?: any): AxiosPromise<void> {
            return WithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval(withdrawalApprovalId: string, inlineObject: InlineObject, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval(withdrawalApprovalId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval(withdrawalApprovalId: string, inlineObject1: InlineObject1, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval(withdrawalApprovalId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

}


