// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivateAllowedAddressesRequest
 */
export interface ActivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface ActivateMasterWalletRequest
 */
export interface ActivateMasterWalletRequest {
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {KeyDTO}
     * @memberof ActivateMasterWalletRequest
     */
    backupKey: KeyDTO;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface AllowedAddressDTO
 */
export interface AllowedAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    whitelistedWalletId?: string;
    /**
     * 
     * @type {number}
     * @memberof AllowedAddressDTO
     */
    coinId?: number;
    /**
     * 
     * @type {WhitelistType}
     * @memberof AllowedAddressDTO
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {AllowedCoinType}
     * @memberof AllowedAddressDTO
     */
    allowedCoinType: AllowedCoinType;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedAddressDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AllowedCoinType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @interface ApproveWithdrawalApprovalRequest
 */
export interface ApproveWithdrawalApprovalRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof ApproveWithdrawalApprovalRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface BalanceDTO
 */
export interface BalanceDTO {
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceDTO
     */
    spendableBalance: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    FILECOIN = 'FILECOIN',
    BINANCESMARTCHAIN = 'BINANCE_SMART_CHAIN'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CoinSymbol {
    ETH = 'ETH',
    KLAY = 'KLAY',
    BTC = 'BTC',
    FIL = 'FIL',
    BNB = 'BNB'
}

/**
 * 
 * @export
 * @interface CreateAllowedAddressRequest
 */
export interface CreateAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    label?: string;
    /**
     * 
     * @type {WhitelistType}
     * @memberof CreateAllowedAddressRequest
     */
    whitelistType: WhitelistType;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateDepositAddressRequest
 */
export interface CreateDepositAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDepositAddressRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletRequest
 */
export interface CreateInactiveMasterWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletRequest
     */
    encryptionKey: string;
}
/**
 * 
 * @export
 * @interface CreateInactiveMasterWalletResponse
 */
export interface CreateInactiveMasterWalletResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof CreateInactiveMasterWalletResponse
     */
    henesisKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    encryptionKey: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof CreateInactiveMasterWalletResponse
     */
    status: WalletStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateInactiveMasterWalletResponse
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface CreateRawTransactionRequest
 */
export interface CreateRawTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRawTransactionRequest
     */
    feeRate?: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionInputDTO
 */
export interface CreateTransactionInputDTO {
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof CreateTransactionInputDTO
     */
    transactionOutput: TransactionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionInputDTO
     */
    accountSignature: string;
}
/**
 * 
 * @export
 * @interface CreateTransactionOutputDTO
 */
export interface CreateTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * 
     * @type {Array<CreateTransactionInputDTO>}
     * @memberof CreateTransactionRequest
     */
    inputs: Array<CreateTransactionInputDTO>;
    /**
     * 
     * @type {Array<CreateTransactionOutputDTO>}
     * @memberof CreateTransactionRequest
     */
    outputs: Array<CreateTransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransactionRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalPolicyRequest
 */
export interface CreateWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof CreateWithdrawalPolicyRequest
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DeleteAllowedAddressRequest
 */
export interface DeleteAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedAddressRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DepositAddressDTO
 */
export interface DepositAddressDTO {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAddressDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface EstimatedFeeDTO
 */
export interface EstimatedFeeDTO {
    /**
     * 
     * @type {string}
     * @memberof EstimatedFeeDTO
     */
    estimatedFee: string;
}
/**
 * 
 * @export
 * @interface ExternalWithdrawalSearchCondition
 */
export interface ExternalWithdrawalSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    updatedAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    createdAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWithdrawalSearchCondition
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface InactivateAllowedAddressesRequest
 */
export interface InactivateAllowedAddressesRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedAddressesRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface KeyDTO
 */
export interface KeyDTO {
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    pub: string;
    /**
     * 
     * @type {string}
     * @memberof KeyDTO
     */
    keyFile: string;
}
/**
 * 
 * @export
 * @interface MasterWalletDTO
 */
export interface MasterWalletDTO {
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    orgId: string;
    /**
     * 
     * @type {KeyDTO}
     * @memberof MasterWalletDTO
     */
    accountKey: KeyDTO;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    encryptionKey: string;
    /**
     * 
     * @type {WalletStatus}
     * @memberof MasterWalletDTO
     */
    status: WalletStatus;
    /**
     * 
     * @type {boolean}
     * @memberof MasterWalletDTO
     */
    whitelistActivated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MasterWalletDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedAddressDTO
 */
export interface PaginationAllowedAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedAddressDTO>}
     * @memberof PaginationAllowedAddressDTO
     */
    results: Array<AllowedAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationDepositAddressDTO
 */
export interface PaginationDepositAddressDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationDepositAddressDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<DepositAddressDTO>}
     * @memberof PaginationDepositAddressDTO
     */
    results: Array<DepositAddressDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationSimplifiedTransferDTO
 */
export interface PaginationSimplifiedTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationSimplifiedTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<SimplifiedTransferDTO>}
     * @memberof PaginationSimplifiedTransferDTO
     */
    results: Array<SimplifiedTransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferDTO
 */
export interface PaginationTransferDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferDTO>}
     * @memberof PaginationTransferDTO
     */
    results: Array<TransferDTO>;
}
/**
 * 
 * @export
 * @interface PaginationTransferInternalDTO
 */
export interface PaginationTransferInternalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationTransferInternalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<TransferInternalDTO>}
     * @memberof PaginationTransferInternalDTO
     */
    results: Array<TransferInternalDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletDTO
 */
export interface PaginationWalletDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletDTO>}
     * @memberof PaginationWalletDTO
     */
    results: Array<WalletDTO>;
}
/**
 * 
 * @export
 * @interface PaginationWalletWithdrawalPolicyDTO
 */
export interface PaginationWalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WalletWithdrawalPolicyDTO>}
     * @memberof PaginationWalletWithdrawalPolicyDTO
     */
    results: Array<WalletWithdrawalPolicyDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountKeyRequest
 */
export interface PatchAccountKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    keyFile: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountKeyRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchWalletNameRequest
 */
export interface PatchWalletNameRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWalletNameRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface PatchWithdrawalPolicyRequest
 */
export interface PatchWithdrawalPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    limitAmount: string;
    /**
     * 
     * @type {string}
     * @memberof PatchWithdrawalPolicyRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RawTransactionDTO
 */
export interface RawTransactionDTO {
    /**
     * 
     * @type {Array<RawTransactionInputDTO>}
     * @memberof RawTransactionDTO
     */
    inputs: Array<RawTransactionInputDTO>;
    /**
     * 
     * @type {Array<RawTransactionOutputDTO>}
     * @memberof RawTransactionDTO
     */
    outputs: Array<RawTransactionOutputDTO>;
}
/**
 * 
 * @export
 * @interface RawTransactionInputDTO
 */
export interface RawTransactionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionInputDTO
     */
    redeemScript?: string;
    /**
     * 
     * @type {TransactionOutputDTO}
     * @memberof RawTransactionInputDTO
     */
    transactionOutput?: TransactionOutputDTO;
}
/**
 * 
 * @export
 * @interface RawTransactionOutputDTO
 */
export interface RawTransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof RawTransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {boolean}
     * @memberof RawTransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface RejectWithdrawalApprovalRequest
 */
export interface RejectWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof RejectWithdrawalApprovalRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface SimplifiedTransferDTO
 */
export interface SimplifiedTransferDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    type?: SimplifiedTransferDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    status?: SimplifiedTransferDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    walletId?: string;
    /**
     * 
     * @type {Address}
     * @memberof SimplifiedTransferDTO
     */
    receivedAt?: Address;
    /**
     * 
     * @type {Address}
     * @memberof SimplifiedTransferDTO
     */
    sendTo?: Address;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedTransferDTO
     */
    updatedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SimplifiedTransferDTOTypeEnum {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplifiedTransferDTOStatusEnum {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED',
    REQUESTED = 'REQUESTED'
}

/**
 * 
 * @export
 * @interface SimplifiedWalletInternalDTO
 */
export interface SimplifiedWalletInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplifiedWalletInternalDTO
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    hex: string;
    /**
     * 
     * @type {Array<TransactionOutputDTO>}
     * @memberof TransactionDTO
     */
    outputs: Array<TransactionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    blockNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    transactionHash: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransactionOutputDTO
 */
export interface TransactionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    transactionId: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOutputDTO
     */
    outputIndex: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOutputDTO
     */
    scriptPubKey: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOutputDTO
     */
    isChange: boolean;
}
/**
 * 
 * @export
 * @interface TransferDTO
 */
export interface TransferDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    amount: string;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {number}
     * @memberof TransferDTO
     */
    outputIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    receivedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    sendTo?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    withdrawalApprovalId?: string;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferInternalDTO
 */
export interface TransferInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    amount: string;
    /**
     * 
     * @type {TransferStatus}
     * @memberof TransferInternalDTO
     */
    status: TransferStatus;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    walletId: string;
    /**
     * 
     * @type {TransactionDTO}
     * @memberof TransferInternalDTO
     */
    transaction?: TransactionDTO;
    /**
     * 
     * @type {number}
     * @memberof TransferInternalDTO
     */
    outputIndex?: number;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    receivedAt?: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {SimplifiedWalletInternalDTO}
     * @memberof TransferInternalDTO
     */
    sendTo?: SimplifiedWalletInternalDTO;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    withdrawalApprovalId?: string;
    /**
     * 
     * @type {TransferType}
     * @memberof TransferInternalDTO
     */
    type: TransferType;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TransferInternalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TransferSearchCondition
 */
export interface TransferSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    updatedAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    createdAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSearchCondition
     */
    transferType?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferStatus {
    PENDINGAPPROVAL = 'PENDING_APPROVAL',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    MINED = 'MINED',
    CONFIRMED = 'CONFIRMED',
    REQUESTED = 'REQUESTED'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransferType {
    WITHDRAWAL = 'WITHDRAWAL',
    DEPOSIT = 'DEPOSIT'
}

/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressRequest
 */
export interface ValidateIsAllowedAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateIsAllowedAddressRequest
     */
    address: string;
}
/**
 * 
 * @export
 * @interface ValidateIsAllowedAddressResponse
 */
export interface ValidateIsAllowedAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateIsAllowedAddressResponse
     */
    isValid: boolean;
}
/**
 * 
 * @export
 * @interface WalletDTO
 */
export interface WalletDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    blockchain?: WalletDTOBlockchainEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    type?: WalletDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    status?: WalletDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    walletName?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletDTO
     */
    updatedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WalletDTOBlockchainEnum {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN',
    FILECOIN = 'FILECOIN',
    BINANCESMARTCHAIN = 'BINANCE_SMART_CHAIN'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletDTOTypeEnum {
    MASTERWALLET = 'MASTER_WALLET',
    DEPOSITADDRESS = 'DEPOSIT_ADDRESS'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletDTOStatusEnum {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface WalletSearchCondition
 */
export interface WalletSearchCondition {
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    updatedAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    updatedAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    createdAtGte?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    createdAtLt?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    orgId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletSearchCondition
     */
    walletId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WalletStatus {
    ACTIVE = 'ACTIVE',
    INACTIVE = 'INACTIVE',
    CREATING = 'CREATING'
}

/**
 * 
 * @export
 * @interface WalletWithdrawalPolicyDTO
 */
export interface WalletWithdrawalPolicyDTO {
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    id: string;
    /**
     * 
     * @type {Blockchain}
     * @memberof WalletWithdrawalPolicyDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    limitAmount: string;
    /**
     * 
     * @type {WithdrawalPolicyType}
     * @memberof WalletWithdrawalPolicyDTO
     */
    type: WithdrawalPolicyType;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    walletId: string;
    /**
     * 
     * @type {CoinSymbol}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinSymbol: CoinSymbol;
    /**
     * 
     * @type {string}
     * @memberof WalletWithdrawalPolicyDTO
     */
    coinName: string;
    /**
     * 
     * @type {number}
     * @memberof WalletWithdrawalPolicyDTO
     */
    decimals: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WhitelistType {
    ALL = 'ALL',
    SINGLE = 'SINGLE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalPolicyType {
    DAILY = 'DAILY',
    TRANSACTION = 'TRANSACTION'
}


/**
 * AdminControllerApi - axios parameter creator
 * @export
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses1: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses1.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses1.');
            }
            const localVarPath = `/api/v2/btc/admin/deposit-addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {ExternalWithdrawalSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalWithdrawals: async (pageable: Pageable, condition: ExternalWithdrawalSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getExternalWithdrawals.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getExternalWithdrawals.');
            }
            const localVarPath = `/api/v2/btc/admin/external-withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1: async (pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getMasterWallets1.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getMasterWallets1.');
            }
            const localVarPath = `/api/v2/btc/admin/master-wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers2: async (pageable: Pageable, condition: TransferSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers2.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getTransfers2.');
            }
            const localVarPath = `/api/v2/btc/admin/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getDepositAddresses1(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {ExternalWithdrawalSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalWithdrawals(pageable: Pageable, condition: ExternalWithdrawalSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationSimplifiedTransferDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getExternalWithdrawals(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getMasterWallets1(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationSimplifiedTransferDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getTransfers2(pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return AdminControllerApiFp(configuration).getDepositAddresses1(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {ExternalWithdrawalSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalWithdrawals(pageable: Pageable, condition: ExternalWithdrawalSearchCondition, options?: any): AxiosPromise<PaginationSimplifiedTransferDTO> {
            return AdminControllerApiFp(configuration).getExternalWithdrawals(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationWalletDTO> {
            return AdminControllerApiFp(configuration).getMasterWallets1(pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {TransferSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any): AxiosPromise<PaginationSimplifiedTransferDTO> {
            return AdminControllerApiFp(configuration).getTransfers2(pageable, condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getDepositAddresses1(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getDepositAddresses1(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {ExternalWithdrawalSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getExternalWithdrawals(pageable: Pageable, condition: ExternalWithdrawalSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getExternalWithdrawals(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getMasterWallets1(pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getMasterWallets1(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {TransferSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getTransfers2(pageable: Pageable, condition: TransferSearchCondition, options?: any) {
        return AdminControllerApiFp(this.configuration).getTransfers2(pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InternalControllerApi - axios parameter creator
 * @export
 */
export const InternalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer.');
            }
            const localVarPath = `/api/v2/btc/internal/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers.');
            }
            const localVarPath = `/api/v2/btc/internal/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalControllerApi - functional programming interface
 * @export
 */
export const InternalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfer(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferInternalDTO>> {
            const localVarAxiosArgs = await InternalControllerApiAxiosParamCreator(configuration).getTransfers(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InternalControllerApi - factory interface
 * @export
 */
export const InternalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transferId: string, options?: any): AxiosPromise<TransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfer(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferInternalDTO> {
            return InternalControllerApiFp(configuration).getTransfers(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalControllerApi - object-oriented interface
 * @export
 * @class InternalControllerApi
 * @extends {BaseAPI}
 */
export class InternalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfer(transferId: string, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfer(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalControllerApi
     */
    public getTransfers(pageable: Pageable, specs: object, options?: any) {
        return InternalControllerApiFp(this.configuration).getTransfers(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TransferControllerApi - axios parameter creator
 * @export
 */
export const TransferControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1: async (transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling getTransfer1.');
            }
            const localVarPath = `/api/v2/btc/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1: async (pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getTransfers1.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getTransfers1.');
            }
            const localVarPath = `/api/v2/btc/transfers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferControllerApi - functional programming interface
 * @export
 */
export const TransferControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer1(transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfer1(transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfers1(pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationTransferDTO>> {
            const localVarAxiosArgs = await TransferControllerApiAxiosParamCreator(configuration).getTransfers1(pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TransferControllerApi - factory interface
 * @export
 */
export const TransferControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} transferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer1(transferId: string, options?: any): AxiosPromise<TransferDTO> {
            return TransferControllerApiFp(configuration).getTransfer1(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfers1(pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationTransferDTO> {
            return TransferControllerApiFp(configuration).getTransfers1(pageable, specs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferControllerApi - object-oriented interface
 * @export
 * @class TransferControllerApi
 * @extends {BaseAPI}
 */
export class TransferControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} transferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfer1(transferId: string, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfer1(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferControllerApi
     */
    public getTransfers1(pageable: Pageable, specs: object, options?: any) {
        return TransferControllerApiFp(this.configuration).getTransfers1(pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WalletControllerApi - axios parameter creator
 * @export
 */
export const WalletControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses: async (walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateAllowedAddresses.');
            }
            // verify required parameter 'activateAllowedAddressesRequest' is not null or undefined
            if (activateAllowedAddressesRequest === null || activateAllowedAddressesRequest === undefined) {
                throw new RequiredError('activateAllowedAddressesRequest','Required parameter activateAllowedAddressesRequest was null or undefined when calling activateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedAddressesRequest !== undefined ? activateAllowedAddressesRequest : {}) : (activateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet: async (walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling activateMasterWallet.');
            }
            // verify required parameter 'activateMasterWalletRequest' is not null or undefined
            if (activateMasterWalletRequest === null || activateMasterWalletRequest === undefined) {
                throw new RequiredError('activateMasterWalletRequest','Required parameter activateMasterWalletRequest was null or undefined when calling activateMasterWallet.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/activate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateMasterWalletRequest !== undefined ? activateMasterWalletRequest : {}) : (activateMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling calculateEstimatedFee.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/estimated-fee`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress: async (walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createAllowedAddress.');
            }
            // verify required parameter 'createAllowedAddressRequest' is not null or undefined
            if (createAllowedAddressRequest === null || createAllowedAddressRequest === undefined) {
                throw new RequiredError('createAllowedAddressRequest','Required parameter createAllowedAddressRequest was null or undefined when calling createAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedAddressRequest !== undefined ? createAllowedAddressRequest : {}) : (createAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress: async (walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createDepositAddress.');
            }
            // verify required parameter 'createDepositAddressRequest' is not null or undefined
            if (createDepositAddressRequest === null || createDepositAddressRequest === undefined) {
                throw new RequiredError('createDepositAddressRequest','Required parameter createDepositAddressRequest was null or undefined when calling createDepositAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createDepositAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createDepositAddressRequest !== undefined ? createDepositAddressRequest : {}) : (createDepositAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1: async (createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInactiveMasterWalletRequest' is not null or undefined
            if (createInactiveMasterWalletRequest === null || createInactiveMasterWalletRequest === undefined) {
                throw new RequiredError('createInactiveMasterWalletRequest','Required parameter createInactiveMasterWalletRequest was null or undefined when calling createMasterWallet1.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createInactiveMasterWalletRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createInactiveMasterWalletRequest !== undefined ? createInactiveMasterWalletRequest : {}) : (createInactiveMasterWalletRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction: async (walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createRawTransaction.');
            }
            // verify required parameter 'createRawTransactionRequest' is not null or undefined
            if (createRawTransactionRequest === null || createRawTransactionRequest === undefined) {
                throw new RequiredError('createRawTransactionRequest','Required parameter createRawTransactionRequest was null or undefined when calling createRawTransaction.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/raw-transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createRawTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createRawTransactionRequest !== undefined ? createRawTransactionRequest : {}) : (createRawTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy: async (walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            // verify required parameter 'createWithdrawalPolicyRequest' is not null or undefined
            if (createWithdrawalPolicyRequest === null || createWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('createWithdrawalPolicyRequest','Required parameter createWithdrawalPolicyRequest was null or undefined when calling createWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalPolicyRequest !== undefined ? createWithdrawalPolicyRequest : {}) : (createWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress: async (walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling deleteAllowedAddress.');
            }
            // verify required parameter 'deleteAllowedAddressRequest' is not null or undefined
            if (deleteAllowedAddressRequest === null || deleteAllowedAddressRequest === undefined) {
                throw new RequiredError('deleteAllowedAddressRequest','Required parameter deleteAllowedAddressRequest was null or undefined when calling deleteAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedAddressRequest !== undefined ? deleteAllowedAddressRequest : {}) : (deleteAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress: async (walletId: string, allowedAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddress.');
            }
            // verify required parameter 'allowedAddressId' is not null or undefined
            if (allowedAddressId === null || allowedAddressId === undefined) {
                throw new RequiredError('allowedAddressId','Required parameter allowedAddressId was null or undefined when calling getAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/{allowedAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"allowedAddressId"}}`, encodeURIComponent(String(allowedAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses: async (walletId: string, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getAllowedAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getBalance.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/balance`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (walletId: string, depositAddressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddress.');
            }
            // verify required parameter 'depositAddressId' is not null or undefined
            if (depositAddressId === null || depositAddressId === undefined) {
                throw new RequiredError('depositAddressId','Required parameter depositAddressId was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses/{depositAddressId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"depositAddressId"}}`, encodeURIComponent(String(depositAddressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses: async (walletId: string, pageable: Pageable, condition: WalletSearchCondition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getDepositAddresses.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling getDepositAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/deposit-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWallet.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey: async (walletId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getMasterWalletInitialKey.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/initial-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets: async (specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getMasterWallets.');
            }
            const localVarPath = `/api/v2/btc/wallets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies: async (walletId: string, pageable: Pageable, specs: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            // verify required parameter 'specs' is not null or undefined
            if (specs === null || specs === undefined) {
                throw new RequiredError('specs','Required parameter specs was null or undefined when calling getWalletWithdrawalPolicies.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy: async (walletId: string, withdrawalPolicyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling getWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses: async (walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling inactivateAllowedAddresses.');
            }
            // verify required parameter 'inactivateAllowedAddressesRequest' is not null or undefined
            if (inactivateAllowedAddressesRequest === null || inactivateAllowedAddressesRequest === undefined) {
                throw new RequiredError('inactivateAllowedAddressesRequest','Required parameter inactivateAllowedAddressesRequest was null or undefined when calling inactivateAllowedAddresses.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/inactivate-allowed-addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedAddressesRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedAddressesRequest !== undefined ? inactivateAllowedAddressesRequest : {}) : (inactivateAllowedAddressesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey: async (walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletAccountKey.');
            }
            // verify required parameter 'patchAccountKeyRequest' is not null or undefined
            if (patchAccountKeyRequest === null || patchAccountKeyRequest === undefined) {
                throw new RequiredError('patchAccountKeyRequest','Required parameter patchAccountKeyRequest was null or undefined when calling patchMasterWalletAccountKey.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/account-key`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountKeyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountKeyRequest !== undefined ? patchAccountKeyRequest : {}) : (patchAccountKeyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName: async (walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchMasterWalletName.');
            }
            // verify required parameter 'patchWalletNameRequest' is not null or undefined
            if (patchWalletNameRequest === null || patchWalletNameRequest === undefined) {
                throw new RequiredError('patchWalletNameRequest','Required parameter patchWalletNameRequest was null or undefined when calling patchMasterWalletName.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/name`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWalletNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWalletNameRequest !== undefined ? patchWalletNameRequest : {}) : (patchWalletNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy: async (walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'withdrawalPolicyId' is not null or undefined
            if (withdrawalPolicyId === null || withdrawalPolicyId === undefined) {
                throw new RequiredError('withdrawalPolicyId','Required parameter withdrawalPolicyId was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            // verify required parameter 'patchWithdrawalPolicyRequest' is not null or undefined
            if (patchWithdrawalPolicyRequest === null || patchWithdrawalPolicyRequest === undefined) {
                throw new RequiredError('patchWithdrawalPolicyRequest','Required parameter patchWithdrawalPolicyRequest was null or undefined when calling patchWalletWithdrawalPolicy.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/withdrawal-policies/{withdrawalPolicyId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"withdrawalPolicyId"}}`, encodeURIComponent(String(withdrawalPolicyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchWithdrawalPolicyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchWithdrawalPolicyRequest !== undefined ? patchWithdrawalPolicyRequest : {}) : (patchWithdrawalPolicyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (walletId: string, createTransactionRequest: CreateTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling sendTransaction.');
            }
            // verify required parameter 'createTransactionRequest' is not null or undefined
            if (createTransactionRequest === null || createTransactionRequest === undefined) {
                throw new RequiredError('createTransactionRequest','Required parameter createTransactionRequest was null or undefined when calling sendTransaction.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/transactions`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTransactionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTransactionRequest !== undefined ? createTransactionRequest : {}) : (createTransactionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress: async (walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            if (walletId === null || walletId === undefined) {
                throw new RequiredError('walletId','Required parameter walletId was null or undefined when calling validateIsAllowedAddress.');
            }
            // verify required parameter 'validateIsAllowedAddressRequest' is not null or undefined
            if (validateIsAllowedAddressRequest === null || validateIsAllowedAddressRequest === undefined) {
                throw new RequiredError('validateIsAllowedAddressRequest','Required parameter validateIsAllowedAddressRequest was null or undefined when calling validateIsAllowedAddress.');
            }
            const localVarPath = `/api/v2/btc/wallets/{walletId}/allowed-addresses/validate`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validateIsAllowedAddressRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validateIsAllowedAddressRequest !== undefined ? validateIsAllowedAddressRequest : {}) : (validateIsAllowedAddressRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletControllerApi - functional programming interface
 * @export
 */
export const WalletControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateEstimatedFee(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedFeeDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).calculateEstimatedFee(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createDepositAddress(walletId, createDepositAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createMasterWallet1(createInactiveMasterWalletRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawTransactionDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createRawTransaction(walletId, createRawTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddress(walletId, allowedAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedAddresses(walletId: string, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getAllowedAddresses(walletId, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getBalance(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(walletId: string, depositAddressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddress(walletId, depositAddressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationDepositAddressDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getDepositAddresses(walletId, pageable, condition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallet(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallet(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWalletInitialKey(walletId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWalletInitialKey(walletId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterWallets(specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterWalletDTO>>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getMasterWallets(specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MasterWalletDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWithdrawalPolicyDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).sendTransaction(walletId, createTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateIsAllowedAddressResponse>> {
            const localVarAxiosArgs = await WalletControllerApiAxiosParamCreator(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletControllerApi - factory interface
 * @export
 */
export const WalletControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateEstimatedFee(walletId: string, options?: any): AxiosPromise<EstimatedFeeDTO> {
            return WalletControllerApiFp(configuration).calculateEstimatedFee(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateDepositAddressRequest} createDepositAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any): AxiosPromise<CreateInactiveMasterWalletResponse | MasterWalletDTO> {
            return WalletControllerApiFp(configuration).createMasterWallet1(createInactiveMasterWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateRawTransactionRequest} createRawTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any): AxiosPromise<RawTransactionDTO> {
            return WalletControllerApiFp(configuration).createRawTransaction(walletId, createRawTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} allowedAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddress(walletId: string, allowedAddressId: string, options?: any): AxiosPromise<AllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedAddresses(walletId: string, pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedAddressDTO> {
            return WalletControllerApiFp(configuration).getAllowedAddresses(walletId, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(walletId: string, options?: any): AxiosPromise<BalanceDTO> {
            return WalletControllerApiFp(configuration).getBalance(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} depositAddressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(walletId: string, depositAddressId: string, options?: any): AxiosPromise<DepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {WalletSearchCondition} condition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any): AxiosPromise<PaginationDepositAddressDTO> {
            return WalletControllerApiFp(configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallet(walletId: string, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).getMasterWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWalletInitialKey(walletId: string, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterWallets(specs: object, options?: any): AxiosPromise<Array<MasterWalletDTO>> {
            return WalletControllerApiFp(configuration).getMasterWallets(specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {Pageable} pageable 
         * @param {object} specs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any): AxiosPromise<PaginationWalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any): AxiosPromise<void> {
            return WalletControllerApiFp(configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any): AxiosPromise<KeyDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {PatchWalletNameRequest} patchWalletNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any): AxiosPromise<MasterWalletDTO> {
            return WalletControllerApiFp(configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {string} withdrawalPolicyId 
         * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any): AxiosPromise<WalletWithdrawalPolicyDTO> {
            return WalletControllerApiFp(configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any): AxiosPromise<TransferDTO> {
            return WalletControllerApiFp(configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletId 
         * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any): AxiosPromise<ValidateIsAllowedAddressResponse> {
            return WalletControllerApiFp(configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletControllerApi - object-oriented interface
 * @export
 * @class WalletControllerApi
 * @extends {BaseAPI}
 */
export class WalletControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} walletId 
     * @param {ActivateAllowedAddressesRequest} activateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateAllowedAddresses(walletId: string, activateAllowedAddressesRequest: ActivateAllowedAddressesRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).activateAllowedAddresses(walletId, activateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ActivateMasterWalletRequest} activateMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public activateMasterWallet(walletId: string, activateMasterWalletRequest: ActivateMasterWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).activateMasterWallet(walletId, activateMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public calculateEstimatedFee(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).calculateEstimatedFee(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateAllowedAddressRequest} createAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createAllowedAddress(walletId: string, createAllowedAddressRequest: CreateAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createAllowedAddress(walletId, createAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateDepositAddressRequest} createDepositAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createDepositAddress(walletId: string, createDepositAddressRequest: CreateDepositAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createDepositAddress(walletId, createDepositAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInactiveMasterWalletRequest} createInactiveMasterWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createMasterWallet1(createInactiveMasterWalletRequest: CreateInactiveMasterWalletRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createMasterWallet1(createInactiveMasterWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateRawTransactionRequest} createRawTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createRawTransaction(walletId: string, createRawTransactionRequest: CreateRawTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createRawTransaction(walletId, createRawTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateWithdrawalPolicyRequest} createWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public createWalletWithdrawalPolicy(walletId: string, createWithdrawalPolicyRequest: CreateWithdrawalPolicyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).createWalletWithdrawalPolicy(walletId, createWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {DeleteAllowedAddressRequest} deleteAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public deleteAllowedAddress(walletId: string, allowedAddressId: string, deleteAllowedAddressRequest: DeleteAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).deleteAllowedAddress(walletId, allowedAddressId, deleteAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} allowedAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddress(walletId: string, allowedAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddress(walletId, allowedAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getAllowedAddresses(walletId: string, pageable: Pageable, options?: any) {
        return WalletControllerApiFp(this.configuration).getAllowedAddresses(walletId, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getBalance(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getBalance(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} depositAddressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddress(walletId: string, depositAddressId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddress(walletId, depositAddressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {WalletSearchCondition} condition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getDepositAddresses(walletId: string, pageable: Pageable, condition: WalletSearchCondition, options?: any) {
        return WalletControllerApiFp(this.configuration).getDepositAddresses(walletId, pageable, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallet(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWalletInitialKey(walletId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWalletInitialKey(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getMasterWallets(specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getMasterWallets(specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {Pageable} pageable 
     * @param {object} specs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicies(walletId: string, pageable: Pageable, specs: object, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicies(walletId, pageable, specs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public getWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, options?: any) {
        return WalletControllerApiFp(this.configuration).getWalletWithdrawalPolicy(walletId, withdrawalPolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {InactivateAllowedAddressesRequest} inactivateAllowedAddressesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public inactivateAllowedAddresses(walletId: string, inactivateAllowedAddressesRequest: InactivateAllowedAddressesRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).inactivateAllowedAddresses(walletId, inactivateAllowedAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchAccountKeyRequest} patchAccountKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletAccountKey(walletId: string, patchAccountKeyRequest: PatchAccountKeyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletAccountKey(walletId, patchAccountKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {PatchWalletNameRequest} patchWalletNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchMasterWalletName(walletId: string, patchWalletNameRequest: PatchWalletNameRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchMasterWalletName(walletId, patchWalletNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {string} withdrawalPolicyId 
     * @param {PatchWithdrawalPolicyRequest} patchWithdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public patchWalletWithdrawalPolicy(walletId: string, withdrawalPolicyId: string, patchWithdrawalPolicyRequest: PatchWithdrawalPolicyRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).patchWalletWithdrawalPolicy(walletId, withdrawalPolicyId, patchWithdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public sendTransaction(walletId: string, createTransactionRequest: CreateTransactionRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).sendTransaction(walletId, createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} walletId 
     * @param {ValidateIsAllowedAddressRequest} validateIsAllowedAddressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletControllerApi
     */
    public validateIsAllowedAddress(walletId: string, validateIsAllowedAddressRequest: ValidateIsAllowedAddressRequest, options?: any) {
        return WalletControllerApiFp(this.configuration).validateIsAllowedAddress(walletId, validateIsAllowedAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval: async (withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approveWithdrawalApproval.');
            }
            // verify required parameter 'approveWithdrawalApprovalRequest' is not null or undefined
            if (approveWithdrawalApprovalRequest === null || approveWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('approveWithdrawalApprovalRequest','Required parameter approveWithdrawalApprovalRequest was null or undefined when calling approveWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof approveWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(approveWithdrawalApprovalRequest !== undefined ? approveWithdrawalApprovalRequest : {}) : (approveWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval: async (withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling rejectWithdrawalApproval.');
            }
            // verify required parameter 'rejectWithdrawalApprovalRequest' is not null or undefined
            if (rejectWithdrawalApprovalRequest === null || rejectWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('rejectWithdrawalApprovalRequest','Required parameter rejectWithdrawalApprovalRequest was null or undefined when calling rejectWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/btc/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rejectWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rejectWithdrawalApprovalRequest !== undefined ? rejectWithdrawalApprovalRequest : {}) : (rejectWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any): AxiosPromise<TransferDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any): AxiosPromise<void> {
            return WithdrawalApprovalControllerApiFp(configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {ApproveWithdrawalApprovalRequest} approveWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approveWithdrawalApproval(withdrawalApprovalId: string, approveWithdrawalApprovalRequest: ApproveWithdrawalApprovalRequest, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approveWithdrawalApproval(withdrawalApprovalId, approveWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {RejectWithdrawalApprovalRequest} rejectWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public rejectWithdrawalApproval(withdrawalApprovalId: string, rejectWithdrawalApprovalRequest: RejectWithdrawalApprovalRequest, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).rejectWithdrawalApproval(withdrawalApprovalId, rejectWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


