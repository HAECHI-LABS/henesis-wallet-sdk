// tslint:disable
/**
 * Wallet API
 * Wallet API 명세
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenDTO
 */
export interface AccessTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenDTO
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof AccountDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    accessToken: string;
    /**
     * 
     * @type {HenesisLocale}
     * @memberof AccountDTO
     */
    locale: HenesisLocale;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface ActivateAllowedIpsRequest
 */
export interface ActivateAllowedIpsRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivateAllowedIpsRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface AllowedIpDTO
 */
export interface AllowedIpDTO {
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof AllowedIpDTO
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface BillingPlanDTO
 */
export interface BillingPlanDTO {
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    billingType: BillingPlanDTOBillingTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BillingPlanDTO
     */
    withdrawalFeeRate?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    defaultCoinListingChargeKrw: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    contractDate: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof BillingPlanDTO
     */
    endDate: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BillingPlanDTOBillingTypeEnum {
    CHARGE = 'MAINNET_CHARGE',
    CHARGEANDWITHDRAWALFEE = 'MAINNET_CHARGE_AND_WITHDRAWAL_FEE',
    CHARGEORWITHDRAWALFEE = 'MAINNET_CHARGE_OR_WITHDRAWAL_FEE'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Blockchain {
    ETHEREUM = 'ETHEREUM',
    KLAYTN = 'KLAYTN',
    BITCOIN = 'BITCOIN'
}

/**
 * 
 * @export
 * @interface ChangeAccountNameRequest
 */
export interface ChangeAccountNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeAccountNameRequest
     */
    lastName: string;
}
/**
 * 
 * @export
 * @interface Claim
 */
export interface Claim {
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Claim
     */
    type?: ClaimTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Claim
     */
    longType?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ClaimTypeEnum {
    LONG = 'LONG',
    SHORT = 'SHORT'
}

/**
 * 
 * @export
 * @interface ClientIdentity
 */
export interface ClientIdentity {
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    browser?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    method?: ClientIdentityMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientIdentity
     */
    uri?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ClientIdentity
     */
    queryParams?: { [key: string]: Array<string>; };
}

/**
    * @export
    * @enum {string}
    */
export enum ClientIdentityMethodEnum {
    GET = 'GET',
    HEAD = 'HEAD',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE',
    OPTIONS = 'OPTIONS',
    TRACE = 'TRACE'
}

/**
 * 
 * @export
 * @interface CoinListingDTO
 */
export interface CoinListingDTO {
    /**
     * 
     * @type {string}
     * @memberof CoinListingDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CoinListingDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof CoinListingDTO
     */
    coinId: string;
    /**
     * 
     * @type {string}
     * @memberof CoinListingDTO
     */
    chargeKrw: string;
    /**
     * 
     * @type {boolean}
     * @memberof CoinListingDTO
     */
    isExempted: boolean;
    /**
     * 
     * @type {string}
     * @memberof CoinListingDTO
     */
    coinListingDate: string;
}
/**
 * 
 * @export
 * @interface CreateAllowedIpRequest
 */
export interface CreateAllowedIpRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAllowedIpRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface CreateBillingPlanRequest
 */
export interface CreateBillingPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBillingPlanRequest
     */
    billingType: CreateBillingPlanRequestBillingTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateBillingPlanRequest
     */
    withdrawalFeeRate: number;
    /**
     * 
     * @type {string}
     * @memberof CreateBillingPlanRequest
     */
    defaultCoinListingChargeKrw: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBillingPlanRequest
     */
    contractDate: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBillingPlanRequest
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBillingPlanRequest
     */
    endDate: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateBillingPlanRequestBillingTypeEnum {
    CHARGE = 'MAINNET_CHARGE',
    CHARGEANDWITHDRAWALFEE = 'MAINNET_CHARGE_AND_WITHDRAWAL_FEE',
    CHARGEORWITHDRAWALFEE = 'MAINNET_CHARGE_OR_WITHDRAWAL_FEE'
}

/**
 * 
 * @export
 * @interface CreateCoinListingRequest
 */
export interface CreateCoinListingRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCoinListingRequest
     */
    coinId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinListingRequest
     */
    chargeKrw?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCoinListingRequest
     */
    isExempted: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateCoinListingRequest
     */
    coinListingDate: string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateSecretResponse
 */
export interface CreateSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateSecretResponse
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface CreateWithdrawalApprovalRequest
 */
export interface CreateWithdrawalApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    blockchain: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof CreateWithdrawalApprovalRequest
     */
    decimals: number;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    masterWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    userWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    walletName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    feeAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    coinName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    toAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalApprovalRequest
     */
    transferAt: string;
}
/**
 * 
 * @export
 * @interface DeleteAllowedIpRequest
 */
export interface DeleteAllowedIpRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAllowedIpRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface DeleteCoinListingRequest
 */
export interface DeleteCoinListingRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteCoinListingRequest
     */
    coinId: string;
}
/**
 * 
 * @export
 * @interface ErrorBody
 */
export interface ErrorBody {
    /**
     * 
     * @type {string}
     * @memberof ErrorBody
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorBody
     */
    code?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorBody}
     * @memberof ErrorResponse
     */
    error?: ErrorBody;
}
/**
 * 
 * @export
 * @interface HenesisLocale
 */
export interface HenesisLocale {
    /**
     * 
     * @type {string}
     * @memberof HenesisLocale
     */
    language?: HenesisLocaleLanguageEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HenesisLocaleLanguageEnum {
    KO = 'KO',
    EN = 'EN'
}

/**
 * 
 * @export
 * @interface IdentityDTO
 */
export interface IdentityDTO {
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof IdentityDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    organizationSecret: string;
    /**
     * 
     * @type {HenesisLocale}
     * @memberof IdentityDTO
     */
    locale: HenesisLocale;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    otpKey: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDTO
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface InactivateAllowedIpsRequest
 */
export interface InactivateAllowedIpsRequest {
    /**
     * 
     * @type {string}
     * @memberof InactivateAllowedIpsRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {ClientIdentity}
     * @memberof InlineObject
     */
    clientIdentity?: ClientIdentity;
    /**
     * 
     * @type {LoginRequest}
     * @memberof InlineObject
     */
    request?: LoginRequest;
}
/**
 * 
 * @export
 * @interface LoginIpDTO
 */
export interface LoginIpDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    browser?: string;
    /**
     * 
     * @type {LoginIpStatus}
     * @memberof LoginIpDTO
     */
    status: LoginIpStatus;
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    ipAddress: string;
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof LoginIpDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LoginIpStatus {
    REQUESTED = 'REQUESTED',
    VERIFIED = 'VERIFIED'
}

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof LoginResponse
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
    /**
     * 
     * @type {OTPDTO}
     * @memberof LoginResponse
     */
    otp: OTPDTO;
    /**
     * 
     * @type {HenesisLocale}
     * @memberof LoginResponse
     */
    locale: HenesisLocale;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    passwordInitialized: boolean;
}
/**
 * 
 * @export
 * @interface NotificationPayloadDto
 */
export interface NotificationPayloadDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationPayloadDto
     */
    language?: NotificationPayloadDtoLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationPayloadDto
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPayloadDto
     */
    content?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationPayloadDtoLanguageEnum {
    KO = 'KO',
    EN = 'EN'
}

/**
 * 
 * @export
 * @interface NotifyRequest
 */
export interface NotifyRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof NotifyRequest
     */
    targets?: Array<NotifyRequestTargetsEnum>;
    /**
     * 
     * @type {Array<NotificationPayloadDto>}
     * @memberof NotifyRequest
     */
    payloads?: Array<NotificationPayloadDto>;
}

/**
    * @export
    * @enum {string}
    */
export enum NotifyRequestTargetsEnum {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface OTPDTO
 */
export interface OTPDTO {
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof OTPDTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface OrgAccountDTO
 */
export interface OrgAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    email: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof OrgAccountDTO
     */
    roles: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrgAccountDTO
     */
    lastName: string;
    /**
     * 
     * @type {Array<LoginIpDTO>}
     * @memberof OrgAccountDTO
     */
    loginIps: Array<LoginIpDTO>;
}
/**
 * 
 * @export
 * @interface OrganizationDTO
 */
export interface OrganizationDTO {
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationDTO
     */
    secret: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationDTO
     */
    whitelistActivated: boolean;
}
/**
 * 
 * @export
 * @interface OrganizationInfoDTO
 */
export interface OrganizationInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof OrganizationInfoDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInfoDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationInfoDTO
     */
    createdAt: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationInfoDTO
     */
    userCount: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationAllowedIpDTO
 */
export interface PaginationAllowedIpDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationAllowedIpDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<AllowedIpDTO>}
     * @memberof PaginationAllowedIpDTO
     */
    results: Array<AllowedIpDTO>;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    nextUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationMeta
     */
    previousUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface PaginationWithdrawalApprovalDTO
 */
export interface PaginationWithdrawalApprovalDTO {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    pagination: PaginationMeta;
    /**
     * 
     * @type {Array<WithdrawalApprovalDTO>}
     * @memberof PaginationWithdrawalApprovalDTO
     */
    results: Array<WithdrawalApprovalDTO>;
}
/**
 * 
 * @export
 * @interface PatchAccountRoleRequest
 */
export interface PatchAccountRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRoleRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface PatchAllowedIpLabelRequest
 */
export interface PatchAllowedIpLabelRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAllowedIpLabelRequest
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof PatchAllowedIpLabelRequest
     */
    otpCode: string;
}
/**
 * 
 * @export
 * @interface RefreshAccessTokenRequest
 */
export interface RefreshAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    COIN = 'COIN',
    VIEWER = 'VIEWER',
    ADMIN = 'ADMIN',
    HAECHI = 'HAECHI',
    SPENDER = 'SPENDER'
}

/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    password: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SignUpRequest
     */
    roles: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface SimpleAccountDTO
 */
export interface SimpleAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleAccountDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface UpdateBillingPlanChargeRequest
 */
export interface UpdateBillingPlanChargeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBillingPlanChargeRequest
     */
    billingType: UpdateBillingPlanChargeRequestBillingTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateBillingPlanChargeRequest
     */
    withdrawalFeeRate?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateBillingPlanChargeRequest
     */
    defaultCoinListingChargeKrw: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateBillingPlanChargeRequestBillingTypeEnum {
    CHARGE = 'MAINNET_CHARGE',
    CHARGEANDWITHDRAWALFEE = 'MAINNET_CHARGE_AND_WITHDRAWAL_FEE',
    CHARGEORWITHDRAWALFEE = 'MAINNET_CHARGE_OR_WITHDRAWAL_FEE'
}

/**
 * 
 * @export
 * @interface UpdateBillingPlanPeriodRequest
 */
export interface UpdateBillingPlanPeriodRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBillingPlanPeriodRequest
     */
    contractDate: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBillingPlanPeriodRequest
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBillingPlanPeriodRequest
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface UpdateLanguageRequest
 */
export interface UpdateLanguageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateLanguageRequest
     */
    newLanguage: string;
}
/**
 * 
 * @export
 * @interface UpdateOTPInitializeRequest
 */
export interface UpdateOTPInitializeRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOTPInitializeRequest
     */
    initialize: boolean;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    newOrgId: string;
}
/**
 * 
 * @export
 * @interface UpdatePasswordRequest
 */
export interface UpdatePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordRequest
     */
    otpCode?: string;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface WithdrawalApprovalDTO
 */
export interface WithdrawalApprovalDTO {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    id: string;
    /**
     * 
     * @type {SimpleAccountDTO}
     * @memberof WithdrawalApprovalDTO
     */
    requester: SimpleAccountDTO;
    /**
     * 
     * @type {Blockchain}
     * @memberof WithdrawalApprovalDTO
     */
    blockchain: Blockchain;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawalApprovalDTO
     */
    decimals: number;
    /**
     * 
     * @type {WithdrawalApprovalStatus}
     * @memberof WithdrawalApprovalDTO
     */
    status: WithdrawalApprovalStatus;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    masterWalletId: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    userWalletId?: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    coinSymbol: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    toAddress: string;
    /**
     * 
     * @type {Array<SimpleAccountDTO>}
     * @memberof WithdrawalApprovalDTO
     */
    approvedBy: Array<SimpleAccountDTO>;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    transferAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalApprovalDTO
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalApprovalStatus {
    PENDING = 'PENDING',
    REJECTED = 'REJECTED',
    APPROVED = 'APPROVED'
}


/**
 * AccountControllerApi - axios parameter creator
 * @export
 */
export const AccountControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeAccountNameRequest} changeAccountNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountName: async (changeAccountNameRequest: ChangeAccountNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeAccountNameRequest' is not null or undefined
            if (changeAccountNameRequest === null || changeAccountNameRequest === undefined) {
                throw new RequiredError('changeAccountNameRequest','Required parameter changeAccountNameRequest was null or undefined when calling changeAccountName.');
            }
            const localVarPath = `/api/v2/accounts/name`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changeAccountNameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changeAccountNameRequest !== undefined ? changeAccountNameRequest : {}) : (changeAccountNameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken1: async (refreshAccessTokenRequest: RefreshAccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshAccessTokenRequest' is not null or undefined
            if (refreshAccessTokenRequest === null || refreshAccessTokenRequest === undefined) {
                throw new RequiredError('refreshAccessTokenRequest','Required parameter refreshAccessTokenRequest was null or undefined when calling createAccessToken1.');
            }
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof refreshAccessTokenRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(refreshAccessTokenRequest !== undefined ? refreshAccessTokenRequest : {}) : (refreshAccessTokenRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/accounts/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/accounts/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling login.');
            }
            const localVarPath = `/api/v2/accounts/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signUpRequest: SignUpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            if (signUpRequest === null || signUpRequest === undefined) {
                throw new RequiredError('signUpRequest','Required parameter signUpRequest was null or undefined when calling signup.');
            }
            const localVarPath = `/api/v2/accounts/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signUpRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signUpRequest !== undefined ? signUpRequest : {}) : (signUpRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanguage: async (updateLanguageRequest: UpdateLanguageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLanguageRequest' is not null or undefined
            if (updateLanguageRequest === null || updateLanguageRequest === undefined) {
                throw new RequiredError('updateLanguageRequest','Required parameter updateLanguageRequest was null or undefined when calling updateLanguage.');
            }
            const localVarPath = `/api/v2/accounts/language`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateLanguageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateLanguageRequest !== undefined ? updateLanguageRequest : {}) : (updateLanguageRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateOTPInitializeRequest} updateOTPInitializeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitialize: async (updateOTPInitializeRequest: UpdateOTPInitializeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOTPInitializeRequest' is not null or undefined
            if (updateOTPInitializeRequest === null || updateOTPInitializeRequest === undefined) {
                throw new RequiredError('updateOTPInitializeRequest','Required parameter updateOTPInitializeRequest was null or undefined when calling updateOTPInitialize.');
            }
            const localVarPath = `/api/v2/accounts/otp-initialize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateOTPInitializeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateOTPInitializeRequest !== undefined ? updateOTPInitializeRequest : {}) : (updateOTPInitializeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (updateOrganizationRequest: UpdateOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrganizationRequest' is not null or undefined
            if (updateOrganizationRequest === null || updateOrganizationRequest === undefined) {
                throw new RequiredError('updateOrganizationRequest','Required parameter updateOrganizationRequest was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/api/v2/accounts/organization`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateOrganizationRequest !== undefined ? updateOrganizationRequest : {}) : (updateOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (updatePasswordRequest: UpdatePasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePasswordRequest' is not null or undefined
            if (updatePasswordRequest === null || updatePasswordRequest === undefined) {
                throw new RequiredError('updatePasswordRequest','Required parameter updatePasswordRequest was null or undefined when calling updatePassword.');
            }
            const localVarPath = `/api/v2/accounts/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updatePasswordRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updatePasswordRequest !== undefined ? updatePasswordRequest : {}) : (updatePasswordRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (verifyEmailRequest: VerifyEmailRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailRequest' is not null or undefined
            if (verifyEmailRequest === null || verifyEmailRequest === undefined) {
                throw new RequiredError('verifyEmailRequest','Required parameter verifyEmailRequest was null or undefined when calling verifyEmail.');
            }
            const localVarPath = `/api/v2/accounts/verify-email`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof verifyEmailRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(verifyEmailRequest !== undefined ? verifyEmailRequest : {}) : (verifyEmailRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIP: async (clientIdentity: ClientIdentity, identifier: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientIdentity' is not null or undefined
            if (clientIdentity === null || clientIdentity === undefined) {
                throw new RequiredError('clientIdentity','Required parameter clientIdentity was null or undefined when calling verifyIP.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling verifyIP.');
            }
            const localVarPath = `/api/v2/accounts/login/verify`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientIdentity !== undefined) {
                localVarQueryParameter['clientIdentity'] = clientIdentity;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountControllerApi - functional programming interface
 * @export
 */
export const AccountControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeAccountNameRequest} changeAccountNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccountName(changeAccountNameRequest: ChangeAccountNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).changeAccountName(changeAccountNameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken1(refreshAccessTokenRequest: RefreshAccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).createAccessToken1(refreshAccessTokenRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccessToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).deleteAccessToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).getAccessToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).getAccount1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).login(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signUpRequest: SignUpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).signup(signUpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLanguage(updateLanguageRequest: UpdateLanguageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updateLanguage(updateLanguageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateOTPInitializeRequest} updateOTPInitializeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOTPInitialize(updateOTPInitializeRequest: UpdateOTPInitializeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updateOTPInitialize(updateOTPInitializeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updateOrganization(updateOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).updatePassword(updatePasswordRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(verifyEmailRequest: VerifyEmailRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).verifyEmail(verifyEmailRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountControllerApiAxiosParamCreator(configuration).verifyIP(clientIdentity, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountControllerApi - factory interface
 * @export
 */
export const AccountControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ChangeAccountNameRequest} changeAccountNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountName(changeAccountNameRequest: ChangeAccountNameRequest, options?: any): AxiosPromise<AccountDTO> {
            return AccountControllerApiFp(configuration).changeAccountName(changeAccountNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken1(refreshAccessTokenRequest: RefreshAccessTokenRequest, options?: any): AxiosPromise<AccessTokenDTO> {
            return AccountControllerApiFp(configuration).createAccessToken1(refreshAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessToken(options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).deleteAccessToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(options?: any): AxiosPromise<AccessTokenDTO> {
            return AccountControllerApiFp(configuration).getAccessToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount1(options?: any): AxiosPromise<AccountDTO> {
            return AccountControllerApiFp(configuration).getAccount1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(inlineObject: InlineObject, options?: any): AxiosPromise<LoginResponse> {
            return AccountControllerApiFp(configuration).login(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signUpRequest: SignUpRequest, options?: any): AxiosPromise<SignUpResponse> {
            return AccountControllerApiFp(configuration).signup(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateLanguageRequest} updateLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanguage(updateLanguageRequest: UpdateLanguageRequest, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updateLanguage(updateLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateOTPInitializeRequest} updateOTPInitializeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOTPInitialize(updateOTPInitializeRequest: UpdateOTPInitializeRequest, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updateOTPInitialize(updateOTPInitializeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updateOrganization(updateOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdatePasswordRequest} updatePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).updatePassword(updatePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(verifyEmailRequest: VerifyEmailRequest, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).verifyEmail(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any): AxiosPromise<void> {
            return AccountControllerApiFp(configuration).verifyIP(clientIdentity, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountControllerApi - object-oriented interface
 * @export
 * @class AccountControllerApi
 * @extends {BaseAPI}
 */
export class AccountControllerApi extends BaseAPI {
    /**
     * 
     * @param {ChangeAccountNameRequest} changeAccountNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public changeAccountName(changeAccountNameRequest: ChangeAccountNameRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).changeAccountName(changeAccountNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public createAccessToken1(refreshAccessTokenRequest: RefreshAccessTokenRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).createAccessToken1(refreshAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public deleteAccessToken(options?: any) {
        return AccountControllerApiFp(this.configuration).deleteAccessToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccessToken(options?: any) {
        return AccountControllerApiFp(this.configuration).getAccessToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public getAccount1(options?: any) {
        return AccountControllerApiFp(this.configuration).getAccount1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public login(inlineObject: InlineObject, options?: any) {
        return AccountControllerApiFp(this.configuration).login(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public signup(signUpRequest: SignUpRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).signup(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateLanguageRequest} updateLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateLanguage(updateLanguageRequest: UpdateLanguageRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).updateLanguage(updateLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateOTPInitializeRequest} updateOTPInitializeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOTPInitialize(updateOTPInitializeRequest: UpdateOTPInitializeRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOTPInitialize(updateOTPInitializeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateOrganizationRequest} updateOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).updateOrganization(updateOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdatePasswordRequest} updatePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public updatePassword(updatePasswordRequest: UpdatePasswordRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).updatePassword(updatePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public verifyEmail(verifyEmailRequest: VerifyEmailRequest, options?: any) {
        return AccountControllerApiFp(this.configuration).verifyEmail(verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClientIdentity} clientIdentity 
     * @param {string} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountControllerApi
     */
    public verifyIP(clientIdentity: ClientIdentity, identifier: string, options?: any) {
        return AccountControllerApiFp(this.configuration).verifyIP(clientIdentity, identifier, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IdentityControllerApi - axios parameter creator
 * @export
 */
export const IdentityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedIdentity: async (claim: Claim, clientIdentity: ClientIdentity, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'claim' is not null or undefined
            if (claim === null || claim === undefined) {
                throw new RequiredError('claim','Required parameter claim was null or undefined when calling getVerifiedIdentity.');
            }
            // verify required parameter 'clientIdentity' is not null or undefined
            if (clientIdentity === null || clientIdentity === undefined) {
                throw new RequiredError('clientIdentity','Required parameter clientIdentity was null or undefined when calling getVerifiedIdentity.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getVerifiedIdentity.');
            }
            const localVarPath = `/api/v2/identities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (claim !== undefined) {
                localVarQueryParameter['claim'] = claim;
            }

            if (clientIdentity !== undefined) {
                localVarQueryParameter['clientIdentity'] = clientIdentity;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityControllerApi - functional programming interface
 * @export
 */
export const IdentityControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityDTO>> {
            const localVarAxiosArgs = await IdentityControllerApiAxiosParamCreator(configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IdentityControllerApi - factory interface
 * @export
 */
export const IdentityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {Claim} claim 
         * @param {ClientIdentity} clientIdentity 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any): AxiosPromise<IdentityDTO> {
            return IdentityControllerApiFp(configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityControllerApi - object-oriented interface
 * @export
 * @class IdentityControllerApi
 * @extends {BaseAPI}
 */
export class IdentityControllerApi extends BaseAPI {
    /**
     * 
     * @param {Claim} claim 
     * @param {ClientIdentity} clientIdentity 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityControllerApi
     */
    public getVerifiedIdentity(claim: Claim, clientIdentity: ClientIdentity, accountId: string, options?: any) {
        return IdentityControllerApiFp(this.configuration).getVerifiedIdentity(claim, clientIdentity, accountId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OperationControllerApi - axios parameter creator
 * @export
 */
export const OperationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateBillingPlanRequest} createBillingPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPlan: async (organizationId: string, createBillingPlanRequest: CreateBillingPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling createBillingPlan.');
            }
            // verify required parameter 'createBillingPlanRequest' is not null or undefined
            if (createBillingPlanRequest === null || createBillingPlanRequest === undefined) {
                throw new RequiredError('createBillingPlanRequest','Required parameter createBillingPlanRequest was null or undefined when calling createBillingPlan.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBillingPlanRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBillingPlanRequest !== undefined ? createBillingPlanRequest : {}) : (createBillingPlanRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateCoinListingRequest} createCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinListing: async (organizationId: string, createCoinListingRequest: CreateCoinListingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling createCoinListing.');
            }
            // verify required parameter 'createCoinListingRequest' is not null or undefined
            if (createCoinListingRequest === null || createCoinListingRequest === undefined) {
                throw new RequiredError('createCoinListingRequest','Required parameter createCoinListingRequest was null or undefined when calling createCoinListing.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/coin-listing`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCoinListingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCoinListingRequest !== undefined ? createCoinListingRequest : {}) : (createCoinListingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBillingPlan: async (organizationId: string, billingPlanId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling deleteBillingPlan.');
            }
            // verify required parameter 'billingPlanId' is not null or undefined
            if (billingPlanId === null || billingPlanId === undefined) {
                throw new RequiredError('billingPlanId','Required parameter billingPlanId was null or undefined when calling deleteBillingPlan.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans/{billingPlanId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"billingPlanId"}}`, encodeURIComponent(String(billingPlanId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {DeleteCoinListingRequest} deleteCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinListing: async (organizationId: string, deleteCoinListingRequest: DeleteCoinListingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling deleteCoinListing.');
            }
            // verify required parameter 'deleteCoinListingRequest' is not null or undefined
            if (deleteCoinListingRequest === null || deleteCoinListingRequest === undefined) {
                throw new RequiredError('deleteCoinListingRequest','Required parameter deleteCoinListingRequest was null or undefined when calling deleteCoinListing.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/coin-listing`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteCoinListingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteCoinListingRequest !== undefined ? deleteCoinListingRequest : {}) : (deleteCoinListingRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccount.');
            }
            const localVarPath = `/api/v2/operation/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByEmail: async (email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getAccountByEmail.');
            }
            const localVarPath = `/api/v2/operation/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccountsByOrganizationId: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAllAccountsByOrganizationId.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/accounts`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingPlans: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAllBillingPlans.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPlan: async (organizationId: string, billingPlanId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getBillingPlan.');
            }
            // verify required parameter 'billingPlanId' is not null or undefined
            if (billingPlanId === null || billingPlanId === undefined) {
                throw new RequiredError('billingPlanId','Required parameter billingPlanId was null or undefined when calling getBillingPlan.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans/{billingPlanId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"billingPlanId"}}`, encodeURIComponent(String(billingPlanId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInfo: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getOrganizationInfo.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationsInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/operation/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanChargeRequest} updateBillingPlanChargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBillingPlanCharge: async (organizationId: string, billingPlanId: string, updateBillingPlanChargeRequest: UpdateBillingPlanChargeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling updateBillingPlanCharge.');
            }
            // verify required parameter 'billingPlanId' is not null or undefined
            if (billingPlanId === null || billingPlanId === undefined) {
                throw new RequiredError('billingPlanId','Required parameter billingPlanId was null or undefined when calling updateBillingPlanCharge.');
            }
            // verify required parameter 'updateBillingPlanChargeRequest' is not null or undefined
            if (updateBillingPlanChargeRequest === null || updateBillingPlanChargeRequest === undefined) {
                throw new RequiredError('updateBillingPlanChargeRequest','Required parameter updateBillingPlanChargeRequest was null or undefined when calling updateBillingPlanCharge.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans/{billingPlanId}/charge`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"billingPlanId"}}`, encodeURIComponent(String(billingPlanId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateBillingPlanChargeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateBillingPlanChargeRequest !== undefined ? updateBillingPlanChargeRequest : {}) : (updateBillingPlanChargeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanPeriodRequest} updateBillingPlanPeriodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBillingPlanPeriod: async (organizationId: string, billingPlanId: string, updateBillingPlanPeriodRequest: UpdateBillingPlanPeriodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling updateBillingPlanPeriod.');
            }
            // verify required parameter 'billingPlanId' is not null or undefined
            if (billingPlanId === null || billingPlanId === undefined) {
                throw new RequiredError('billingPlanId','Required parameter billingPlanId was null or undefined when calling updateBillingPlanPeriod.');
            }
            // verify required parameter 'updateBillingPlanPeriodRequest' is not null or undefined
            if (updateBillingPlanPeriodRequest === null || updateBillingPlanPeriodRequest === undefined) {
                throw new RequiredError('updateBillingPlanPeriodRequest','Required parameter updateBillingPlanPeriodRequest was null or undefined when calling updateBillingPlanPeriod.');
            }
            const localVarPath = `/api/v2/operation/organizations/{organizationId}/billing-plans/{billingPlanId}/period`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"billingPlanId"}}`, encodeURIComponent(String(billingPlanId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateBillingPlanPeriodRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateBillingPlanPeriodRequest !== undefined ? updateBillingPlanPeriodRequest : {}) : (updateBillingPlanPeriodRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationControllerApi - functional programming interface
 * @export
 */
export const OperationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateBillingPlanRequest} createBillingPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBillingPlan(organizationId: string, createBillingPlanRequest: CreateBillingPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingPlanDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).createBillingPlan(organizationId, createBillingPlanRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateCoinListingRequest} createCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoinListing(organizationId: string, createCoinListingRequest: CreateCoinListingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinListingDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).createCoinListing(organizationId, createCoinListingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBillingPlan(organizationId: string, billingPlanId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).deleteBillingPlan(organizationId, billingPlanId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {DeleteCoinListingRequest} deleteCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoinListing(organizationId: string, deleteCoinListingRequest: DeleteCoinListingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).deleteCoinListing(organizationId, deleteCoinListingRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getAccount(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByEmail(email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getAccountByEmail(email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAccountsByOrganizationId(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountDTO>>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getAllAccountsByOrganizationId(organizationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBillingPlans(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingPlanDTO>>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getAllBillingPlans(organizationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBillingPlan(organizationId: string, billingPlanId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingPlanDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getBillingPlan(organizationId, billingPlanId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInfo(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationInfoDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getOrganizationInfo(organizationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationsInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationInfoDTO>>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).getOrganizationsInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanChargeRequest} updateBillingPlanChargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBillingPlanCharge(organizationId: string, billingPlanId: string, updateBillingPlanChargeRequest: UpdateBillingPlanChargeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingPlanDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).updateBillingPlanCharge(organizationId, billingPlanId, updateBillingPlanChargeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanPeriodRequest} updateBillingPlanPeriodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBillingPlanPeriod(organizationId: string, billingPlanId: string, updateBillingPlanPeriodRequest: UpdateBillingPlanPeriodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingPlanDTO>> {
            const localVarAxiosArgs = await OperationControllerApiAxiosParamCreator(configuration).updateBillingPlanPeriod(organizationId, billingPlanId, updateBillingPlanPeriodRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OperationControllerApi - factory interface
 * @export
 */
export const OperationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateBillingPlanRequest} createBillingPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPlan(organizationId: string, createBillingPlanRequest: CreateBillingPlanRequest, options?: any): AxiosPromise<BillingPlanDTO> {
            return OperationControllerApiFp(configuration).createBillingPlan(organizationId, createBillingPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {CreateCoinListingRequest} createCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoinListing(organizationId: string, createCoinListingRequest: CreateCoinListingRequest, options?: any): AxiosPromise<CoinListingDTO> {
            return OperationControllerApiFp(configuration).createCoinListing(organizationId, createCoinListingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBillingPlan(organizationId: string, billingPlanId: string, options?: any): AxiosPromise<void> {
            return OperationControllerApiFp(configuration).deleteBillingPlan(organizationId, billingPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {DeleteCoinListingRequest} deleteCoinListingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoinListing(organizationId: string, deleteCoinListingRequest: DeleteCoinListingRequest, options?: any): AxiosPromise<void> {
            return OperationControllerApiFp(configuration).deleteCoinListing(organizationId, deleteCoinListingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options?: any): AxiosPromise<AccountDTO> {
            return OperationControllerApiFp(configuration).getAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByEmail(email: string, options?: any): AxiosPromise<AccountDTO> {
            return OperationControllerApiFp(configuration).getAccountByEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccountsByOrganizationId(organizationId: string, options?: any): AxiosPromise<Array<AccountDTO>> {
            return OperationControllerApiFp(configuration).getAllAccountsByOrganizationId(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingPlans(organizationId: string, options?: any): AxiosPromise<Array<BillingPlanDTO>> {
            return OperationControllerApiFp(configuration).getAllBillingPlans(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPlan(organizationId: string, billingPlanId: string, options?: any): AxiosPromise<BillingPlanDTO> {
            return OperationControllerApiFp(configuration).getBillingPlan(organizationId, billingPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInfo(organizationId: string, options?: any): AxiosPromise<OrganizationInfoDTO> {
            return OperationControllerApiFp(configuration).getOrganizationInfo(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationsInfo(options?: any): AxiosPromise<Array<OrganizationInfoDTO>> {
            return OperationControllerApiFp(configuration).getOrganizationsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanChargeRequest} updateBillingPlanChargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBillingPlanCharge(organizationId: string, billingPlanId: string, updateBillingPlanChargeRequest: UpdateBillingPlanChargeRequest, options?: any): AxiosPromise<BillingPlanDTO> {
            return OperationControllerApiFp(configuration).updateBillingPlanCharge(organizationId, billingPlanId, updateBillingPlanChargeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} billingPlanId 
         * @param {UpdateBillingPlanPeriodRequest} updateBillingPlanPeriodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBillingPlanPeriod(organizationId: string, billingPlanId: string, updateBillingPlanPeriodRequest: UpdateBillingPlanPeriodRequest, options?: any): AxiosPromise<BillingPlanDTO> {
            return OperationControllerApiFp(configuration).updateBillingPlanPeriod(organizationId, billingPlanId, updateBillingPlanPeriodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationControllerApi - object-oriented interface
 * @export
 * @class OperationControllerApi
 * @extends {BaseAPI}
 */
export class OperationControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} organizationId 
     * @param {CreateBillingPlanRequest} createBillingPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public createBillingPlan(organizationId: string, createBillingPlanRequest: CreateBillingPlanRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).createBillingPlan(organizationId, createBillingPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {CreateCoinListingRequest} createCoinListingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public createCoinListing(organizationId: string, createCoinListingRequest: CreateCoinListingRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).createCoinListing(organizationId, createCoinListingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} billingPlanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public deleteBillingPlan(organizationId: string, billingPlanId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).deleteBillingPlan(organizationId, billingPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {DeleteCoinListingRequest} deleteCoinListingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public deleteCoinListing(organizationId: string, deleteCoinListingRequest: DeleteCoinListingRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).deleteCoinListing(organizationId, deleteCoinListingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getAccount(accountId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getAccountByEmail(email: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getAccountByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getAllAccountsByOrganizationId(organizationId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getAllAccountsByOrganizationId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getAllBillingPlans(organizationId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getAllBillingPlans(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} billingPlanId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getBillingPlan(organizationId: string, billingPlanId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getBillingPlan(organizationId, billingPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getOrganizationInfo(organizationId: string, options?: any) {
        return OperationControllerApiFp(this.configuration).getOrganizationInfo(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public getOrganizationsInfo(options?: any) {
        return OperationControllerApiFp(this.configuration).getOrganizationsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} billingPlanId 
     * @param {UpdateBillingPlanChargeRequest} updateBillingPlanChargeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public updateBillingPlanCharge(organizationId: string, billingPlanId: string, updateBillingPlanChargeRequest: UpdateBillingPlanChargeRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).updateBillingPlanCharge(organizationId, billingPlanId, updateBillingPlanChargeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} billingPlanId 
     * @param {UpdateBillingPlanPeriodRequest} updateBillingPlanPeriodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationControllerApi
     */
    public updateBillingPlanPeriod(organizationId: string, billingPlanId: string, updateBillingPlanPeriodRequest: UpdateBillingPlanPeriodRequest, options?: any) {
        return OperationControllerApiFp(this.configuration).updateBillingPlanPeriod(organizationId, billingPlanId, updateBillingPlanPeriodRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrganizationControllerApi - axios parameter creator
 * @export
 */
export const OrganizationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ActivateAllowedIpsRequest} activateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedIps: async (activateAllowedIpsRequest: ActivateAllowedIpsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activateAllowedIpsRequest' is not null or undefined
            if (activateAllowedIpsRequest === null || activateAllowedIpsRequest === undefined) {
                throw new RequiredError('activateAllowedIpsRequest','Required parameter activateAllowedIpsRequest was null or undefined when calling activateAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/activate-allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof activateAllowedIpsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(activateAllowedIpsRequest !== undefined ? activateAllowedIpsRequest : {}) : (activateAllowedIpsRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAllowedIpRequest} createAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedIp: async (createAllowedIpRequest: CreateAllowedIpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAllowedIpRequest' is not null or undefined
            if (createAllowedIpRequest === null || createAllowedIpRequest === undefined) {
                throw new RequiredError('createAllowedIpRequest','Required parameter createAllowedIpRequest was null or undefined when calling createAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAllowedIpRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAllowedIpRequest !== undefined ? createAllowedIpRequest : {}) : (createAllowedIpRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationRequest: CreateOrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            if (createOrganizationRequest === null || createOrganizationRequest === undefined) {
                throw new RequiredError('createOrganizationRequest','Required parameter createOrganizationRequest was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/api/v2/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createOrganizationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createOrganizationRequest !== undefined ? createOrganizationRequest : {}) : (createOrganizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations/secret`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {DeleteAllowedIpRequest} deleteAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedIp: async (allowedIpId: string, deleteAllowedIpRequest: DeleteAllowedIpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling deleteAllowedIp.');
            }
            // verify required parameter 'deleteAllowedIpRequest' is not null or undefined
            if (deleteAllowedIpRequest === null || deleteAllowedIpRequest === undefined) {
                throw new RequiredError('deleteAllowedIpRequest','Required parameter deleteAllowedIpRequest was null or undefined when calling deleteAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteAllowedIpRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteAllowedIpRequest !== undefined ? deleteAllowedIpRequest : {}) : (deleteAllowedIpRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationId: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIp: async (allowedIpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling getAllowedIp.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIps: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/organizations/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InactivateAllowedIpsRequest} inactivateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedIps: async (inactivateAllowedIpsRequest: InactivateAllowedIpsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inactivateAllowedIpsRequest' is not null or undefined
            if (inactivateAllowedIpsRequest === null || inactivateAllowedIpsRequest === undefined) {
                throw new RequiredError('inactivateAllowedIpsRequest','Required parameter inactivateAllowedIpsRequest was null or undefined when calling inactivateAllowedIps.');
            }
            const localVarPath = `/api/v2/organizations/inactivate-allowed-ips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inactivateAllowedIpsRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inactivateAllowedIpsRequest !== undefined ? inactivateAllowedIpsRequest : {}) : (inactivateAllowedIpsRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotifyRequest} notifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify: async (notifyRequest: NotifyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notifyRequest' is not null or undefined
            if (notifyRequest === null || notifyRequest === undefined) {
                throw new RequiredError('notifyRequest','Required parameter notifyRequest was null or undefined when calling notify.');
            }
            const localVarPath = `/api/v2/organizations/notify`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof notifyRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(notifyRequest !== undefined ? notifyRequest : {}) : (notifyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRole: async (accountId: string, patchAccountRoleRequest: PatchAccountRoleRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling patchAccountRole.');
            }
            // verify required parameter 'patchAccountRoleRequest' is not null or undefined
            if (patchAccountRoleRequest === null || patchAccountRoleRequest === undefined) {
                throw new RequiredError('patchAccountRoleRequest','Required parameter patchAccountRoleRequest was null or undefined when calling patchAccountRole.');
            }
            const localVarPath = `/api/v2/organizations/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAccountRoleRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAccountRoleRequest !== undefined ? patchAccountRoleRequest : {}) : (patchAccountRoleRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {PatchAllowedIpLabelRequest} patchAllowedIpLabelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedIpLabel: async (allowedIpId: string, patchAllowedIpLabelRequest: PatchAllowedIpLabelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'allowedIpId' is not null or undefined
            if (allowedIpId === null || allowedIpId === undefined) {
                throw new RequiredError('allowedIpId','Required parameter allowedIpId was null or undefined when calling patchAllowedIpLabel.');
            }
            // verify required parameter 'patchAllowedIpLabelRequest' is not null or undefined
            if (patchAllowedIpLabelRequest === null || patchAllowedIpLabelRequest === undefined) {
                throw new RequiredError('patchAllowedIpLabelRequest','Required parameter patchAllowedIpLabelRequest was null or undefined when calling patchAllowedIpLabel.');
            }
            const localVarPath = `/api/v2/organizations/allowed-ips/{allowedIpId}/label`
                .replace(`{${"allowedIpId"}}`, encodeURIComponent(String(allowedIpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchAllowedIpLabelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchAllowedIpLabelRequest !== undefined ? patchAllowedIpLabelRequest : {}) : (patchAllowedIpLabelRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationControllerApi - functional programming interface
 * @export
 */
export const OrganizationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ActivateAllowedIpsRequest} activateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllowedIps(activateAllowedIpsRequest: ActivateAllowedIpsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).activateAllowedIps(activateAllowedIpsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateAllowedIpRequest} createAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllowedIp(createAllowedIpRequest: CreateAllowedIpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createAllowedIp(createAllowedIpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createOrganization(createOrganizationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSecretResponse>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).createSecret(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {DeleteAllowedIpRequest} deleteAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllowedIp(allowedIpId: string, deleteAllowedIpRequest: DeleteAllowedIpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).deleteAllowedIp(allowedIpId, deleteAllowedIpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByOrganizationId(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgAccountDTO>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAccountByOrganizationId(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationDTO>>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAllOrganizations(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedIp(allowedIpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAllowedIp(allowedIpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllowedIps(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationAllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getAllowedIps(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).getOrganization(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InactivateAllowedIpsRequest} inactivateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inactivateAllowedIps(inactivateAllowedIpsRequest: InactivateAllowedIpsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).inactivateAllowedIps(inactivateAllowedIpsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {NotifyRequest} notifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notify(notifyRequest: NotifyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).notify(notifyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountRole(accountId: string, patchAccountRoleRequest: PatchAccountRoleRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).patchAccountRole(accountId, patchAccountRoleRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {PatchAllowedIpLabelRequest} patchAllowedIpLabelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAllowedIpLabel(allowedIpId: string, patchAllowedIpLabelRequest: PatchAllowedIpLabelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowedIpDTO>> {
            const localVarAxiosArgs = await OrganizationControllerApiAxiosParamCreator(configuration).patchAllowedIpLabel(allowedIpId, patchAllowedIpLabelRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationControllerApi - factory interface
 * @export
 */
export const OrganizationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ActivateAllowedIpsRequest} activateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllowedIps(activateAllowedIpsRequest: ActivateAllowedIpsRequest, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).activateAllowedIps(activateAllowedIpsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAllowedIpRequest} createAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowedIp(createAllowedIpRequest: CreateAllowedIpRequest, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).createAllowedIp(createAllowedIpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): AxiosPromise<OrganizationDTO> {
            return OrganizationControllerApiFp(configuration).createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(options?: any): AxiosPromise<CreateSecretResponse> {
            return OrganizationControllerApiFp(configuration).createSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {DeleteAllowedIpRequest} deleteAllowedIpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowedIp(allowedIpId: string, deleteAllowedIpRequest: DeleteAllowedIpRequest, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).deleteAllowedIp(allowedIpId, deleteAllowedIpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByOrganizationId(options?: any): AxiosPromise<Array<OrgAccountDTO>> {
            return OrganizationControllerApiFp(configuration).getAccountByOrganizationId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options?: any): AxiosPromise<Array<OrganizationDTO>> {
            return OrganizationControllerApiFp(configuration).getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIp(allowedIpId: string, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).getAllowedIp(allowedIpId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedIps(pageable: Pageable, options?: any): AxiosPromise<PaginationAllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).getAllowedIps(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any): AxiosPromise<OrganizationDTO> {
            return OrganizationControllerApiFp(configuration).getOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InactivateAllowedIpsRequest} inactivateAllowedIpsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateAllowedIps(inactivateAllowedIpsRequest: InactivateAllowedIpsRequest, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).inactivateAllowedIps(inactivateAllowedIpsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotifyRequest} notifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify(notifyRequest: NotifyRequest, options?: any): AxiosPromise<void> {
            return OrganizationControllerApiFp(configuration).notify(notifyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {PatchAccountRoleRequest} patchAccountRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountRole(accountId: string, patchAccountRoleRequest: PatchAccountRoleRequest, options?: any): AxiosPromise<AccountDTO> {
            return OrganizationControllerApiFp(configuration).patchAccountRole(accountId, patchAccountRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} allowedIpId 
         * @param {PatchAllowedIpLabelRequest} patchAllowedIpLabelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAllowedIpLabel(allowedIpId: string, patchAllowedIpLabelRequest: PatchAllowedIpLabelRequest, options?: any): AxiosPromise<AllowedIpDTO> {
            return OrganizationControllerApiFp(configuration).patchAllowedIpLabel(allowedIpId, patchAllowedIpLabelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationControllerApi - object-oriented interface
 * @export
 * @class OrganizationControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationControllerApi extends BaseAPI {
    /**
     * 
     * @param {ActivateAllowedIpsRequest} activateAllowedIpsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public activateAllowedIps(activateAllowedIpsRequest: ActivateAllowedIpsRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).activateAllowedIps(activateAllowedIpsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAllowedIpRequest} createAllowedIpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createAllowedIp(createAllowedIpRequest: CreateAllowedIpRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createAllowedIp(createAllowedIpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrganizationRequest} createOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public createSecret(options?: any) {
        return OrganizationControllerApiFp(this.configuration).createSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {DeleteAllowedIpRequest} deleteAllowedIpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public deleteAllowedIp(allowedIpId: string, deleteAllowedIpRequest: DeleteAllowedIpRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).deleteAllowedIp(allowedIpId, deleteAllowedIpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAccountByOrganizationId(options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAccountByOrganizationId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAllOrganizations(options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAllowedIp(allowedIpId: string, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAllowedIp(allowedIpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getAllowedIps(pageable: Pageable, options?: any) {
        return OrganizationControllerApiFp(this.configuration).getAllowedIps(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public getOrganization(options?: any) {
        return OrganizationControllerApiFp(this.configuration).getOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InactivateAllowedIpsRequest} inactivateAllowedIpsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public inactivateAllowedIps(inactivateAllowedIpsRequest: InactivateAllowedIpsRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).inactivateAllowedIps(inactivateAllowedIpsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotifyRequest} notifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public notify(notifyRequest: NotifyRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).notify(notifyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {PatchAccountRoleRequest} patchAccountRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public patchAccountRole(accountId: string, patchAccountRoleRequest: PatchAccountRoleRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).patchAccountRole(accountId, patchAccountRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} allowedIpId 
     * @param {PatchAllowedIpLabelRequest} patchAllowedIpLabelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    public patchAllowedIpLabel(allowedIpId: string, patchAllowedIpLabelRequest: PatchAllowedIpLabelRequest, options?: any) {
        return OrganizationControllerApiFp(this.configuration).patchAllowedIpLabel(allowedIpId, patchAllowedIpLabelRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WithdrawalApprovalControllerApi - axios parameter creator
 * @export
 */
export const WithdrawalApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: async (withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling approve.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/approve`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApproval: async (withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-approval`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejection: async (withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling cancelRejection.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/cancel-rejection`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApproval: async (createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWithdrawalApprovalRequest' is not null or undefined
            if (createWithdrawalApprovalRequest === null || createWithdrawalApprovalRequest === undefined) {
                throw new RequiredError('createWithdrawalApprovalRequest','Required parameter createWithdrawalApprovalRequest was null or undefined when calling createWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalApprovalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalApprovalRequest !== undefined ? createWithdrawalApprovalRequest : {}) : (createWithdrawalApprovalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApproval: async (withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling getWithdrawalApproval.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovals: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getWithdrawalApprovals.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject: async (withdrawalApprovalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalApprovalId' is not null or undefined
            if (withdrawalApprovalId === null || withdrawalApprovalId === undefined) {
                throw new RequiredError('withdrawalApprovalId','Required parameter withdrawalApprovalId was null or undefined when calling reject.');
            }
            const localVarPath = `/api/v2/withdrawal-approvals/{withdrawalApprovalId}/reject`
                .replace(`{${"withdrawalApprovalId"}}`, encodeURIComponent(String(withdrawalApprovalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - functional programming interface
 * @export
 */
export const WithdrawalApprovalControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approve(withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).approve(withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelApproval(withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).cancelApproval(withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelRejection(withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).cancelRejection(withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawalApproval(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).createWithdrawalApproval(createWithdrawalApprovalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalApproval(withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).getWithdrawalApproval(withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalApprovals(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationWithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).getWithdrawalApprovals(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reject(withdrawalApprovalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalApprovalDTO>> {
            const localVarAxiosArgs = await WithdrawalApprovalControllerApiAxiosParamCreator(configuration).reject(withdrawalApprovalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WithdrawalApprovalControllerApi - factory interface
 * @export
 */
export const WithdrawalApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).approve(withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApproval(withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).cancelApproval(withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRejection(withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).cancelRejection(withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawalApproval(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).createWithdrawalApproval(createWithdrawalApprovalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApproval(withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApproval(withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalApprovals(pageable: Pageable, options?: any): AxiosPromise<PaginationWithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).getWithdrawalApprovals(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} withdrawalApprovalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject(withdrawalApprovalId: string, options?: any): AxiosPromise<WithdrawalApprovalDTO> {
            return WithdrawalApprovalControllerApiFp(configuration).reject(withdrawalApprovalId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApprovalControllerApi - object-oriented interface
 * @export
 * @class WithdrawalApprovalControllerApi
 * @extends {BaseAPI}
 */
export class WithdrawalApprovalControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public approve(withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).approve(withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelApproval(withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelApproval(withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public cancelRejection(withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).cancelRejection(withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWithdrawalApprovalRequest} createWithdrawalApprovalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public createWithdrawalApproval(createWithdrawalApprovalRequest: CreateWithdrawalApprovalRequest, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).createWithdrawalApproval(createWithdrawalApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApproval(withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApproval(withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public getWithdrawalApprovals(pageable: Pageable, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).getWithdrawalApprovals(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} withdrawalApprovalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApprovalControllerApi
     */
    public reject(withdrawalApprovalId: string, options?: any) {
        return WithdrawalApprovalControllerApiFp(this.configuration).reject(withdrawalApprovalId, options).then((request) => request(this.axios, this.basePath));
    }

}


